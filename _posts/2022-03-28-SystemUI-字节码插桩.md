---
layout:     post
title:      "SystemUI-字节码插桩"
subtitle:   ""
date:       2022-03-28 12:00:00
author:     "Yaku"
header-img: "img/post-bg-2015.jpg"
tags:
    - Android
    - SystemUI
---



# 1.java_genrule介绍

在阅读系统源码时，发现了一个有意思的工具lockedregioncodeinjection，从命名来看是对锁处理的地方做代码插桩，其使用的代码如下：

```Java
java_genrule {
    name: "services.core.priorityboosted",
    srcs: [":services.core.unboosted"],
    tools: ["lockedregioncodeinjection"],
    cmd: "$(location lockedregioncodeinjection) " +
        "  --targets \"Lcom/android/server/am/ActivityManagerService;,Lcom/android/server/wm/WindowManagerGlobalLock;\" " +
        "  --pre \"com/android/server/am/ActivityManagerService.boostPriorityForLockedSection,com/android/server/wm/WindowManagerService.boostPriorityForLockedSection\" " +
        "  --post \"com/android/server/am/ActivityManagerService.resetPriorityAfterLockedSection,com/android/server/wm/WindowManagerService.resetPriorityAfterLockedSection\" " +
        "  -o $(out) " +
        "  -i $(in)",
    out: ["services.core.priorityboosted.jar"],
}
```

从源码中查找 java_genrule 的定义：

```Plain
// genrule.go

java_genrule is a genrule that can depend on other java_* objects.

By default a java_genrule has a single variant that will run against the device variant of its dependencies and
produce an output that can be used as an input to a device java rule.

Specifying `host_supported: true` will produce two variants, one that uses device dependencies and one that uses
host dependencies.  Each variant will run the command.

Use a java_genrule instead of a genrule when it needs to depend on or be depended on by other java modules, unless
the dependency is for a generated source file.

Examples:

Use a java_genrule to package generated java resources:

    java_genrule {
        name: "generated_resources",
        tools: [
            "generator",
            "soong_zip",
        ],
        srcs: ["generator_inputs/**/*"],
        out: ["generated_android_icu4j_resources.jar"],
        cmd: "$(location generator) $(in) -o $(genDir) " +
            "&& $(location soong_zip) -o $(out) -C $(genDir)/res -D $(genDir)/res",
    }

    java_library {
        name: "lib_with_generated_resources",
        srcs: ["src/**/*.java"],
        static_libs: ["generated_resources"],
    }
```

大意是 java_genrule 是一个依赖其他 java_* 对象的生成规则，比如java_library。这里的cmd参数是要执行的命令，tools是命令中使用的工具，srcs是输入文件，out是输出文件。

接着查找lockedregioncodeinjection工具的位置：

```SQL
java_binary_host {
    name: "lockedregioncodeinjection",
    manifest: "manifest.txt",
    srcs: ["src/**/*.java"],
    static_libs: [
        "asm-9.2",
        "asm-commons-9.2",
        "asm-tree-9.2",
        "asm-analysis-9.2",
        "guava-21.0",
    ],
}
```

可以看到lockedregioncodeinjection是一个可运行的jar包，其入口定义在manifest.txt：

```Plain
Main-Class: lockedregioncodeinjection.Main
```

整个jar包入口在工程的Main类中：

```Java
public static void main(String[] args) throws IOException {
    String inJar = null;
    String outJar = null;

    String legacyTargets = null;
    String legacyPreMethods = null;
    String legacyPostMethods = null;
    for (int i = 0; i < args.length; i++) {
        if ("-i".equals(args[i].trim())) {
            i++;
            inJar = args[i].trim();
        } else if ("-o".equals(args[i].trim())) {
            i++;
            outJar = args[i].trim();
        } else if ("--targets".equals(args[i].trim())) {
            i++;
            legacyTargets = args[i].trim();
        } else if ("--pre".equals(args[i].trim())) {
            i++;
            legacyPreMethods = args[i].trim();
        } else if ("--post".equals(args[i].trim())) {
            i++;
            legacyPostMethods = args[i].trim();
        }

    }

    // TODO(acleung): Better help message than asserts.
    assert inJar != null;
    assert outJar != null;
    assert legacyTargets == null || (legacyPreMethods != null && legacyPostMethods != null);

    ZipFile zipSrc = new ZipFile(inJar);
    ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(outJar));
    List<LockTarget> targets = null;
    if (legacyTargets != null) {
        targets = Utils.getTargetsFromLegacyJackConfig(legacyTargets, legacyPreMethods,
                legacyPostMethods);
    } else {
        targets = Collections.emptyList();
    }

    Enumeration<? extends ZipEntry> srcEntries = zipSrc.entries();
    while (srcEntries.hasMoreElements()) {
        ZipEntry entry = srcEntries.nextElement();
        ZipEntry newEntry = new ZipEntry(entry.getName());
        newEntry.setTime(entry.getTime());
        zos.putNextEntry(newEntry);
        BufferedInputStream bis = new BufferedInputStream(zipSrc.getInputStream(entry));

        if (entry.getName().endsWith(".class")) {
            convert(bis, zos, targets);
        } else {
            while (bis.available() > 0) {
                zos.write(bis.read());
            }
            zos.closeEntry();
            bis.close();
        }
    }
    zos.finish();
    zos.close();
    zipSrc.close();
}
```

核心逻辑为解析命令参数，对代码做插桩。

如何使用生成的 services.core.priorityboosted.jar 呢？可以看到 java_genrule 可以像其他 java_* 对象一样，直接作为编译依赖项。

```Plain
java_library {
    name: "services.core",
    static_libs: ["services.core.priorityboosted"],
}
```



# 2.应用字节码插桩

无论是Gradle编译还是bp编译，其核心流程都是一致的，在编译前都会生成基于拓扑排序的编译依赖关系。基于SystemUI的Android.bp文件，来分析下编译依赖关系：

```Plain
android_app {
    name: "SystemUI",
    defaults: [

    ],
    static_libs: [
        "SystemUI-core",
    ],
    resource_dirs: [],

    platform_apis: true,
    system_ext_specific: true,
    certificate: "platform",
    privileged: true,

    libs: [
        "android.car",
        "ims-common",
        "extphonelib",
    ],
    enforce_uses_libs: false,

    kotlincflags: ["-Xjvm-default=enable"],

    dxflags: ["--multi-dex"],
    required: [
        "privapp_whitelist_com.android.systemui",
    ],
}
```

可以看到编译SystemUI.apk主要依赖SystemUI-core，

```Plain
android_app {
    name: "SystemUI",
    static_libs: [
        "SystemUI-core",
    ],
    resource_dirs: [],

    platform_apis: true,
    product_specific: true,
    certificate: "platform",
    privileged: true,

    optimize: {
        proguard_flags_files: ["proguard.flags"],
    },

    libs: [
        "android.car",
        "android.car.userlib",
        "ims-common",
        "telephony-common",
        "telephony-ext",
        "miuisdk",
    ],

    kotlincflags: ["-Xjvm-default=enable"],

    dxflags: ["--multi-dex"],
    required: ["privapp_whitelist_com.android.systemui"],

}

android_library {
    name: "SystemUI-core",
    srcs: [
        "src/**/*.kt",
        "src/**/*.java",
        "src/**/I*.aidl",
    ],
    resource_dirs: [
        "res-keyguard",
        "res",
    ],
    static_libs: [
        "SystemUIPluginLib",
        "SystemUISharedLib",
        "SettingsLib",
        "androidx.legacy_legacy-support-v4",
        "androidx.recyclerview_recyclerview",
        "androidx.preference_preference",
        "androidx.appcompat_appcompat",
        "androidx.mediarouter_mediarouter",
        "androidx.palette_palette",
        "androidx.legacy_legacy-preference-v14",
        "androidx.leanback_leanback",
        "androidx.slice_slice-core",
        "androidx.slice_slice-view",
        "androidx.slice_slice-builders",
        "androidx.arch.core_core-runtime",
        "androidx.lifecycle_lifecycle-extensions",
        "androidx.dynamicanimation_dynamicanimation",
        "androidx-constraintlayout_constraintlayout",
        "iconloader_base",
        "SystemUI-tags",
        "SystemUI-proto",
        "dagger2-2.19",
        "jsr330"
    ],
    manifest: "AndroidManifest.xml",

    libs: [
        "android.car",
        "android.car.userlib",
        "telephony-common",
        "telephony-ext",
        "ims-common",
        "miuisdk",
    ],

    kotlincflags: ["-Xjvm-default=enable"],

    plugins: ["dagger2-compiler-2.19"],
}
```

而SystemUI-core是一个jar包，可以在这二者之间插入java_genrule实现代码插桩，示例如下：

```Plain
genrule {
    name: "SystemUI-codeinjection",
    srcs: [":SystemUI-core"],
    tools: ["xx"],
    cmd: "xx"
    out: ["SystemUI-core-codeinjection.jar"],
}

android_app {
    name: "SystemUI",
    static_libs: [
        "SystemUI-codeinjection",
    ],
    ...
}
```



# 3.ASM简介

ASM 库提供了两个用于生成和转换已编译类的 API，一个是核心 API，以基于事件的形式来表示类，另一个是树 API，以基于对象的形式来表示类。

| 包名                            | 功能                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| org.objectweb.asm               | 基于事件的 API，提供 ClassReader 和 ClassWriter 类读写Java字节码文件。 |
| org.objectweb.asm.signature     | 读写泛型签名。                                               |
| org.objectweb.asm.tree          | 基于对象的 API，提供了一些工具，用于在基于事件和基于对象的表示方法之间进行转换。 |
| org.objectweb.asm.tree.analysis | 以树 API 为基础，提供了一个类分析框架和几个预定义的类分析器。 |
| org.objectweb.asm.commons       | 提供了一些很有用的基于核心包和tree包的预定义adapters。       |
| org.objectweb.asm.util          | 提供各种基于核心 API 的工具，可以在开发和调试 ASM 应用程序时使用。 |

 

**1.核心api**

ASM 提供了三个基于 MethodVisitor API 的核心组件，用于生成和转换方法：

ClassReader 类分析已编译方法的内容，在其 accept 方法的参数中传送了 ClassVisitor ， ClassReader 类将针对这一 ClassVisitor 返回的 MethodVisitor 对象调用相应方法。

ClassWriter 的 visitMethod 方法返回 MethodVisitor 接口的一个实现，它直接以二进制形式生成已编译方法。

MethodVisitor 类将它接收到的所有方法调用委托给另一个MethodVisitor 方法。可以将它看作一个事件筛选器。

**2.树api**

核心api的封装或默认实现。

ClassNode继承于ClassVisitor，描述类结构。

FieldNode继承于FieldVisitor，描述类成员变量。

MethodNode继承于MethodVisitor，描述类方法。

MethodInsnNode继承于AbstractInsnNode，描述方法中的指令。

InsnList是双链表，结点是AbstractInsnNode。

AbstractInsnNode是字节码指令的节点。

 

树 API 通常用于那些不能由核心 API 一次实现的转换。使用树 API 转换类时，所花费的时间和占用的内存也要多于使用核心 API 的时候。但使用树 API 有可能使一些转换的实现更为容易。

 

**示例：**

ClassNode可以通过读取字节码创建：

```Java
 ClassReader classReader = new ClassReader(source);
 ClassNode classNode = new ClassNode();
 classReader.accept(classNode, 0);
```

现在可以修改ClassNode的内容并序列化写回：

```Java
  ClassWriter classWriter = new ClassWriter(0);
  classNode.accept(classWriter);
```

使用ClassVisitor为每一个方法创建MethodNode实例。此例中MethodNode充当缓冲区在调用visitEnd()方法时刷新：

```Java
  ClassReader classReader = new ClassReader(source);
  ClassWriter classWriter = new ClassWriter(0);
  ClassVisitor classVisitor = new ClassVisitor(ASM7, classWriter) {
    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
      final MethodVisitor methodVisitor = super.visitMethod(access, name, desc, signature, exceptions);
      MethodNode methodNode = new MethodNode(access, name, desc, signature, exceptions) {
        public void visitEnd() {
          // transform or analyze method code using tree API
          accept(methodVisitor);
        }
      };
    }
  };
  classReader.accept(classVisitor, 0);
```

可以通过以下两种方式构造方法代码：

1.使用tree api，通过创建XxxInsnNode实例来添加：

```Java
  MethodNode methodNode = new MethodNode(...);
  methodNode.instructions.add(new VarInsnNode(ALOAD, 0));
  ...
```

2.使用核心api，直接调用MethodVisitor方法来添加：

```Java
  MethodNode methodNode = new MethodNode(...);
  methodNode.visitVarInsn(ALOAD, 0);
  ...
```

 

如果无法按顺序生成所有指令，例如你需要预埋一些点等待其他指令生成后插入。可以使用InsnList的insert()和insertBefore() 方法实现：

```Java
  MethodNode methodNode = new MethodNode(...);
  methodNode.visitVarInsn(ALOAD, 0);
  AbstractInsnNode ptr = methodNode.instructions.getLast();
  methodNode.visitVarInsn(ALOAD, 1);
  // inserts an instruction between ALOAD 0 and ALOAD 1
  methodNode.instructions.insert(ptr, new VarInsnNode(ALOAD, 0));
  ...
```

 

可以通过如下两种方式在指令列表中插入指令：

1.使用列表迭代器

```Java
  ListIterator it = methodNode.instructions.iterator();
  while (it.hasNext()) {
    AbstractInsnNode insnNode = (AbstractInsnNode) it.next();
    if (...) {
      it.add(new VarInsnNode(ALOAD, 0));
    }
  }
```

2.将list转换成数组

```Java
  AbstractInsnNode[] insns = methodNode.instructions.toArray();
  for(int i = 0; i<insns.length; i++) {
    AbstractInsnNode insn = insns[i];
    if (...) {
      methodNode.instructions.insert(insn, new VarInsnNode(ALOAD, 0));
    }
  }
```

 

如果想通过MethodVisitor的方法来添加这些指令，可以重新创建一个MethodNode作为MethodVisitor，示例：

```Java
  AbstractInsnNode[] insns = methodNode.instructions.toArray();
  for(int i = 0; i<insns.length; i++) {
    AbstractInsnNode insn = insns[i];
    if (...) {
      MethodNode toInsert = new MethodNode();
      toInsert.visitVarInsn(ALOAD, 0);
      toInsert.visitVarInsn(ALOAD, 1);
      m.instructions.insert(insn, toInsert.instructions);
    }
  }
```

 

 

# 参考文档：
[asm源码](https://gitlab.ow2.org/asm/asm)  
[ASM 6 Developer Guide](https://asm.ow2.io/developer-guide.html)  
[ASM4 使用指南](http://asm.itstack.org/#/README)  
[ASM笔记目录](https://shizhida.com/asm/ASM笔记目录/)  
[The Java Virtual Machine Instruction Set](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html)  