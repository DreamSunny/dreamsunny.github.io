<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android学习笔记</title>
    <description>Android学习笔记</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 11 Sep 2023 22:58:22 +0800</pubDate>
    <lastBuildDate>Mon, 11 Sep 2023 22:58:22 +0800</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>抖音Android基础技术大揭秘</title>
        <description>&lt;h1 id=&quot;1抖音android基础技术大揭秘-vol01&quot;&gt;1.抖音Android基础技术大揭秘 Vol.01&lt;/h1&gt;

&lt;p&gt;掘金：&lt;a href=&quot;https://live.juejin.cn/4354/6654710&quot;&gt;字节跳动技术沙龙（第10期）&lt;/a&gt;&lt;br /&gt;
B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1eh4y1s7kR&quot;&gt;字节跳动技术沙龙（第10期）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin1.png&quot; alt=&quot;douyin1&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2抖音android基础技术大揭秘-vol02&quot;&gt;2.抖音Android基础技术大揭秘 Vol.02&lt;/h1&gt;

&lt;p&gt;掘金：&lt;a href=&quot;https://live.juejin.cn/4354/9932368&quot;&gt;字节跳动技术沙龙（第12期）&lt;/a&gt;&lt;br /&gt;
B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1bc411V7tE&quot;&gt;字节跳动技术沙龙（第12期）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin2.png&quot; alt=&quot;douyin2&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3抖音android基础技术大揭秘-vol03&quot;&gt;3.抖音Android基础技术大揭秘 Vol.03&lt;/h1&gt;

&lt;p&gt;掘金：&lt;a href=&quot;https://live.byteoc.com/9281/2307433&quot;&gt;抖音Android基础技术大揭秘第三期&lt;/a&gt;&lt;br /&gt;
B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1Fh4y1X71b&quot;&gt;抖音Android基础技术大揭秘第三期&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin3.png&quot; alt=&quot;douyin3&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4抖音android基础技术大揭秘-vol04&quot;&gt;4.抖音Android基础技术大揭秘 Vol.04&lt;/h1&gt;

&lt;p&gt;B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1zu4y1o74x/&quot;&gt;抖音Android基础技术大揭秘第四期&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin4.png&quot; alt=&quot;douyin4&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 29 May 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/05/29/%E6%8A%96%E9%9F%B3Android%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E5%A4%A7%E6%8F%AD%E7%A7%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/05/29/%E6%8A%96%E9%9F%B3Android%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E5%A4%A7%E6%8F%AD%E7%A7%98/</guid>
        
        <category>Android</category>
        
        <category>Performance</category>
        
        <category>Stability</category>
        
        
      </item>
    
      <item>
        <title>Android资源加载流程</title>
        <description>&lt;p&gt;官方文档：&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/topics/resources/providing-resources?hl=zh-cn&quot;&gt;应用资源概览&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/studio/command-line/aapt2?hl=zh-cn&quot;&gt;AAPT2&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;1资源文件类型&quot;&gt;1.资源文件类型&lt;/h1&gt;

&lt;p&gt;Android应用程序资源可以分为两大类，分别是assets和res：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;assets&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;assets类资源放在工程根目录的assets子目录下，它里面保存的是一些原始的文件，可以以任何方式来进行组织。这些文件最终会被原装不动地打包在apk文件中。如果我们要在程序中访问这些文件，那么就需要指定文件名来访问。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;res&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;res类资源放在工程根目录的res子目录下，它里面保存的文件大多数都会被编译，并且都会被赋予资源ID。这样我们就可以在程序中通过R类来访问res类的资源。res类资源按照不同的用途可以进一步划分为以下子类型：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;目录&lt;/th&gt;
      &lt;th&gt;资源类型&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;animator/&lt;/td&gt;
      &lt;td&gt;用于定义属性动画的 XML 文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;anim/&lt;/td&gt;
      &lt;td&gt;用于定义补间动画的 XML 文件。属性动画也可保存在此目录中，但为了区分这两种类型，属性动画首选 animator/ 目录。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;color/&lt;/td&gt;
      &lt;td&gt;定义颜色状态列表的 XML 文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;drawable/&lt;/td&gt;
      &lt;td&gt;位图文件（PNG、.9.png、JPG 或 GIF）或编译为以下可绘制资源子类型的 XML 文件：位图文件九宫图（可调整大小的位图）状态列表形状动画可绘制对象其他可绘制对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mipmap/&lt;/td&gt;
      &lt;td&gt;适用于不同启动器图标密度的可绘制对象文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;layout/&lt;/td&gt;
      &lt;td&gt;用于定义界面布局的 XML 文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;menu/&lt;/td&gt;
      &lt;td&gt;用于定义应用菜单（例如选项菜单、上下文菜单或子菜单）的 XML 文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;raw/&lt;/td&gt;
      &lt;td&gt;需以原始形式保存的任意文件。如要使用原始 InputStream 打开这些资源，请使用资源 ID（即 R.raw.filename）调用 Resources.openRawResource()。但是，如需访问原始文件名和文件层次结构，请考虑将资源保存在 assets/ 目录（而非 res/raw/）下。assets/ 中的文件没有资源 ID，因此您只能使用 AssetManager 读取这些文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;values/&lt;/td&gt;
      &lt;td&gt;包含字符串、整数和颜色等简单值的 XML 文件。其他 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;res/&lt;/code&gt; 子目录中的 XML 资源文件会根据 XML 文件名定义单个资源，而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;values/&lt;/code&gt; 目录中的文件可描述多个资源。对于此目录中的文件，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;resources&amp;gt;&lt;/code&gt; 元素的每个子元素均会定义一个资源。例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;string&amp;gt;&lt;/code&gt; 元素会创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R.string&lt;/code&gt; 资源，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;color&amp;gt;&lt;/code&gt; 元素会创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R.color&lt;/code&gt; 资源。由于每个资源均使用自己的 XML 元素进行定义，因此您可以随意命名文件，并在某个文件中放入不同的资源类型。但是，您可能需要将独特的资源类型放在不同的文件中，使其一目了然。例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：arrays.xml 用于资源数组（类型化数组）colors.xml 用于颜色值dimens.xml 用于维度值strings.xml 用于字符串值styles.xml 用于样式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;xml/&lt;/td&gt;
      &lt;td&gt;可在运行时通过调用 Resources.getXML() 读取的任意 XML 文件。各种 XML 配置文件（例如搜索配置）都必须保存在此处。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;font/&lt;/td&gt;
      &lt;td&gt;带有扩展名的字体文件（例如 TTF、OTF 或 TTC），或包含 &lt;font-family&gt; 元素的 XML 文件。&lt;/font-family&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上述资源文件，除了raw类型资源和drawable类型资源的Bitmap文件之外，其它的资源文件均为文本格式的XML文件，它们在打包的过程中，会被编译成二进制格式的XML文件。这些二进制格式的XML文件分别有一个字符串资源池，用来保存文件中引用到的每一个字符串，包括XML元素标签、属性名称、属性值，以及其它的一切文本值所使用到的字符串。这样原来在文本格式的XML文件中的每一个放置字符串的地方在二进制格式的XML文件中都被替换成一个索引到字符串资源池的整数值。这样做有两个好处：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;文件占用更小。例如，假设在原来的文本格式的XML文件中，有四个地方使用的都是同一个字符串，那么在最终编译出来的二进制格式的XML文件中，字符串资源池只有一份字符串值，而引用它的四个地方只占用一个整数值。&lt;/li&gt;
  &lt;li&gt;解析速度更快。由于在二进制格式的XML文件中，所有的XML元素标签和属性等值都是使用整数来描述的，因此，在解析的过程中，就不再需要进行字符串解析，这样就可以提高解析速度。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Android资源打包工具aapt在编译和打包资源的过程中，会执行以下两个额外的操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;赋予每一个非assets资源一个ID值，这些ID值以常量的形式定义在一个R.java文件中。&lt;/li&gt;
  &lt;li&gt;生成一个resources.arsc文件，用来描述那些具有ID值的资源的配置信息，它的内容就相当于是一个资源索引表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;resources.arsc文件格式定义在 &lt;a href=&quot;https://android.googlesource.com/platform/frameworks/base/+/56a2301/include/androidfw/ResourceTypes.h&quot;&gt;ResourceTypes.h&lt;/a&gt; ，资源ID是一个4字节的无符号整数 0xPPTTEEEE 的形式，其中 PP 是 PackageId，TT 是 TypeIndex，EEEE 是EntryIndex。Package ID中7f是应用包资源，01是系统资源。&lt;/p&gt;

&lt;h1 id=&quot;2资源管理器&quot;&gt;2.资源管理器&lt;/h1&gt;

&lt;p&gt;上文提到Android应用程序资源可以分为assets和res两大类，在代码中访问这两大类资源分别使用的AssetManager和Resources，可以通过Context获取到实例，实现类是ContextImpl：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ContextImpl.java
public AssetManager getAssets() {
    return getResources().getAssets();
}

@Override
public Resources getResources() {
    return mResources;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/ResourceLoader/resource1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;应用启动流程中，在创建Application实例前会先创建ContextImpl实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// LoadedApk.java
private Application makeApplicationInner(boolean forceDefaultAppClass,
        Instrumentation instrumentation, boolean allowDuplicateInstances) {
    ...
    try {
        final java.lang.ClassLoader cl = getClassLoader();
        ...
        // 创建ContextImpl实例
        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
        ...
        app = mActivityThread.mInstrumentation.newApplication(
                cl, appClass, appContext);
        appContext.setOuterContext(app);
    } catch (Exception e) {
        ...
    } 
    ...
    return app;
}

// ContextImpl.java
static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo) {
    return createAppContext(mainThread, packageInfo, null);
}

static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo,
        String opPackageName) {
    if (packageInfo == null) throw new IllegalArgumentException(&quot;packageInfo&quot;);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo,
        ContextParams.EMPTY, null, null, null, null, null, 0, null, opPackageName);
    context.setResources(packageInfo.getResources());
    context.mContextType = isSystemOrSystemUI(context) ? CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI
            : CONTEXT_TYPE_NON_UI;
    return context;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建完ContextImpl实例后会调用LoadedApk.getResources()方法初始化mResources成员变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// LoadedApk.java
public Resources getResources() {
    if (mResources == null) {
        final String[] splitPaths = getSplitPaths(null);
        ...
        mResources = ResourcesManager.getInstance().getResources(null, mResDir,
                splitPaths, mLegacyOverlayDirs, mOverlayPaths,
                mApplicationInfo.sharedLibraryFiles, null, null, getCompatibilityInfo(),
                getClassLoader(), null);
    }
    return mResources;
}

private void setApplicationInfo(ApplicationInfo aInfo) {
    final int myUid = Process.myUid();
    aInfo = adjustNativeLibraryPaths(aInfo);
    mApplicationInfo = aInfo;
    mAppDir = aInfo.sourceDir;
    mResDir = aInfo.uid == myUid ? aInfo.sourceDir : aInfo.publicSourceDir;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的mResDir与mAppDir都是aInfo.sourceDir，也就是/data/app/xx/xx/base.apk。&lt;/p&gt;

&lt;p&gt;继续查看创建Resources的逻辑，这里传入的activityToken为null：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesManager.java
public Resources getResources(
        @Nullable IBinder activityToken,
        @Nullable String resDir,
        @Nullable String[] splitResDirs,
        @Nullable String[] legacyOverlayDirs,
        @Nullable String[] overlayPaths,
        @Nullable String[] libDirs,
        @Nullable Integer overrideDisplayId,
        @Nullable Configuration overrideConfig,
        @NonNull CompatibilityInfo compatInfo,
        @Nullable ClassLoader classLoader,
        @Nullable List&amp;lt;ResourcesLoader&amp;gt; loaders) {
    try {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, &quot;ResourcesManager#getResources&quot;);
        final ResourcesKey key = new ResourcesKey(
                resDir,
                splitResDirs,
                combinedOverlayPaths(legacyOverlayDirs, overlayPaths),
                libDirs,
                overrideDisplayId != null ? overrideDisplayId : INVALID_DISPLAY,
                overrideConfig,
                compatInfo,
                loaders == null ? null : loaders.toArray(new ResourcesLoader[0]));
        classLoader = classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();

        final ApkAssetsSupplier assetsSupplier = createApkAssetsSupplierNotLocked(key);
        ...
        Resources resources;
        // 每个Activity会创建一个对应的Resources
        if (activityToken != null) {
            Configuration initialOverrideConfig = new Configuration(key.mOverrideConfiguration);
            rebaseKeyForActivity(activityToken, key, overrideDisplayId != null);
            resources = createResourcesForActivity(activityToken, key, initialOverrideConfig,
                    overrideDisplayId, classLoader, assetsSupplier);
        } else {
            resources = createResources(key, classLoader, assetsSupplier);
        }
        return resources;
    } finally {
    }
}

private Resources createResources(@NonNull ResourcesKey key, @NonNull ClassLoader classLoader,
        @Nullable ApkAssetsSupplier apkSupplier) {
    synchronized (mLock) {
        ResourcesImpl resourcesImpl = findOrCreateResourcesImplForKeyLocked(key, apkSupplier);
        ...
        return createResourcesLocked(classLoader, resourcesImpl, key.mCompatInfo);
    }
}

private @NonNull Resources createResourcesLocked(@NonNull ClassLoader classLoader,
        @NonNull ResourcesImpl impl, @NonNull CompatibilityInfo compatInfo) {
    cleanupReferences(mResourceReferences, mResourcesReferencesQueue);

    Resources resources = compatInfo.needsCompatResources() ? new CompatResources(classLoader)
            : new Resources(classLoader);
    resources.setImpl(impl);
    resources.setCallbacks(mUpdateCallbacks);
    mResourceReferences.add(new WeakReference&amp;lt;&amp;gt;(resources, mResourcesReferencesQueue));
    return resources;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建ResourcesImpl的实例，可以看到ResourcesImpl的实例会被弱引用缓存到mResourceImpls中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesManager.java
private @Nullable ResourcesImpl findOrCreateResourcesImplForKeyLocked(
        @NonNull ResourcesKey key, @Nullable ApkAssetsSupplier apkSupplier) {
    ResourcesImpl impl = findResourcesImplForKeyLocked(key);
    if (impl == null) {
        impl = createResourcesImpl(key, apkSupplier);
        if (impl != null) {
            mResourceImpls.put(key, new WeakReference&amp;lt;&amp;gt;(impl));
        }
    }
    return impl;
}

private @Nullable ResourcesImpl createResourcesImpl(@NonNull ResourcesKey key,
        @Nullable ApkAssetsSupplier apkSupplier) {
    final AssetManager assets = createAssetManager(key, apkSupplier);
    ...
    final ResourcesImpl impl = new ResourcesImpl(assets, displayMetrics, config, daj);
    return impl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建AssetManager的实例，关键操作是addApkAssets方法，参数是ApkAssets对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesManager.java
protected @Nullable AssetManager createAssetManager(@NonNull final ResourcesKey key) {
    return createAssetManager(key, /* apkSupplier */ null);
}

private @Nullable AssetManager createAssetManager(@NonNull final ResourcesKey key,
        @Nullable ApkAssetsSupplier apkSupplier) {
    final AssetManager.Builder builder = new AssetManager.Builder();

    final ArrayList&amp;lt;ApkKey&amp;gt; apkKeys = extractApkKeys(key);
    for (int i = 0, n = apkKeys.size(); i &amp;lt; n; i++) {
        final ApkKey apkKey = apkKeys.get(i);
        try {
            // 添加到mUserApkAssets
            builder.addApkAssets(
                    (apkSupplier != null) ? apkSupplier.load(apkKey) : loadApkAssets(apkKey));
        } catch (IOException e) {
        }
    }

    if (key.mLoaders != null) {
        for (final ResourcesLoader loader : key.mLoaders) {
            // 添加到mLoaders
            builder.addLoader(loader);
        }
    }

    return builder.build();
}

private static @NonNull ArrayList&amp;lt;ApkKey&amp;gt; extractApkKeys(@NonNull final ResourcesKey key) {
    final ArrayList&amp;lt;ApkKey&amp;gt; apkKeys = new ArrayList&amp;lt;&amp;gt;();

    if (key.mResDir != null) {
        apkKeys.add(new ApkKey(key.mResDir, false /*sharedLib*/, false /*overlay*/));
    }
    if (key.mSplitResDirs != null) { ... }
    if (key.mLibDirs != null) { ... }
    if (key.mOverlayPaths != null)  { ... }

    return apkKeys;
}

// AssetManager.java
public AssetManager build() {
    final ApkAssets[] systemApkAssets = getSystem().getApkAssets();
    ...
    final int totalApkAssetCount = systemApkAssets.length + mUserApkAssets.size()
            + loaderApkAssets.size();
    final ApkAssets[] apkAssets = new ApkAssets[totalApkAssetCount];
    // 简化为apkAssets = systemApkAssets + mUserApkAssets + mLoaders去重
    ...

    final AssetManager assetManager = new AssetManager(false /*sentinel*/);
    assetManager.mApkAssets = apkAssets;
    AssetManager.nativeSetApkAssets(assetManager.mObject, apkAssets,
            false /*invalidateCaches*/);
    assetManager.mLoaders = mLoaders.isEmpty() ? null
            : mLoaders.toArray(new ResourcesLoader[0]);

    return assetManager;
}

// 创建加载系统资源的ApkAssets
public static AssetManager getSystem() {
    synchronized (sSync) {
        createSystemAssetsInZygoteLocked(false, FRAMEWORK_APK_PATH);
        return sSystem;
    }
}

public static void createSystemAssetsInZygoteLocked(boolean reinitialize,
        String frameworkPath) {
    try {
        final ArrayList&amp;lt;ApkAssets&amp;gt; apkAssets = new ArrayList&amp;lt;&amp;gt;();
        // &quot;/system/framework/framework-res.apk&quot;
        apkAssets.add(ApkAssets.loadFromPath(frameworkPath, ApkAssets.PROPERTY_SYSTEM));

        final String[] systemIdmapPaths =
                OverlayConfig.getZygoteInstance().createImmutableFrameworkIdmapsInZygote();
        for (String idmapPath : systemIdmapPaths) {
            // Android系统资源覆盖机制
            apkAssets.add(ApkAssets.loadOverlayFromPath(idmapPath, ApkAssets.PROPERTY_SYSTEM));
        }
        sSystemApkAssetsSet = new ArraySet&amp;lt;&amp;gt;(apkAssets);
        sSystemApkAssets = apkAssets.toArray(new ApkAssets[apkAssets.size()]);
        if (sSystem == null) {
            sSystem = new AssetManager(true /*sentinel*/);
        }
        sSystem.setApkAssets(sSystemApkAssets, false /*invalidateCaches*/);
    } catch (IOException e) {
    }
}

private AssetManager(boolean sentinel) {
    mObject = nativeCreate();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Android资源覆盖机制参考官方文档：&lt;a href=&quot;https://source.android.com/docs/core/runtime/rros&quot;&gt;Change the value of an app’s resources at runtime&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接下来创建ApkAssets的实例，在构造方法中调用native方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesManager.java
ApkAssets load(final ApkKey apkKey) throws IOException {
    ApkAssets apkAssets = mLocalCache.get(apkKey);
    if (apkAssets == null) {
        apkAssets = loadApkAssets(apkKey);
        mLocalCache.put(apkKey, apkAssets);
    }
    return apkAssets;
}

private @NonNull ApkAssets loadApkAssets(@NonNull final ApkKey key) throws IOException {
    ApkAssets apkAssets;
    ...
    if (key.overlay) {
        apkAssets = ApkAssets.loadOverlayFromPath(overlayPathToIdmapPath(key.path), flags);
    } else {
        apkAssets = ApkAssets.loadFromPath(key.path, flags);
    }

    synchronized (mLock) {
        mCachedApkAssets.put(key, new WeakReference&amp;lt;&amp;gt;(apkAssets));
    }

    return apkAssets;
}

// ApkAssets.java
public static @NonNull ApkAssets loadFromPath(@NonNull String path, @PropertyFlags int flags)
        throws IOException {
    return new ApkAssets(FORMAT_APK, path, flags, null /* assets */);
}

private ApkAssets(@FormatType int format, @NonNull String path, @PropertyFlags int flags,
        @Nullable AssetsProvider assets) throws IOException {
    Objects.requireNonNull(path, &quot;path&quot;);
    mFlags = flags;
    mNativePtr = nativeLoad(format, path, flags, assets);
    mStringBlock = new StringBlock(nativeGetStringBlock(mNativePtr), true /*useSparse*/);
    mAssets = assets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kResourcesArsc是常量”resources.arsc”，加载资源文件，创建native侧ApkAssets。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// android_content_res_ApkAssets.cpp
static jlong NativeLoad(JNIEnv* env, jclass /*clazz*/, const format_type_t format,
                        jstring java_path, const jint property_flags, jobject assets_provider) {
  ScopedUtfChars path(env, java_path);

  auto loader_assets = LoaderAssetsProvider::Create(env, assets_provider);
  std::unique_ptr&amp;lt;ApkAssets&amp;gt; apk_assets;
  switch (format) {
    case FORMAT_APK: {
        auto assets = MultiAssetsProvider::Create(std::move(loader_assets),
                                                  ZipAssetsProvider::Create(path.c_str(),
                                                                            property_flags));
        apk_assets = ApkAssets::Load(std::move(assets), property_flags);
        break;
    }
    ...
  }

  return CreateGuardedApkAssets(std::move(apk_assets));
}

// Asset.cpp
std::unique_ptr&amp;lt;ApkAssets&amp;gt; ApkAssets::Load(std::unique_ptr&amp;lt;AssetsProvider&amp;gt; assets,
                                           package_property_t flags) {
  return LoadImpl(std::move(assets), flags, nullptr /* idmap_asset */, nullptr /* loaded_idmap */);
}

std::unique_ptr&amp;lt;ApkAssets&amp;gt; ApkAssets::LoadImpl(std::unique_ptr&amp;lt;AssetsProvider&amp;gt; assets,
                                               package_property_t property_flags,
                                               std::unique_ptr&amp;lt;Asset&amp;gt; idmap_asset,
                                               std::unique_ptr&amp;lt;LoadedIdmap&amp;gt; loaded_idmap) {
  // Open the resource table via mmap unless it is compressed. This logic is taken care of by Open.
  bool resources_asset_exists = false;
  auto resources_asset = assets-&amp;gt;Open(kResourcesArsc, Asset::AccessMode::ACCESS_BUFFER,
                                      &amp;amp;resources_asset_exists);
  return LoadImpl(std::move(resources_asset), std::move(assets), property_flags,
                  std::move(idmap_asset), std::move(loaded_idmap));
}

std::unique_ptr&amp;lt;ApkAssets&amp;gt; ApkAssets::LoadImpl(std::unique_ptr&amp;lt;Asset&amp;gt; resources_asset,
                                               std::unique_ptr&amp;lt;AssetsProvider&amp;gt; assets,
                                               package_property_t property_flags,
                                               std::unique_ptr&amp;lt;Asset&amp;gt; idmap_asset,
                                               std::unique_ptr&amp;lt;LoadedIdmap&amp;gt; loaded_idmap) {
  std::unique_ptr&amp;lt;LoadedArsc&amp;gt; loaded_arsc;
  if (resources_asset != nullptr) {
    const auto data = resources_asset-&amp;gt;getIncFsBuffer(true /* aligned */);
    const size_t length = resources_asset-&amp;gt;getLength();
    if (!data || length == 0) {
      return {};
    }
    loaded_arsc = LoadedArsc::Load(data, length, loaded_idmap.get(), property_flags);
  } else {
    loaded_arsc = LoadedArsc::CreateEmpty();
  }
  return std::unique_ptr&amp;lt;ApkAssets&amp;gt;(new ApkAssets(std::move(resources_asset),
                                                  std::move(loaded_arsc), std::move(assets),
                                                  property_flags, std::move(idmap_asset),
                                                  std::move(loaded_idmap)));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个过程主要是创建了AssetManager，ResourcesImpl，Resources这三个类的实例，三者之间的关系为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ResourceLoader/resource2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在ResourcesManager中会缓存创建的ResourcesImpl和Resources。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;/**
 * A mapping of ResourceImpls and their configurations. These are heavy weight objects
 * which should be reused as much as possible.
 */
@UnsupportedAppUsage
private final ArrayMap&amp;lt;ResourcesKey, WeakReference&amp;lt;ResourcesImpl&amp;gt;&amp;gt; mResourceImpls =
        new ArrayMap&amp;lt;&amp;gt;();

/**
 * A list of Resource references that can be reused.
 */
@UnsupportedAppUsage
private final ArrayList&amp;lt;WeakReference&amp;lt;Resources&amp;gt;&amp;gt; mResourceReferences = new ArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用想要动态添加资源，可以基于资源路径构造ApkAssets，调用AssetManager的setApkAssets接口添加。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// AssetManager.java
public void setApkAssets(@NonNull ApkAssets[] apkAssets, boolean invalidateCaches) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3资源文件加载&quot;&gt;3.资源文件加载&lt;/h1&gt;

&lt;p&gt;Android资源文件在打包时，非assets资源会编译到resources.arsc文件，使用Resources根据资源ID加载；非assets文件会直接打包到apk，使用AssetManager根据文件名加载。事实上，Resources加载资源也是由AssetManager实现的，接下来以加载Activity布局文件为例，介绍下资源加载流程。&lt;/p&gt;

&lt;h2 id=&quot;31-加载res资源文件&quot;&gt;3.1 加载res资源文件&lt;/h2&gt;

&lt;p&gt;LayoutInflater类主要功能是从xml实例化View视图，Resources通过资源ID加载布局xml文件，然后解析xml文件实例化View视图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// LayoutInflater.java
public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
    XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}

// 解析xml文件实例化View视图
public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;

        try {
            advanceToRootNode(parser);
            final String name = parser.getName();
            if (TAG_MERGE.equals(name)) { // &quot;merge&quot;
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        temp.setLayoutParams(params);
                    }
                }

                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);

                if (root != null &amp;amp;&amp;amp; attachToRoot) {
                    root.addView(temp, params);
                }

                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
        } catch (Exception e) {
        } finally {
        }

        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Resources通过ResourcesImpl查找对应的布局文件，如果没有找到会抛出NotFoundException：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Resources.java
public XmlResourceParser getLayout(@LayoutRes int id) throws NotFoundException {
    return loadXmlResourceParser(id, &quot;layout&quot;);
}

XmlResourceParser loadXmlResourceParser(@AnyRes int id, @NonNull String type)
        throws NotFoundException {
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValue(id, value, true);
        if (value.type == TypedValue.TYPE_STRING) {
            return loadXmlResourceParser(value.string.toString(), id,
                    value.assetCookie, type);
        }
        throw new NotFoundException(&quot;Resource ID #0x&quot; + Integer.toHexString(id)
                + &quot; type #0x&quot; + Integer.toHexString(value.type) + &quot; is not valid&quot;);
    } finally {
        releaseTempTypedValue(value);
    }
}

XmlResourceParser loadXmlResourceParser(String file, int id, int assetCookie,
                                        String type) throws NotFoundException {
    return mResourcesImpl.loadXmlResourceParser(file, id, assetCookie, type);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResourcesImpl通过AssetManager的native方法查找资源：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesImpl.java
void getValue(@AnyRes int id, TypedValue outValue, boolean resolveRefs)
        throws NotFoundException {
    boolean found = mAssets.getResourceValue(id, 0, outValue, resolveRefs);
    if (found) {
        return;
    }
    throw new NotFoundException(&quot;Resource ID #0x&quot; + Integer.toHexString(id));
}

boolean getResourceValue(@AnyRes int resId, int densityDpi, @NonNull TypedValue outValue,
        boolean resolveRefs) {
    Objects.requireNonNull(outValue, &quot;outValue&quot;);
    synchronized (this) {
        ensureValidLocked();
        final int cookie = nativeGetResourceValue(
                mObject, resId, (short) densityDpi, outValue, resolveRefs);
        if (cookie &amp;lt;= 0) {
            return false;
        }
        ...
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建AssetManager2实例，调用其GetResource方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// android_util_AssetManager.cpp
static jint NativeGetResourceValue(JNIEnv* env, jclass /*clazz*/, jlong ptr, jint resid,
                                   jshort density, jobject typed_value,
                                   jboolean resolve_references) {
  ScopedLock&amp;lt;AssetManager2&amp;gt; assetmanager(AssetManagerFromLong(ptr));
  auto value = assetmanager-&amp;gt;GetResource(static_cast&amp;lt;uint32_t&amp;gt;(resid), false /*may_be_bag*/,
                                         static_cast&amp;lt;uint16_t&amp;gt;(density));
  if (!value.has_value()) {
    return ApkAssetsCookieToJavaCookie(kInvalidCookie);
  }

  if (resolve_references) {
    auto result = assetmanager-&amp;gt;ResolveReference(value.value());
    if (!result.has_value()) {
      return ApkAssetsCookieToJavaCookie(kInvalidCookie);
    }
  }
  return CopyValue(env, *value, typed_value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AssetManager2查找资源的核心逻辑，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// AssetManager2.cpp 
base::expected&amp;lt;AssetManager2::SelectedValue, NullOrIOError&amp;gt; AssetManager2::GetResource(
      uint32_t resid, bool may_be_bag, uint16_t density_override) const {
  auto result = FindEntry(resid, density_override, false /* stop_at_first_match */,
                          false /* ignore_configuration */);
  auto result_map_entry = std::get_if&amp;lt;incfs::verified_map_ptr&amp;lt;ResTable_map_entry&amp;gt;&amp;gt;(&amp;amp;result-&amp;gt;entry);
  if (result_map_entry != nullptr) {
      if (!may_be_bag) {
        LOG(ERROR) &amp;lt;&amp;lt; base::StringPrintf(&quot;Resource %08x is a complex map type.&quot;, resid);
        return base::unexpected(std::nullopt);
      }

      // Create a reference since we can&apos;t represent this complex type as a Res_value.
      return SelectedValue(Res_value::TYPE_REFERENCE, resid, result-&amp;gt;cookie, result-&amp;gt;type_flags,
                           resid, result-&amp;gt;config);
  }

  // Convert the package ID to the runtime assigned package ID.
  Res_value value = std::get&amp;lt;Res_value&amp;gt;(result-&amp;gt;entry);
  result-&amp;gt;dynamic_ref_table-&amp;gt;lookupResourceValue(&amp;amp;value);

  return SelectedValue(value.dataType, value.data, result-&amp;gt;cookie, result-&amp;gt;type_flags,
                       resid, result-&amp;gt;config);
}

base::expected&amp;lt;FindEntryResult, NullOrIOError&amp;gt; AssetManager2::FindEntry(
    uint32_t resid, uint16_t density_override, bool stop_at_first_match,
    bool ignore_configuration) const {
  // Might use this if density_override != 0.
  ResTable_config density_override_config;

  // Select our configuration or generate a density override configuration.
  const ResTable_config* desired_config = &amp;amp;configuration_;
  if (density_override != 0 &amp;amp;&amp;amp; density_override != configuration_.density) {
    density_override_config = configuration_;
    density_override_config.density = density_override;
    desired_config = &amp;amp;density_override_config;
  }

  // 这里对应上文资源ID生成规则
  const uint32_t package_id = get_package_id(resid);
  const uint8_t type_idx = get_type_id(resid) - 1;
  const uint16_t entry_idx = get_entry_id(resid);
  uint8_t package_idx = package_ids_[package_id];
  if (UNLIKELY(package_idx == 0xff)) {
    ANDROID_LOG(ERROR) &amp;lt;&amp;lt; base::StringPrintf(&quot;No package ID %02x found for ID 0x%08x.&quot;,
                                             package_id, resid);
    return base::unexpected(std::nullopt);
  }

  // 主要用来处理Runtime Resources Overlay
  const PackageGroup&amp;amp; package_group = package_groups_[package_idx];
  auto result = FindEntryInternal(package_group, type_idx, entry_idx, *desired_config,
                                  stop_at_first_match, ignore_configuration);
  if (UNLIKELY(!result.has_value())) {
    return base::unexpected(result.error());
  }

  bool overlaid = false;
  if (!stop_at_first_match &amp;amp;&amp;amp; !ignore_configuration &amp;amp;&amp;amp; !apk_assets_[result-&amp;gt;cookie]-&amp;gt;IsLoader()) {
    // 查找资源覆盖的逻辑
  }

  return result;
}

// 核心逻辑是根据资源id，找到package_group，遍历package_group根据资源类型找到最佳匹配
base::expected&amp;lt;FindEntryResult, NullOrIOError&amp;gt; AssetManager2::FindEntryInternal(
    const PackageGroup&amp;amp; package_group, uint8_t type_idx, uint16_t entry_idx,
    const ResTable_config&amp;amp; desired_config, bool stop_at_first_match,
    bool ignore_configuration) const {
  ApkAssetsCookie best_cookie = kInvalidCookie;
  const LoadedPackage* best_package = nullptr;
  incfs::verified_map_ptr&amp;lt;ResTable_type&amp;gt; best_type;
  const ResTable_config* best_config = nullptr;
  uint32_t best_offset = 0U;
  uint32_t type_flags = 0U;

  const bool use_filtered = !ignore_configuration &amp;amp;&amp;amp; &amp;amp;desired_config == &amp;amp;configuration_;

  // RRO机制可能存在多个package
  const size_t package_count = package_group.packages_.size();
  for (size_t pi = 0; pi &amp;lt; package_count; pi++) {
    const ConfiguredPackage&amp;amp; loaded_package_impl = package_group.packages_[pi];
    const LoadedPackage* loaded_package = loaded_package_impl.loaded_package_;
    const ApkAssetsCookie cookie = package_group.cookies_[pi];

    const TypeSpec* type_spec = loaded_package-&amp;gt;GetTypeSpecByTypeIndex(type_idx);
    const bool package_is_loader = loaded_package-&amp;gt;IsCustomLoader();

    auto entry_flags = type_spec-&amp;gt;GetFlagsForEntryIndex(entry_idx);
    type_flags |= entry_flags.value();

    // 根据设备的当前配置信息，去选择最合适的资源项
    const FilteredConfigGroup&amp;amp; filtered_group = loaded_package_impl.filtered_configs_[type_idx];
    const size_t type_entry_count = (use_filtered) ? filtered_group.type_entries.size()
                                                   : type_spec-&amp;gt;type_entries.size();
    // 遍历资源类型查找最佳匹配
    for (size_t i = 0; i &amp;lt; type_entry_count; i++) {
      const TypeSpec::TypeEntry* type_entry = (use_filtered) ? filtered_group.type_entries[i]
                                                             : &amp;amp;type_spec-&amp;gt;type_entries[i];

      const ResTable_config&amp;amp; this_config = type_entry-&amp;gt;config;
      if (!(use_filtered || ignore_configuration || this_config.match(desired_config))) {
        continue;
      }
      
      // 查找最佳匹配
      Resolution::Step::Type resolution_type;
      if (best_config == nullptr) {
        resolution_type = Resolution::Step::Type::INITIAL;
      } else if (this_config.isBetterThan(*best_config, &amp;amp;desired_config)) {
        resolution_type = Resolution::Step::Type::BETTER_MATCH;
      } else if (package_is_loader &amp;amp;&amp;amp; this_config.compare(*best_config) == 0) {
        resolution_type = Resolution::Step::Type::OVERLAID;
      } else {
        continue;
      }

      const auto&amp;amp; type = type_entry-&amp;gt;type;
      const auto offset = LoadedPackage::GetEntryOffset(type, entry_idx);
      if (!offset.has_value()) {
        continue;
      }

      best_cookie = cookie;
      best_package = loaded_package;
      best_type = type;
      best_config = &amp;amp;this_config;
      best_offset = offset.value();

      if (stop_at_first_match) {
        break;
      }
    }
  }

  auto best_entry_result = LoadedPackage::GetEntryFromOffset(best_type, best_offset);
  const incfs::map_ptr&amp;lt;ResTable_entry&amp;gt; best_entry = *best_entry_result;
  const auto entry = GetEntryValue(best_entry.verified());

  return FindEntryResult{
    .cookie = best_cookie,
    .entry = *entry,
    .config = *best_config,
    .type_flags = type_flags,
    .package_name = &amp;amp;best_package-&amp;gt;GetPackageName(),
    .type_string_ref = StringPoolRef(best_package-&amp;gt;GetTypeStringPool(), best_type-&amp;gt;id - 1),
    .entry_string_ref = StringPoolRef(best_package-&amp;gt;GetKeyStringPool(),
                                      best_entry-&amp;gt;key.index),
    .dynamic_ref_table = package_group.dynamic_ref_table.get(),
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;32-加载assets资源&quot;&gt;3.2 加载assets资源&lt;/h2&gt;

&lt;p&gt;通过Context获取到AssetManager实例，调用其open方法传入文件名：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// AssetManager.java
public @NonNull InputStream open(@NonNull String fileName) throws IOException {
    return open(fileName, ACCESS_STREAMING);
}

public @NonNull InputStream open(@NonNull String fileName, int accessMode) throws IOException {
    Objects.requireNonNull(fileName, &quot;fileName&quot;);
    synchronized (this) {
        ensureOpenLocked();
        final long asset = nativeOpenAsset(mObject, fileName, accessMode);
        if (asset == 0) {
            throw new FileNotFoundException(&quot;Asset file: &quot; + fileName);
        }
        final AssetInputStream assetInputStream = new AssetInputStream(asset);
        incRefsLocked(assetInputStream.hashCode());
        return assetInputStream;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在native侧同样创建AssetManager2，调用其Open方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// android_util_AssetManager.cpp
static jlong NativeOpenAsset(JNIEnv* env, jclass /*clazz*/, jlong ptr, jstring asset_path,
                             jint access_mode) {
  ScopedUtfChars asset_path_utf8(env, asset_path);
  ...
  ScopedLock&amp;lt;AssetManager2&amp;gt; assetmanager(AssetManagerFromLong(ptr));
  std::unique_ptr&amp;lt;Asset&amp;gt; asset =
      assetmanager-&amp;gt;Open(asset_path_utf8.c_str(), static_cast&amp;lt;Asset::AccessMode&amp;gt;(access_mode));
  if (!asset) {
    jniThrowException(env, &quot;java/io/FileNotFoundException&quot;, asset_path_utf8.c_str());
    return 0;
  }
  return reinterpret_cast&amp;lt;jlong&amp;gt;(asset.release());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;apk_assets_存储的是已经加载的所有apk包，遍历apk_assets_通过AssetsProvider查找文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// AssetManager2.cpp 
std::unique_ptr&amp;lt;Asset&amp;gt; AssetManager2::Open(const std::string&amp;amp; filename,
                                           Asset::AccessMode mode) const {
  const std::string new_path = &quot;assets/&quot; + filename;
  return OpenNonAsset(new_path, mode);
}

std::unique_ptr&amp;lt;Asset&amp;gt; AssetManager2::OpenNonAsset(const std::string&amp;amp; filename,
                                                   Asset::AccessMode mode,
                                                   ApkAssetsCookie* out_cookie) const {
  for (int32_t i = apk_assets_.size() - 1; i &amp;gt;= 0; i--) {
    // 通过文件名加载文件时忽略RRO
    if (apk_assets_[i]-&amp;gt;IsOverlay()) {
      continue;
    }

    std::unique_ptr&amp;lt;Asset&amp;gt; asset = apk_assets_[i]-&amp;gt;GetAssetsProvider()-&amp;gt;Open(filename, mode);
    if (asset) {
      if (out_cookie != nullptr) {
        *out_cookie = i;
      }
      return asset;
    }
  }

  if (out_cookie != nullptr) {
    *out_cookie = kInvalidCookie;
  }
  return {};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AssetsProvider是在上文创建ApkAssets时创建的，读取文件分为文件压缩/文件未压缩两种：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// AssetsProvider.cpp
std::unique_ptr&amp;lt;Asset&amp;gt; AssetsProvider::Open(const std::string&amp;amp; path, Asset::AccessMode mode,
                                            bool* file_exists) const {
  return OpenInternal(path, mode, file_exists);
}

std::unique_ptr&amp;lt;Asset&amp;gt; ZipAssetsProvider::OpenInternal(const std::string&amp;amp; path,
                                                       Asset::AccessMode mode,
                                                       bool* file_exists) const {
    if (file_exists != nullptr) {
      *file_exists = false; // 初始化为false
    }

    ZipEntry entry;
    // zip_archive.cc 
    if (FindEntry(zip_handle_.get(), path, &amp;amp;entry) != 0) {
      return {};
    }

    if (file_exists != nullptr) {
      *file_exists = true; // 找到文件，设置为true
    }

    const int fd = GetFileDescriptor(zip_handle_.get());
    const off64_t fd_offset = GetFileDescriptorOffset(zip_handle_.get());
    const bool incremental_hardening = (flags_ &amp;amp; PROPERTY_DISABLE_INCREMENTAL_HARDENING) == 0U;
    incfs::IncFsFileMap asset_map;
    if (entry.method == kCompressDeflated) { // 是否是压缩文件
      if (!asset_map.Create(fd, entry.offset + fd_offset, entry.compressed_length,
                            name_.GetDebugName().c_str(), incremental_hardening)) {
        LOG(ERROR) &amp;lt;&amp;lt; &quot;Failed to mmap file &apos;&quot; &amp;lt;&amp;lt; path &amp;lt;&amp;lt; &quot;&apos; in APK &apos;&quot; &amp;lt;&amp;lt; name_.GetDebugName()
                   &amp;lt;&amp;lt; &quot;&apos;&quot;;
        return {};
      }

      std::unique_ptr&amp;lt;Asset&amp;gt; asset =
          Asset::createFromCompressedMap(std::move(asset_map), entry.uncompressed_length, mode);
      return asset;
    }

    if (!asset_map.Create(fd, entry.offset + fd_offset, entry.uncompressed_length,
                          name_.GetDebugName().c_str(), incremental_hardening)) {
      LOG(ERROR) &amp;lt;&amp;lt; &quot;Failed to mmap file &apos;&quot; &amp;lt;&amp;lt; path &amp;lt;&amp;lt; &quot;&apos; in APK &apos;&quot; &amp;lt;&amp;lt; name_.GetDebugName() &amp;lt;&amp;lt; &quot;&apos;&quot;;
      return {};
    }
    ...
    auto asset = Asset::createFromUncompressedMap(std::move(asset_map), mode, std::move(ufd));
    return asset;
}

std::unique_ptr&amp;lt;Asset&amp;gt; Asset::createFromUncompressedMap(incfs::IncFsFileMap&amp;amp;&amp;amp; dataMap,
                                                                   AccessMode mode,
                                                                   base::unique_fd fd)
{
    auto pAsset = util::make_unique&amp;lt;_FileAsset&amp;gt;();
    status_t result = pAsset-&amp;gt;openChunk(std::move(dataMap), std::move(fd));
    pAsset-&amp;gt;mAccessMode = mode;
    return std::move(pAsset);
}

status_t _FileAsset::openChunk(incfs::IncFsFileMap&amp;amp;&amp;amp; dataMap, base::unique_fd fd)
{
    assert(mFp == NULL);    // no reopen
    assert(!mMap.has_value());
    assert(dataMap != NULL);

    mMap = std::move(dataMap);
    mStart = -1;            // not used
    mLength = mMap-&amp;gt;length();
    mFd = std::move(fd);
    assert(mOffset == 0);

    return NO_ERROR;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;参考文档&quot;&gt;参考文档：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/8738877&quot;&gt;Android资源管理框架（Asset Manager）简要介绍和学习计划&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/8744683&quot;&gt;Android应用程序资源的编译和打包过程分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/8791064&quot;&gt;Android应用程序资源管理器（Asset Manager）的创建过程分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/8806798&quot;&gt;Android应用程序资源的查找过程分析&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 17 Apr 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/04/17/Android%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/04/17/Android%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>ResourceLoader</category>
        
        
      </item>
    
      <item>
        <title>Android类加载流程</title>
        <description>&lt;h1 id=&quot;1基本概念&quot;&gt;1.基本概念&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;1.1 类加载器的作用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;类的加载需要类加载器完成，在JVM中，一个类的唯一性是需要这个类本身和类加载器一起才能确定的，每个类加载器都有一个独立的命名空间。&lt;/p&gt;

&lt;p&gt;不同的类加载器，即使是同一个类字节码文件，最后再JVM里的类对象也不是同一个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 双亲委派模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，&lt;/p&gt;

&lt;p&gt;因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    // 交给父类加载器尝试加载
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                // 父类加载器无法加载时自身尝试加载
                c = findClass(name);

                // this is the defining class loader; record the stats
                PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。&lt;/p&gt;

&lt;p&gt;例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，&lt;/p&gt;

&lt;p&gt;因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，&lt;/p&gt;

&lt;p&gt;并放在程序的Class Path中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3 Java与Android类加载器比较&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JVM加载的是class文件，ART加载的是dex文件。&lt;/p&gt;

&lt;p&gt;Java中四种类加载器：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ClassLoader/java.png&quot; alt=&quot;java&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Android中类加载器：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ClassLoader/android.png&quot; alt=&quot;android&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2android类加载器&quot;&gt;2.Android类加载器&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;ClassLoader：&lt;/strong&gt;对Java的ClassLoader代码做了精简，其中loadClass()核心逻辑不变，仍采用双亲委派模型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BootClassLoader&lt;/strong&gt;：继承于ClassLoader，是ClassLoader的内部类。是SystemClassLoader的父加载器，同时也是Android中所有ClassLoader的最终parent。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ClassLoader.java 
private static ClassLoader createSystemClassLoader() {
    String classPath = System.getProperty(&quot;java.class.path&quot;, &quot;.&quot;);
    String librarySearchPath = System.getProperty(&quot;java.library.path&quot;, &quot;&quot;);
    return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());
}

public ClassLoader getClassLoader() {
    return (classLoader == null) ? BootClassLoader.getInstance() : classLoader;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;BaseDexClassLoader&lt;/strong&gt;：继承于ClassLoader，是PathClassLoader和DexClassLoader的父类。&lt;/p&gt;

&lt;p&gt;BaseDexClassLoader重写了ClassLoader的findClass()方法，核心在于维护了DexPathList这个类对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// BaseDexClassLoader.java 
private final DexPathList pathList;

public BaseDexClassLoader(String dexPath,
        String librarySearchPath, ClassLoader parent, ClassLoader[] sharedLibraryLoaders,
        ClassLoader[] sharedLibraryLoadersAfter,
        boolean isTrusted) {
    super(parent);
    ...
    this.pathList = new DexPathList(this, dexPath, librarySearchPath, null, isTrusted);
    ...
}
 
@Override
protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
    ...
    Class c = pathList.findClass(name, suppressedExceptions);
    if (c != null) {
        return c;
    }
    ...
    return c;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;PathClassLoader&lt;/strong&gt;：继承于BaseDexClassLoader，用来加载系统类和apk中的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DexClassLoader&lt;/strong&gt;：继承于BaseDexClassLoader，可以用来加载外置的dex文件或者apk，jar等。&lt;/p&gt;

&lt;p&gt;在Android8.1之后，optimizedDirectory参数已废弃，默认传入null。也就是说Android8.1版本及以后，PathClassLoader和DexClassLoader没有区别。&lt;/p&gt;

&lt;h1 id=&quot;3dexpathlist&quot;&gt;3.DexPathList&lt;/h1&gt;

&lt;p&gt;DexPathList核心功能是维护dexElements数组，用来记录dex文件集合。在BaseDexClassLoader构造函数中将dexPath传入，在DexPathList的splitDexPath()方法解析文件路径，在makeDexElements()方法添加到dexElements数组中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DexPathList.java
private Element[] dexElements;
 
DexPathList(ClassLoader definingContext, String dexPath,
        String librarySearchPath, File optimizedDirectory, boolean isTrusted) {
    ...
    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,
                                       suppressedExceptions, definingContext, isTrusted);
    ...
}

// 生成dexElements数组
private static Element[] makeDexElements(List&amp;lt;File&amp;gt; files, File optimizedDirectory,
        List&amp;lt;IOException&amp;gt; suppressedExceptions, ClassLoader loader, boolean isTrusted) {
  Element[] elements = new Element[files.size()];
  int elementsPos = 0;
  for (File file : files) {
      if (file.isDirectory()) {
              ...
      } else if (file.isFile()) {
          String name = file.getName();

          DexFile dex = null;
          if (name.endsWith(DEX_SUFFIX)) {
              // Raw dex file (not inside a zip/jar).
              try {
                  dex = loadDexFile(file, optimizedDirectory, loader, elements);
                  if (dex != null) {
                      elements[elementsPos++] = new Element(dex, null);
                  }
              } catch (IOException suppressed) {
                  ...
              }
          } else {
              ...
          }
          if (dex != null &amp;amp;&amp;amp; isTrusted) {
            dex.setTrusted();
          }
      } else {
          System.logW(&quot;ClassLoader referenced unknown path: &quot; + file);
      }
  }
  if (elementsPos != elements.length) {
      elements = Arrays.copyOf(elements, elementsPos);
  }
  return elements;
}

// 加载dex文件，创建DexFile对象
private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader,
                                   Element[] elements)
        throws IOException {
    if (optimizedDirectory == null) {
        return new DexFile(file, loader, elements);
    } else {
        String optimizedPath = optimizedPathFor(file, optimizedDirectory);
        return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);
    }
}

static class Element {
    private final File path;
    private final Boolean pathIsDirectory;
    private final DexFile dexFile;
 
    public Class&amp;lt;?&amp;gt; findClass(String name, ClassLoader definingContext,List&amp;lt;Throwable&amp;gt; suppressed) {
        return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed) : null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上文提到BaseDexClassLoader重写了ClassLoader的findClass()方法，其实现是直接调用DexPathList的findClass()方法，其核心逻辑是遍历所有dex文件，调用DexFile的loadClassBinaryName()方法加载类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DexPathList.java
public Class&amp;lt;?&amp;gt; findClass(String name, List&amp;lt;Throwable&amp;gt; suppressed) {
    for (Element element : dexElements) {
        Class&amp;lt;?&amp;gt; clazz = element.findClass(name, definingContext, suppressed);
        if (clazz != null) {
            return clazz;
        }
    }
    ...
    return null;
}

// DexFile.java 
public Class loadClassBinaryName(String name, ClassLoader loader, List&amp;lt;Throwable&amp;gt; suppressed) {
    return defineClass(name, loader, mCookie, this, suppressed);
}

private static Class defineClass(String name, ClassLoader loader, Object cookie,
                                 DexFile dexFile, List&amp;lt;Throwable&amp;gt; suppressed) {
    Class result = null;
    try {
        result = defineClassNative(name, loader, cookie, dexFile);
    } catch (NoClassDefFoundError e) {
        ...
    } catch (ClassNotFoundException e) {
        ...
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从DexPathList的findClass()方法我们可以看到，在尝试加载一个类的时候，会遍历所有dex文件，只要找到就会直接返回，不会再继续遍历dexElements。&lt;/p&gt;

&lt;p&gt;也就是说当两个类不同的dex中出现，会优先处理排在前面的dex文件，这便是热修复的核心精髓，将需要修复的类所打包的dex文件插入到dexElements前面。&lt;/p&gt;

&lt;h1 id=&quot;4类加载流程&quot;&gt;4.类加载流程&lt;/h1&gt;

&lt;p&gt;在启动应用创建进程后，会调用ActivityThread.main()方法，在main()方法中ActivityThread与AMS建立交互，&lt;/p&gt;

&lt;p&gt;然后AMS调用ApplicationThread.bindApplication()方法，在bindApplication()方法中发送BIND_APPLICATION消息，执行handleBindApplication()方法，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
public static void main(String[] args) {
    ...
    ActivityThread thread = new ActivityThread();
    thread.attach(false, startSeq);
    ...
}
 
private void attach(boolean system, long startSeq) {
    ...
    final IActivityManager mgr = ActivityManager.getService();
    try {
        mgr.attachApplication(mAppThread, startSeq);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
    ...
}
 
private class ApplicationThread extends IApplicationThread.Stub {
    public final void bindApplication(String processName, ApplicationInfo appInfo,
        ...
        sendMessage(H.BIND_APPLICATION, data);
    }
}
 
private void handleBindApplication(AppBindData data) {
    ...
    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo, isSdkSandbox);
    ...
    Application app = data.info.makeApplication(data.restrictedBackupMode, null);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在handleBindApplication()方法中会调用getPackageInfoNoCheck()方法，其过程中会创建LoadedApk对象，这里需要注意的是构建LoadedApk传入的baseLoader为null，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,
        CompatibilityInfo compatInfo) {
    return getPackageInfo(ai, compatInfo, null, false, true, false, isSdkSandbox);
}
 
private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,
        ClassLoader baseLoader, boolean securityViolation, boolean includeCode,
        boolean registerPackage, boolean isSdkSandbox) {
        ...
        packageInfo =
                new LoadedApk(this, aInfo, compatInfo, baseLoader,
                        securityViolation, includeCode
                        &amp;amp;&amp;amp; (aInfo.flags &amp;amp; ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);
        ...
        return packageInfo;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，LoadedApk对象已经创建，其mBaseClassLoader为null。接下来继续makeApplication()的逻辑，&lt;/p&gt;

&lt;p&gt;这里会调用getClassLoader()方法，此时mClassLoader为null，调用createOrUpdateClassLoaderLocked()方法，&lt;/p&gt;

&lt;p&gt;此时mDefaultClassLoader也为null，调用ApplicationLoaders创建DefaultClassLoader，&lt;/p&gt;

&lt;p&gt;最后初始化mClassLoader，这里mDefaultClassLoader==mClassLoader，两者是相同的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// LoadedApk.java
public Application makeApplication(boolean forceDefaultAppClass,
        Instrumentation instrumentation) {
    return makeApplicationInner(forceDefaultAppClass, instrumentation,
            /* allowDuplicateInstances= */ true);
}

private Application makeApplicationInner(boolean forceDefaultAppClass,
        Instrumentation instrumentation, boolean allowDuplicateInstances) {
    ...
    final String myProcessName = Process.myProcessName();
    String appClass = mApplicationInfo.getCustomApplicationClassNameForProcess(
            myProcessName);
    if (forceDefaultAppClass || (appClass == null)) {
        appClass = &quot;android.app.Application&quot;;
    }

    try {
        final java.lang.ClassLoader cl = getClassLoader();
        ...
        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
        ...
        app = mActivityThread.mInstrumentation.newApplication(
                cl, appClass, appContext);
        appContext.setOuterContext(app);
    } catch (Exception e) {
        ...
    } 
    ...
    return app;
}
 
public ClassLoader getClassLoader() {
    synchronized (this) {
        if (mClassLoader == null) {
            createOrUpdateClassLoaderLocked(null /*addedPaths*/);
        }
        return mClassLoader;
    }
}
 
private void createOrUpdateClassLoaderLocked(List&amp;lt;String&amp;gt; addedPaths) {
    ...
    final List&amp;lt;String&amp;gt; zipPaths = new ArrayList&amp;lt;&amp;gt;(10);
    final List&amp;lt;String&amp;gt; libPaths = new ArrayList&amp;lt;&amp;gt;(10);
    ...
    makePaths(mActivityThread, isBundledApp, mApplicationInfo, zipPaths, libPaths);
    ...
    final String zip = (zipPaths.size() == 1) ? zipPaths.get(0) :
        TextUtils.join(File.pathSeparator, zipPaths);
    if (mDefaultClassLoader == null) {
        ...
        mDefaultClassLoader = ApplicationLoaders.getDefault().getClassLoaderWithSharedLibraries(
                zip, mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath,
                libraryPermittedPath, mBaseClassLoader,
                mApplicationInfo.classLoaderName, sharedLibraries.first, nativeSharedLibraries,
                sharedLibraries.second);
        mAppComponentFactory = createAppFactory(mApplicationInfo, mDefaultClassLoader);
        ...
    }
    if (!libPaths.isEmpty()) {
        ...
        try {
            ApplicationLoaders.getDefault().addNative(mDefaultClassLoader, libPaths);
        } finally {
            ...
        }
    }
    if (addedPaths != null &amp;amp;&amp;amp; addedPaths.size() &amp;gt; 0) {
        final String add = TextUtils.join(File.pathSeparator, addedPaths);
        ApplicationLoaders.getDefault().addPath(mDefaultClassLoader, add);
        ...
    }
    ...
    if (mClassLoader == null) {
        mClassLoader = mAppComponentFactory.instantiateClassLoader(mDefaultClassLoader,
                new ApplicationInfo(mApplicationInfo));
    }
}

public static void makePaths(ActivityThread activityThread,
                             boolean isBundledApp,
                             ApplicationInfo aInfo,
                             List&amp;lt;String&amp;gt; outZipPaths,
                             List&amp;lt;String&amp;gt; outLibPaths) {
    final String appDir = aInfo.sourceDir; // Full path to the base APK for this application.
    final String libDir = aInfo.nativeLibraryDir; // Full path to the directory where native JNI libraries are stored.

    outZipPaths.clear();
    outZipPaths.add(appDir); // data/app/**/base.apk
    ...
    if (outLibPaths != null) {
        if (outLibPaths.isEmpty()) {
            outLibPaths.add(libDir); 
        }

        if (aInfo.primaryCpuAbi != null) {
            ...
            for (String apk : outZipPaths) {
                outLibPaths.add(apk + &quot;!/lib/&quot; + aInfo.primaryCpuAbi);
            }
        }
        ...
    }
    ...
    appendSharedLibrariesLibPathsIfNeeded(
            aInfo.sharedLibraryInfos, aInfo, outSeenPaths, outLibPaths);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来看ApplicationLoaders里的逻辑，在getClassLoaderWithSharedLibraries()方法中会调用getClassLoader()方法，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ApplicationLoaders.java
ClassLoader getClassLoaderWithSharedLibraries(
        String zip, int targetSdkVersion, boolean isBundled,
        String librarySearchPath, String libraryPermittedPath,
        ClassLoader parent, String classLoaderName,
        List&amp;lt;ClassLoader&amp;gt; sharedLibraries, List&amp;lt;String&amp;gt; nativeSharedLibraries,
        List&amp;lt;ClassLoader&amp;gt; sharedLibrariesLoadedAfterApp) {
    // For normal usage the cache key used is the same as the zip path.
    return getClassLoader(zip, targetSdkVersion, isBundled, librarySearchPath,
                          libraryPermittedPath, parent, zip, classLoaderName, sharedLibraries,
                          nativeSharedLibraries, sharedLibrariesLoadedAfterApp);
}

// 这里传入的parent==null
private ClassLoader getClassLoader(String zip, int targetSdkVersion, boolean isBundled,
                                  String librarySearchPath, String libraryPermittedPath,
                                  ClassLoader parent, String cacheKey,
                                  String classLoaderName, List&amp;lt;ClassLoader&amp;gt; sharedLibraries,
                                  List&amp;lt;String&amp;gt; nativeSharedLibraries,
                                  List&amp;lt;ClassLoader&amp;gt; sharedLibrariesLoadedAfterApp) {
    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent(); // java.lang.BootClassLoader

    synchronized (mLoaders) {
        if (parent == null) {
            parent = baseParent;
        }

        if (parent == baseParent) {
            ...
            ClassLoader classloader = ClassLoaderFactory.createClassLoader(
                    zip,  librarySearchPath, libraryPermittedPath, parent,
                    targetSdkVersion, isBundled, classLoaderName, sharedLibraries,
                    nativeSharedLibraries, sharedLibrariesLoadedAfterApp);
            ...
            return classloader;
        }

        ClassLoader loader = ClassLoaderFactory.createClassLoader(
                zip, null, parent, classLoaderName, sharedLibraries,
                null /*sharedLibrariesLoadedAfterApp*/);

        return loader;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着看ClassLoaderFactory的逻辑，这里classloaderName为null，因此创建的是PathClassLoader。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ClassLoaderFactory.java
public static ClassLoader createClassLoader(String dexPath,
       String librarySearchPath, ClassLoader parent, String classloaderName,
       List&amp;lt;ClassLoader&amp;gt; sharedLibraries, List&amp;lt;ClassLoader&amp;gt; sharedLibrariesLoadedAfter) {
   ...
   if (isPathClassLoaderName(classloaderName)) {
       return new PathClassLoader(dexPath, librarySearchPath, parent, arrayOfSharedLibraries,
               arrayOfSharedLibrariesLoadedAfterApp);
   } else if (isDelegateLastClassLoaderName(classloaderName)) {
       return new DelegateLastClassLoader(dexPath, librarySearchPath, parent,
               arrayOfSharedLibraries, arrayOfSharedLibrariesLoadedAfterApp);
   }

    throw new AssertionError(&quot;Invalid classLoaderName: &quot; + classloaderName);
}
 
public static boolean isPathClassLoaderName(String name) {
    return name == null || PATH_CLASS_LOADER_NAME.equals(name) ||
            DEX_CLASS_LOADER_NAME.equals(name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回到LoadedApk.makeApplication()的逻辑，接下来会创建Application，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Instrumentation.java 
public Application newApplication(ClassLoader cl, String className, Context context)
        throws InstantiationException, IllegalAccessException,
        ClassNotFoundException {
    Application app = getFactory(context.getPackageName())
            .instantiateApplication(cl, className);
    app.attach(context);
    return app;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的className默认是android.app.Application，cl是之前创建的PathClassLoader。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// AppComponentFactory.java
public @NonNull Application instantiateApplication(@NonNull ClassLoader cl,
        @NonNull String className)
        throws InstantiationException, IllegalAccessException, ClassNotFoundException {
    return (Application) cl.loadClass(className).newInstance();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是应用PathClassLoader的创建流程以及应用代码是如何被加载的。需要注意的是基于双亲委派模型，最终加载android.app.Application类的classloader是BootClassLoader。&lt;/p&gt;

&lt;h1 id=&quot;5delegatelastclassloader&quot;&gt;5.DelegateLastClassLoader&lt;/h1&gt;

&lt;p&gt;在上文分析创建PathClassLoader代码中，还有一种类加载器DelegateLastClassLoader，继承于PathClassLoader，其加载class核心逻辑如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;@Override
protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // First, check whether the class has already been loaded. Return it if that&apos;s the
    // case.
    Class&amp;lt;?&amp;gt; cl = findLoadedClass(name);
    if (cl != null) {
        return cl;
    }
 
    // Next, check whether the class in question is present in the boot classpath.
    try {
        return Object.class.getClassLoader().loadClass(name);
    } catch (ClassNotFoundException ignored) {
    }
 
    // Next, check whether the class in question is present in the dexPath that this classloader
    // operates on, or its shared libraries.
    ClassNotFoundException fromSuper = null;
    try {
        return findClass(name);
    } catch (ClassNotFoundException ex) {
        fromSuper = ex;
    }
 
    // Finally, check whether the class in question is present in the parent classloader.
    try {
        return getParent().loadClass(name);
    } catch (ClassNotFoundException cnfe) {
        // The exception we&apos;re catching here is the CNFE thrown by the parent of this
        // classloader. However, we would like to throw a CNFE that provides details about
        // the class path / list of dex files associated with *this* classloader, so we choose
        // to throw the exception thrown from that lookup.
        throw fromSuper;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，判断该类是否已经被加载，如果已加载直接返回。&lt;/p&gt;

&lt;p&gt;然后，尝试由BootClassLoader加载。&lt;/p&gt;

&lt;p&gt;接着，尝试由DelegateLastClassLoader自身加载。&lt;/p&gt;

&lt;p&gt;最后，尝试由DelegateLastClassLoader的父加载器加载。&lt;/p&gt;

&lt;p&gt;可以看到DelegateLastClassLoader打破了双亲委派模型，先尝试自身加载，在交由parent加载。&lt;/p&gt;

&lt;h1 id=&quot;6replugin&quot;&gt;6.RePlugin&lt;/h1&gt;

&lt;p&gt;项目地址：https://github.com/Qihoo360/RePlugin&lt;/p&gt;

&lt;p&gt;其核心是在应用Application创建的时候，通过hook替换掉应用Context中的mPackageInfo中的mClassLoader，在自定义的DexClassLoader中优先加载插件类。&lt;/p&gt;

&lt;p&gt;RePluginClassLoader：用于替换Context中的mPackageInfo中的mClassLoader。&lt;/p&gt;

&lt;p&gt;PluginDexClassLoader：处理类加载逻辑，优先加载插件类。&lt;/p&gt;

&lt;p&gt;PatchClassLoaderUtils：通过hook实现替换Context中的mPackageInfo中的mClassLoader的功能。&lt;/p&gt;

&lt;h1 id=&quot;参考文档&quot;&gt;参考文档：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1517603&quot;&gt;彻底搞懂JVM类加载器：基本概念&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.tencent.com/developer/article/1520709&quot;&gt;类加载器中的双亲委派模型详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gityuan.com/2017/03/19/android-classloader/&quot;&gt;Android类加载器ClassLoader&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 24 Mar 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/03/24/Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/03/24/Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>ClassLoader</category>
        
        
      </item>
    
      <item>
        <title>Activity显示流程</title>
        <description>&lt;p&gt;在 &lt;a href=&quot;https://dreamsunny.github.io/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/&quot;&gt;Activity启动流程&lt;/a&gt; 中，我们知道了系统侧响应 Activity 启动请求会创建 Task ；&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&quot;https://dreamsunny.github.io/2022/12/24/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/&quot;&gt;DisplayArea树层级结构&lt;/a&gt;中，我们了解了 Task 最终会添加到 DefaultTaskDisplayArea ；&lt;/p&gt;

&lt;p&gt;本文主要梳理下Activity显示流程。&lt;/p&gt;

&lt;h1 id=&quot;1task添加到defaulttaskdisplayarea&quot;&gt;1.Task添加到DefaultTaskDisplayArea&lt;/h1&gt;

&lt;p&gt;调用堆栈如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/trace1.png&quot; alt=&quot;trace1&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// TaskDisplayArea.java
Task getOrCreateRootTask(..) {
    ...
    return new Task.Builder(mAtmService)
            ...
            .setParent(this)
            ...
            .build();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 setParent(this) 传入的是 TaskDisplayArea 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Task.java
Task build() {
    ...
    final Task task = buildInner();
    ...
    if (mParent != null) {
        if (mParent instanceof Task) {
            final Task parentTask = (Task) mParent;
            parentTask.addChild(task, mOnTop ? POSITION_TOP : POSITION_BOTTOM,
                    (mActivityInfo.flags &amp;amp; FLAG_SHOW_FOR_ALL_USERS) != 0);
        } else {
            mParent.addChild(task, mOnTop ? POSITION_TOP : POSITION_BOTTOM);
        }
    }
    ...
    return task;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Task.Builder的build() 方法中，将创建的task添加到 TaskDisplayArea。&lt;/p&gt;

&lt;h1 id=&quot;2activityrecord添加到task&quot;&gt;2.ActivityRecord添加到Task&lt;/h1&gt;

&lt;p&gt;调用堆栈如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/trace2.png&quot; alt=&quot;trace2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1.创建ActivityRecord：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityStarter.java
private int executeRequest(Request request) {
    ...
    final ActivityRecord r = new ActivityRecord.Builder(mService)
            ...
            .build();
    ...
}
// ActivityRecord.java
private ActivityRecord(..) {
    super(_service.mWindowManager, new Token(), TYPE_APPLICATION, true,
            null /* displayContent */, false /* ownerCanManageAppTokens */);
    ((Token) token).mActivityRef = new WeakReference&amp;lt;&amp;gt;(this);
}

private static class Token extends Binder {
    @NonNull WeakReference&amp;lt;ActivityRecord&amp;gt; mActivityRef;

    @Override
    public String toString() {
        return &quot;Token{&quot; + Integer.toHexString(System.identityHashCode(this)) + &quot; &quot;
                + mActivityRef.get() + &quot;}&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.添加到 Task 中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityStarter.java
private void addOrReparentStartingActivity(@NonNull Task task, String reason) {
    ..
    TaskFragment newParent = task;
    ...
    if (mStartActivity.getTaskFragment() == null
            || mStartActivity.getTaskFragment() == newParent) {
        newParent.addChild(mStartActivity, POSITION_TOP);
    } else {
        mStartActivity.reparent(newParent, newParent.getChildCount() /* top */, reason);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.添加到 DisplayContent 的 mTokenMap 中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowToken.java
void onDisplayChanged(DisplayContent dc) {
    dc.reParentWindowToken(this);
    super.onDisplayChanged(dc);
}
// DisplayContent.java
void reParentWindowToken(WindowToken token) {
    ...
    addWindowToken(token.token, token);
    ...
}

void addWindowToken(IBinder binder, WindowToken token) {
    ...
    mTokenMap.put(binder, token);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3activity窗口添加到wms&quot;&gt;3.Activity窗口添加到WMS&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_show.png&quot; alt=&quot;act_show&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;31-activitysetcontentview&quot;&gt;3.1 Activity.setContentView(..)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Activity.java
public void setContentView(@LayoutRes int layoutResID) {
    getWindow().setContentView(layoutResID);
    initWindowDecorActionBar();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activity.setContentView(..) 中直接调用 PhoneWindow.setContentView(..) 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// PhoneWindow.java
public void setContentView(int layoutResID) {
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        ...
    }

    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        ...
    } else {
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
    ...
}

private void installDecor() {
    mForceDecorInstall = false;
    if (mDecor == null) {
        mDecor = generateDecor(-1);
        ...
    } else {
        mDecor.setWindow(this);
    }
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor);
        ...
    }
}

protected DecorView generateDecor(int featureId) {
    ...
    return new DecorView(context, featureId, this, getAttributes());
}

protected ViewGroup generateLayout(DecorView decor) {
    ...
    int layoutResource;
    int features = getLocalFeatures();
    if ((features &amp;amp; ((1 &amp;lt;&amp;lt; FEATURE_LEFT_ICON) | (1 &amp;lt;&amp;lt; FEATURE_RIGHT_ICON))) != 0) {
        ..
    } else if ((features &amp;amp; ((1 &amp;lt;&amp;lt; FEATURE_PROGRESS) | (1 &amp;lt;&amp;lt; FEATURE_INDETERMINATE_PROGRESS))) != 0
        &amp;amp;&amp;amp; (features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_ACTION_BAR)) == 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_CUSTOM_TITLE)) != 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_NO_TITLE)) == 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) {
        ..
    } else {
        layoutResource = R.layout.screen_simple;
    }
    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);
    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
    ...
    return contentParent;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PhoneWindow.setContentView(..) 方法主要做3件事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建DecorView。&lt;/li&gt;
  &lt;li&gt;inflate Activity 根布局。&lt;/li&gt;
  &lt;li&gt;inflate Activity 视图布局（setContentView()传入的layoutResID）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中系统预置 Activity 根布局有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;feature&lt;/th&gt;
      &lt;th&gt;布局&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_LEFT_ICON&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_RIGHT_ICON&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_title_icons.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_PROGRESS&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_INDETERMINATE_PROGRESS&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_ACTION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_progress.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_CUSTOM_TITLE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_custom_title.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_NO_TITLE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_title.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_ACTION_MODE_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_simple_overlay_action_mode.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;else&lt;/td&gt;
      &lt;td&gt;screen_simple.xml&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以 screen_simple.xml 为例查看其布局：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// screen_simple.xml
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;
    android:orientation=&quot;vertical&quot;&amp;gt;
    &amp;lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot;
              android:inflatedId=&quot;@+id/action_mode_bar&quot;
              android:layout=&quot;@layout/action_mode_bar&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;wrap_content&quot;
              android:theme=&quot;?attr/actionBarTheme&quot; /&amp;gt;
    &amp;lt;FrameLayout
         android:id=&quot;@android:id/content&quot;
         android:layout_width=&quot;match_parent&quot;
         android:layout_height=&quot;match_parent&quot;
         android:foregroundInsidePadding=&quot;false&quot;
         android:foregroundGravity=&quot;fill_horizontal|top&quot;
         android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&amp;gt;
&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应整个 Activity 视图为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/decor.png&quot; alt=&quot;decor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终，Activity.setContentView(..) 传入的布局会添加到 FrameLayout(id=ID_ANDROID_CONTENT) 。&lt;/p&gt;

&lt;h2 id=&quot;32-viewrootimplsetview&quot;&gt;3.2 ViewRootImpl.setView(..)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ViewRootImpl.java
public ViewRootImpl(Context context, Display display) {
    this(context, display, WindowManagerGlobal.getWindowSession(),
            false /* useSfChoreographer */);
}

public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session) {
    this(context, display, session, false /* useSfChoreographer */);
}

public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session,
        boolean useSfChoreographer) {
    mWindowSession = session;
    mWindow = new W(this);
    ...
}

public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,
        int userId, Bundle bundle) {
    synchronized (this) {
        if (mView == null) {
            ...
            try {
                res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,
                        getHostVisibility(), mDisplay.getDisplayId(), userId,
                        mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,
                        mTempControls);
            } catch (RemoteException e) {
            } finally {
            }
            ...
        }
    }
}
// WindowManagerGlobal.java
public static IWindowSession getWindowSession() {
    synchronized (WindowManagerGlobal.class) {
        if (sWindowSession == null) {
            try {
                IWindowManager windowManager = getWindowManagerService();
                sWindowSession = windowManager.openSession(
                        new IWindowSessionCallback.Stub() {
                            @Override
                            public void onAnimatorScaleChanged(float scale) {
                                ValueAnimator.setDurationScale(scale);
                            }
                        });
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        return sWindowSession;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ViewRootImpl 是 View视图 与 WindowManager 的纽带，mIWindowSession、mWindow 为 Binder 对象，用于 APP 端与 WMS 之间的相互通信。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/win_binder.png&quot; alt=&quot;win_binder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里通过 IWindowSession.addToDisplayAsUser(..) 接口，请求WMS添加新窗口。&lt;/p&gt;

&lt;p&gt;此外，ViewRootImpl 管理整个 View 视图的绘制和 Input 事件分发。&lt;/p&gt;

&lt;h1 id=&quot;4wms添加窗口&quot;&gt;4.WMS添加窗口&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(Session session, IWindow client, LayoutParams attrs, ..) {
    WindowState parentWindow = null;
    final int type = attrs.type;
    synchronized (mGlobalLock) {
        final DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token);
        
        if (type &amp;gt;= FIRST_SUB_WINDOW &amp;amp;&amp;amp; type &amp;lt;= LAST_SUB_WINDOW) {
            parentWindow = windowForClientLocked(null, attrs.token, false);
            ...
        }

        ActivityRecord activity = null;
        final boolean hasParent = parentWindow != null;
        WindowToken token = displayContent.getWindowToken(
                hasParent ? parentWindow.mAttrs.token : attrs.token);
        final int rootType = hasParent ? parentWindow.mAttrs.type : type;

        if (token == null) {
            ...
        } else if (rootType &amp;gt;= FIRST_APPLICATION_WINDOW
                &amp;amp;&amp;amp; rootType &amp;lt;= LAST_APPLICATION_WINDOW) {
            activity = token.asActivityRecord();
            ...
        } else if (rootType == TYPE_INPUT_METHOD) {
            ...
        } else if (rootType == TYPE_VOICE_INTERACTION) {
            ...
        } else if (rootType == TYPE_WALLPAPER) {
            ...
        } else if (rootType == TYPE_ACCESSIBILITY_OVERLAY) {
            ...
        } else if (type == TYPE_TOAST) {
            ...
        } else if (type == TYPE_QS_DIALOG) {
            ...
        } else if (token.asActivityRecord() != null) {
            ...
        }

        final WindowState win = new WindowState(this, session, client, token, parentWindow,
                appOp[0], attrs, viewVisibility, session.mUid, userId,
                session.mCanAddInternalSystemWindow);
        win.attach();
        mWindowMap.put(client.asBinder(), win);
        win.mToken.addWindow(win);

        if (type == TYPE_APPLICATION_STARTING &amp;amp;&amp;amp; activity != null) {
            activity.attachStartingWindow(win);
        } else if (type == TYPE_INPUT_METHOD
            ...
        } else if (type == TYPE_INPUT_METHOD_DIALOG) {
            ...
        } else {
            ...
        }
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;41-创建windowstate&quot;&gt;4.1 创建WindowState&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    WindowToken token = displayContent.getWindowToken(
            hasParent ? parentWindow.mAttrs.token : attrs.token);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里传入的 token 是在创建 ActivityRecord 时创建的 Binder 对象（见上文2），获取到的 WindowToken 为 ActivityRecord 对象。&lt;/p&gt;

&lt;p&gt;WMS每一个新窗口都会对应创建一个 WindowState 对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    final WindowState win = new WindowState(this, session, client, token, parentWindow,
            appOp[0], attrs, viewVisibility, session.mUid, userId,
            session.mCanAddInternalSystemWindow);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以 Activity 页面弹出一个Dialog对话框为例，WindowToken 与 WindowState 的关系为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/win_token.png&quot; alt=&quot;win_token&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;42-创建surfacesession&quot;&gt;4.2 创建SurfaceSession&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    synchronized (mGlobalLock) {
        ...
        final WindowState win = new WindowState(...);
        win.attach();
        ...
    }
    return res;
}

// WindowState.java
void attach() {
    mSession.windowAddedLocked();
}

// Session.java
void windowAddedLocked() {
    ...
    if (mSurfaceSession == null) {
        mSurfaceSession = new SurfaceSession();
        ...
    }
}

// SurfaceSession.java
/** Create a new connection with the surface flinger. */
@UnsupportedAppUsage
public SurfaceSession() {
    mNativeClient = nativeCreate();
}

// android_view_SurfaceSession.cpp
static jlong nativeCreate(JNIEnv* env, jclass clazz) {
    SurfaceComposerClient* client = new SurfaceComposerClient();
    client-&amp;gt;incStrong((void*)nativeCreate);
    return reinterpret_cast&amp;lt;jlong&amp;gt;(client);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SurfaceSession 构造方法中通过 nativeCreate() 方法返回了一个 SurfaceComposerClient 指针，它表示一个跟 SurfaceFlinger 的连接，当其第一次被使用时会调用 onFirstRef() 方法，创建一个实现 ISurfaceComposerClient 接口的 Client 对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// SurfaceComposerClient.cpp
void SurfaceComposerClient::onFirstRef() {
    sp&amp;lt;ISurfaceComposer&amp;gt; sf(ComposerService::getComposerService());
    if (sf != nullptr &amp;amp;&amp;amp; mStatus == NO_INIT) {
        sp&amp;lt;ISurfaceComposerClient&amp;gt; conn;
        conn = sf-&amp;gt;createConnection();
        if (conn != nullptr) {
            mClient = conn;
            mStatus = NO_ERROR;
        }
    }
}

// SurfaceFlinger.cpp
sp&amp;lt;ISurfaceComposerClient&amp;gt; SurfaceFlinger::createConnection() {
    const sp&amp;lt;Client&amp;gt; client = new Client(this);
    return client-&amp;gt;initCheck() == NO_ERROR ? client : nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WMS 创建了一个 WindowState 对象表示客户端的一个 Window，接着调用 WindowState.attach() 方法创建了一个 SurfaceSession 对象，SurfaceSession 表示一个跟 SurfaceFlinger 的连接，它创建了一个 SurfaceComposerClient 对象，然后 SurfaceFlinger 又创建了一个 Client 对象。&lt;/p&gt;

&lt;h2 id=&quot;43-windowstate添加到activityrecord&quot;&gt;4.3 WindowState添加到ActivityRecord&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    final WindowState win = new WindowState(.., token, ..);
    ...
    win.mToken.addWindow(win);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;5应用绘制&quot;&gt;5.应用绘制&lt;/h1&gt;

&lt;h2 id=&quot;51-创建surface&quot;&gt;5.1 创建Surface&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ViewRootImpl.java
public final Surface mSurface = new Surface();
private final SurfaceControl mSurfaceControl = new SurfaceControl();
private BLASTBufferQueue mBlastBufferQueue;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建 ViewRootImp 实例时，会创建一个空的 Surface 和 SurfaceControl 对象，其初始化流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ViewRootImpl$TraversalRunnable.run(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.doTraversal(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.performTraversals(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.relayoutWindow(..)&lt;/li&gt;
  &lt;li&gt;Session.relayout(.., mSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowManagerService.relayoutWindow(.., outSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowManagerService.createSurfaceControl(outSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowStateAnimator.createSurfaceLocked()&lt;/li&gt;
  &lt;li&gt;new WindowSurfaceController(..)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.Builder.build()&lt;/li&gt;
  &lt;li&gt;new SurfaceControl(..)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.nativeCreate(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// android_view_SurfaceControl.cpp
static jlong nativeCreate(..) {
    sp&amp;lt;SurfaceComposerClient&amp;gt; client;
    if (sessionObj != NULL) {
        client = android_view_SurfaceSession_getClient(env, sessionObj);
    } else {
        client = SurfaceComposerClient::getDefault();
    }

    sp&amp;lt;SurfaceControl&amp;gt; surface;
    status_t err = client-&amp;gt;createSurfaceChecked(String8(name.c_str()), w, h, format, &amp;amp;surface,
                                                flags, parentHandle, std::move(metadata));
    surface-&amp;gt;incStrong((void *)nativeCreate);
    return reinterpret_cast&amp;lt;jlong&amp;gt;(surface.get());
}

// SurfaceComposerClient.cpp 
status_t SurfaceComposerClient::createSurfaceChecked(..) {
    status_t err = mStatus;

    if (mStatus == NO_ERROR) {
        sp&amp;lt;IBinder&amp;gt; handle;
        sp&amp;lt;IGraphicBufferProducer&amp;gt; gbp;

        err = mClient-&amp;gt;createSurface(name, w, h, format, flags, parentHandle, std::move(metadata),
                                     &amp;amp;handle, &amp;amp;gbp, &amp;amp;id, &amp;amp;transformHint);

        if (err == NO_ERROR) {
            *outSurface =
                    new SurfaceControl(this, handle, gbp, id, w, h, format, transformHint, flags);
        }
    }
    return err;
}

// surfaceflinger/Client.cpp
status_t Client::createSurface(..) {
    LayerCreationArgs args(mFlinger.get(), this, name.c_str(), flags, std::move(metadata));
    return mFlinger-&amp;gt;createLayer(args, outHandle, parentHandle, outLayerId, nullptr,
                                 outTransformHint);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;WindowSurfaceController.getSurfaceControl(outSurfaceControl)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.copyFrom(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;outSurfaceControl.copyFrom(mSurfaceControl, &quot;WindowSurfaceController.getSurfaceControl&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;SurfaceControl.nativeCopyFromSurfaceControl(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.updateBlastSurfaceIfNeeded()&lt;/li&gt;
  &lt;li&gt;new BLASTBufferQueue(mTag, mSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;BLASTBufferQueue.createSurface()&lt;/li&gt;
  &lt;li&gt;BLASTBufferQueue.nativeGetSurface(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// android_graphics_BLASTBufferQueue.cpp
static jobject nativeGetSurface(JNIEnv* env, jclass clazz, jlong ptr,
                                jboolean includeSurfaceControlHandle) {
    sp&amp;lt;BLASTBufferQueue&amp;gt; queue = reinterpret_cast&amp;lt;BLASTBufferQueue*&amp;gt;(ptr);
    return android_view_Surface_createFromSurface(env,
                                                  queue-&amp;gt;getSurface(includeSurfaceControlHandle));
}

// BLASTBufferQueue.cpp
sp&amp;lt;Surface&amp;gt; BLASTBufferQueue::getSurface(bool includeSurfaceControlHandle) {
    std::unique_lock _lock{mMutex};
    sp&amp;lt;IBinder&amp;gt; scHandle = nullptr;
    if (includeSurfaceControlHandle &amp;amp;&amp;amp; mSurfaceControl) {
        scHandle = mSurfaceControl-&amp;gt;getHandle();
    }
    return new BBQSurface(mProducer, true, scHandle, this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;Surface.transferFrom(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;mSurface.transferFrom(blastSurface);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;Surface.setNativeObjectLocked(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 Java 层中 ViewRootImpl 实例中持有一个 Surface 对象，该 Surface 对象中的 mNativeObject 属性指向 native 层中创建的 Surface 对象，native 层的 Surface 对应 SurfaceFlinger 中的 Layer 对象，它持有 Layer 中的 BufferQueueProducer 生产者指针，在 Surface 上绘制的内容最终会交由 SurfaceFlinger 来合成渲染送到显示器显示。&lt;/p&gt;

&lt;h2 id=&quot;52-view绘制构建阶段&quot;&gt;5.2 View绘制：构建阶段&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw1.png&quot; alt=&quot;view_draw1&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Choreographer.java

private final class FrameDisplayEventReceiver extends DisplayEventReceiver
        implements Runnable {

    @Override
    public void onVsync(..) {
        try {
            ...
            Message msg = Message.obtain(mHandler, this);
            msg.setAsynchronous(true);
            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
        } finally {
        }
    }

    @Override
    public void run() {
        doFrame(mTimestampNanos, mFrame, mLastVsyncEventData);
    }
}

void doFrame(..) {
    try {
        ...
        doCallbacks(Choreographer.CALLBACK_INPUT, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameData, frameIntervalNanos);
    } finally {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Choreographer中收到Vsync信号后，向主线程MessageQueue发送一条异步Message，当异步Message执行后会调用其doFrame(..)方法，依次执行 INPUT、ANIMATION、INSETS_ANIMATION、TRAVERSAL、COMMIT 回调。&lt;/p&gt;

&lt;p&gt;在 TRAVERSAL 回调中会执行 mTraversalRunnable ，其 run() 方法中调用 doTraversal() 方法，执行 performTraversals() 方法，接着依次执行 View 的 measure、layout、draw 流程的代码。&lt;/p&gt;

&lt;h2 id=&quot;53-view绘制渲染阶段&quot;&gt;5.3 View绘制：渲染阶段&lt;/h2&gt;

&lt;p&gt;RenderThread线程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw2.png&quot; alt=&quot;view_draw2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;渲染方式：软件绘制（CPU） VS 硬件绘制（GPU）&lt;/p&gt;

&lt;p&gt;渲染引擎：OpenGL VS Vulkan&lt;/p&gt;

&lt;h2 id=&quot;54-surfaceflinger合成显示&quot;&gt;5.4 SurfaceFlinger：合成显示&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw3.png&quot; alt=&quot;view_draw3&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;6小结&quot;&gt;6.小结&lt;/h1&gt;

&lt;p&gt;应用侧 Window 是一个抽象概念，用来描述顶层视图的外观和行为，唯一的实现类是 PhoneWindow。&lt;/p&gt;

&lt;p&gt;在创建 Activity / Dialog 时，会创建 PhoneWindow ，同时会创建 DecorView 。&lt;/p&gt;

&lt;p&gt;应用侧向WMS请求添加视图时，会创建ViewRootImpl，同时会创建 Surface，视图绘制的数据会写入  Surface，由 SurfaceFlinger 合成显示。&lt;/p&gt;

&lt;p&gt;WMS添加应用侧视图时会创建 WindowState 用来对应一个 Window，同时维护 Window 的 Z-Order 。&lt;/p&gt;

&lt;h1 id=&quot;7参考文档&quot;&gt;7.参考文档&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.simowce.com/all-about-blastbbq/&quot;&gt;BLASTBufferQueue 详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/50a30fa6952e&quot;&gt;BBQ 机制介绍&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/cdc60627df90&quot;&gt;BBQ 原理解读&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/384a5cd2e304&quot;&gt;BBQ 运用场景&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/19/Activity%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/19/Activity%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>Activity</category>
        
        
      </item>
    
      <item>
        <title>Activity启动流程</title>
        <description>&lt;h1 id=&quot;1activity官方文档&quot;&gt;1.Activity官方文档&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/components/activities/intro-activities?hl=zh-cn&quot;&gt;Activity 简介&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle?hl=zh-cn&quot;&gt;Activity 生命周期&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/topics/manifest/activity-element?hl=zh-cn&quot;&gt;应用清单&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;2activity启动流程&quot;&gt;2.Activity启动流程&lt;/h1&gt;

&lt;p&gt;在桌面点击时钟图标打开闹钟应用，使用系统跟踪抓取 trace 文件，在 &lt;a href=&quot;https://ui.perfetto.dev/&quot;&gt;perfetto&lt;/a&gt; 打开查看：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/startActivity.perfetto-trace&quot;&gt;startActivity.perfetto-trace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_start.png&quot; alt=&quot;act_start&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了让整个过程可视化，对系统侧相关类做了代码插桩，在进入/退出方法处加上Trace日志：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/startActivityinjected.perfetto-trace&quot;&gt;startActivityinjected.perfetto-trace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在此基础上需要掌握调试安卓Framework源码 ，再结合trace来学习源码。&lt;/p&gt;

&lt;h2 id=&quot;21-点击应用图标&quot;&gt;2.1 点击应用图标&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;InputReader 负责从 EventHub 里面把 Input 事件读取出来，然后交给 InputDispatcher 进行事件分发。&lt;/li&gt;
  &lt;li&gt;InputDispatcher 在拿到 InputReader 获取的事件后对 Input 事件进行包装，然后寻找并分发到目标窗口。&lt;/li&gt;
  &lt;li&gt;InboundQueue（iq）队列中放着 InputDispatcher 从 InputReader 中拿到的 Input 事件。&lt;/li&gt;
  &lt;li&gt;OutboundQueue（oq）队列里面放的是即将要被派发给各个目标窗口的 Input 事件。&lt;/li&gt;
  &lt;li&gt;WaitQueue（wq）队列里面记录的是已经派发给目标窗口等待其处理完的 Input 事件。&lt;/li&gt;
  &lt;li&gt;PendingInputEventQueue（aq）队列中记录的是应用需要处理的 Input 事件。&lt;/li&gt;
  &lt;li&gt;deliverInputEvent 标识 App UI Thread 被 Input 事件唤醒。&lt;/li&gt;
  &lt;li&gt;App 响应处理 Input 事件，内部会在其界面 View 树中传递处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;22-启动闹钟应用&quot;&gt;2.2 启动闹钟应用&lt;/h2&gt;

&lt;h3 id=&quot;221-桌面请求启动闹钟应用&quot;&gt;2.2.1 桌面请求启动闹钟应用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Activity.startActivityForResult(..)&lt;/li&gt;
  &lt;li&gt;Instrumentation.execStartActivity(..)&lt;/li&gt;
  &lt;li&gt;ActivityTaskManager.&lt;em&gt;getService&lt;/em&gt;().startActivity(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private static final Singleton&amp;lt;IActivityTaskManager&amp;gt; IActivityTaskManagerSingleton =
        new Singleton&amp;lt;IActivityTaskManager&amp;gt;() {
            @Override
            protected IActivityTaskManager create() {
                final IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);
                return IActivityTaskManager.Stub.asInterface(b);
            }
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;222-系统侧处理请求&quot;&gt;2.2.2 系统侧处理请求&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/atms_start_act.png&quot; alt=&quot;atms_start_act&quot; /&gt;&lt;/p&gt;

&lt;p&gt;核心逻辑从ActivityStarter.execute()方法开始：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. ActivityStarter$Request.resolveActivity(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;解析 ResolveInfo 和 ActivityInfo，最终调用到 ComputerEngine.queryIntentActivitiesInternal(..)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/resolve_act.png&quot; alt=&quot;resolve_act&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有个细节是处理 显式启动 与 隐式启动 的区别：&lt;a href=&quot;https://developer.android.com/guide/components/intents-filters?hl=zh-cn&quot;&gt;Intent 和 Intent 过滤器&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;queryIntentActivitiesInternal(..) {
    ComponentName comp = intent.getComponent();
    if (comp != null) {
        getActivityInfo(..)
    } else {
        queryIntentActivitiesInternalBody(..)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. ActivityStarter.executeRequest()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.1 权限检查&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.1 启动权限检查：ActivityTaskSupervisor.checkStartAnyActivityPermission(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;应用AndroidManifest.xml配置项：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;android:exported&lt;/th&gt;
      &lt;th&gt;activity 是否可由其他应用的组件启动。&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;android:permission&lt;/td&gt;
      &lt;td&gt;启动 activity 或以其他方式使 activity 响应 intent 时，客户端必须具备的权限的名称。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;2.1.2 允许后台启动检查：ActivityStarter.shouldAbortBackgroundActivityStart(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;详见 &lt;a href=&quot;https://developer.android.com/guide/components/activities/background-starts?hl=zh-cn&quot;&gt;从后台启动 Activity 的限制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.2 创建ActivityRecord&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Activity 的实例是在应用侧创建的，系统侧会创建 ActivityRecord 与之对应，用来存储 Activity 的相关信息。&lt;/p&gt;

&lt;p&gt;相关文档：&lt;a href=&quot;http://gityuan.com/2017/06/11/activity_record/&quot;&gt;四大组件之ActivityRecord&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.3 ActivityStarter#startActivityUnchecked&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.1 ActivityTaskManagerService.deferWindowLayout(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;延迟当前进行的布局，因为页面即将要刷新，继续进行布局没有意义，与 continueWindowLayout() 成对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.2 ActivityStarter.startActivityInner(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这部分的核心逻辑围绕 &lt;a href=&quot;https://developer.android.com/guide/components/activities/tasks-and-back-stack?hl=zh-cn&quot;&gt;任务和返回堆栈 &lt;/a&gt;内容展开：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Task（任务）是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Task（任务）是一个整体单元，当用户开始一个新任务或通过主屏幕按钮进入主屏幕时，任务可移至“后台”。“后台”任务可重新返回到“前台”，以便用户可以从他们离开的地方继续操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了更直观地理解这部分内容，写了一个示例应用：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/activityLaunchMode.apk&quot;&gt;activityLaunchMode.apk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.ActivityStarter#setInitialState&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act1.png&quot; alt=&quot;act1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.ActivityStarter#computeLaunchingTaskFlags&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act2.png&quot; alt=&quot;act2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要判断是否添加 &lt;a href=&quot;https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_NEW_TASK&quot;&gt;FLAG_ACTIVITY_NEW_TASK&lt;/a&gt; 属性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.计算4个task&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Get top task at beginning because the order may be changed when reusing existing task.
final Task prevTopRootTask = mPreferredTaskDisplayArea.getFocusedRootTask();
final Task prevTopTask = prevTopRootTask != null ? prevTopRootTask.getTopLeafTask() : null;
final Task reusedTask = getReusableTask();
final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act3.png&quot; alt=&quot;act3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要逻辑是查找是否存在Activity可复用的Task。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.ActivityStarter#isAllowedToStart&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act4.png&quot; alt=&quot;act4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于 targetTask 再次判断 Activity 是否允许启动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.ActivityStarter#recycleTask&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final boolean newTask = targetTask == null;
final ActivityRecord targetTaskTop = newTask
        ? null : targetTask.getTopNonFinishingActivity();
if (targetTaskTop != null) {
    recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);
} else {
    mAddingToTask = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复用targetTask，从桌面点击应用图标启动应用，targetTask 为 null，不会走 recycleTask() 逻辑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.ActivityStarter#getOrCreateRootTask&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act5.png&quot; alt=&quot;act5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里会创建 RootTask（截图中选中位置）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.ActivityStarter#setNewTask&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (newTask) {
    final Task taskToAffiliate = (mLaunchTaskBehind &amp;amp;&amp;amp; mSourceRecord != null)
            ? mSourceRecord.getTask() : null;
    setNewTask(taskToAffiliate);
} else if (mAddingToTask) {
    addOrReparentStartingActivity(targetTask, &quot;adding to task&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act6.png&quot; alt=&quot;act6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;调用 Task.reuseOrCreateTask(..) 复用或者创建 Task（截图中选中位置），这里会复用刚才创建的 RootTask。&lt;/p&gt;

&lt;p&gt;这里还有一个逻辑是 ActivityStarter#addOrReparentStartingActivity ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (mStartActivity.getTaskFragment() == null
        || mStartActivity.getTaskFragment() == newParent) {
    newParent.addChild(mStartActivity, POSITION_TOP);
} else {
    mStartActivity.reparent(newParent, newParent.getChildCount() /* top */, reason);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mStartActivity 是 ActivityRecord，newParent 是 Task，将ActivityRecord添加到Task中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.Task#moveToFront&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act7.png&quot; alt=&quot;act7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里是将 mTargetRootTask 移至“前台”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.Task#startActivityLocked&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act8.png&quot; alt=&quot;act8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有个应用启动优化项：StartingWindow。&lt;/p&gt;

&lt;p&gt;相关介绍文档：&lt;a href=&quot;https://androidperformance.com/2018/05/20/zhihu-startingwindow/#/StartingWindow-对用户体验的影响&quot;&gt;知乎 救救你的 StartingWindow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10.RootWindowContainer#resumeFocusedTasksTopActivities&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act9.png&quot; alt=&quot;act9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前面已经把 mTargetRootTask 移至“前台”，这里是把 mStartActivity 移至“前台”，主要逻辑在TaskFragment#resumeTopActivity。&lt;/p&gt;

&lt;p&gt;在目标 Activity 显示出来之前，需要把 RootTask 中其他 Activities 暂停：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act10.png&quot; alt=&quot;act10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终会调用到 TaskFragment#schedulePauseActivity （截图中选中位置）通知桌面暂停Launcher，详见 2.2.3。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;void schedulePauseActivity(..) {
    mAtmService.getLifecycleManager().scheduleTransaction(prev.app.getThread(),
            prev.token, PauseActivityItem.obtain(..));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来会判断应用进程是否存在，如果不存在先创建应用进程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;boolean pausing = !deferPause &amp;amp;&amp;amp; taskDisplayArea.pauseBackTasks(next);
if (pausing) {
    if (next.attachedToProcess()) {
        //应用进程存在
        next.app.updateProcessInfo(..);
    } else if (!next.isProcessRunning()) {
        //应用进程不存在，创建进程
        mAtmService.startProcessAsync(..);
    }
} else if (mResumedActivity == next &amp;amp;&amp;amp; next.isState(RESUMED)
        &amp;amp;&amp;amp; taskDisplayArea.allResumedActivitiesComplete()) {
    //执行过渡动画
    executeAppTransition(options);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里闹钟进程不存在，会请求 Zygote 创建闹钟进程，详见 2.3。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.3 ActivityTaskManagerService.continueWindowLayout(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与上文 deferWindowLayout(..) 成对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.4 ActivityStarter.postStartActivityProcessing(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ActivityStartInterceptor 回调监听者 onActivityLaunched(..)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (ActivityManager.isStartResultSuccessful(result)) {
    mInterceptor.onActivityLaunched(targetTask.getTaskInfo(), r);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;223-桌面activitypause&quot;&gt;2.2.3 桌面activityPause&lt;/h3&gt;

&lt;p&gt;桌面收到系统侧 activityPause 通知，处理完后再通知系统侧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_pause1.png&quot; alt=&quot;act_pause1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统侧收到桌面 activityPause 通知：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_pause2.png&quot; alt=&quot;act_pause2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;startSpecificActivity(..) 有多个入口，当应用进程创建完执行 attachApplication 后，才会执行 realStartActivityLocked(..)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final WindowProcessController wpc = mService.getProcessController(..);
if (wpc != null &amp;amp;&amp;amp; wpc.hasThread()) {
    realStartActivityLocked(r, wpc, andResume, checkConfig);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 realStartActivityLocked(..) 中会通知应用侧执行 Activity 生命周期回调，详见 2.5：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final ClientTransaction clientTransaction = ClientTransaction.obtain(..);
clientTransaction.addCallback(LaunchActivityItem.obtain(..));
clientTransaction.setLifecycleStateRequest(ResumeActivityItem.obtain(..));
mService.getLifecycleManager().scheduleTransaction(clientTransaction);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;224-桌面activitystop&quot;&gt;2.2.4 桌面activityStop&lt;/h3&gt;

&lt;p&gt;上接 2.2.3，在显示出 Activity 前会执行 AppTransition 过渡动画：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_stop1.png&quot; alt=&quot;act_stop1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过渡动画执行完后，会通知桌面执行activityStop：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_stop2.png&quot; alt=&quot;act_stop2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结下两个应用 Activity 生命周期：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;桌面 Launcher 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onPause()&lt;/code&gt; 方法执行。&lt;/li&gt;
  &lt;li&gt;闹钟 DeskClockTabActivity 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStart()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onResume()&lt;/code&gt; 方法依次执行（闹钟 DeskClockTabActivity 现在具有用户焦点）。&lt;/li&gt;
  &lt;li&gt;桌面 Launcher 在屏幕上不再显示，其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStop()&lt;/code&gt; 方法执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;23-创建闹钟进程&quot;&gt;2.3 创建闹钟进程&lt;/h2&gt;

&lt;h3 id=&quot;231-系统侧请求创建闹钟进程&quot;&gt;2.3.1 系统侧请求创建闹钟进程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityManagerService.startProcess(..)&lt;/li&gt;
  &lt;li&gt;ActivityManagerService.startProcessLocked(..)&lt;/li&gt;
  &lt;li&gt;ProcessList.startProcessLocked(..)&lt;/li&gt;
  &lt;li&gt;ProcessList.startProcess(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (hostingRecord.usesWebviewZygote()) {
    WebViewZygote.getProcess().start(..)
} else if (hostingRecord.usesAppZygote()) {
    // see FLAG_USE_APP_ZYGOTE
    appZygote.getProcess().start(..)
} else {
    Process.start(..);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;ZYGOTE_PROCESS.start(..)&lt;/li&gt;
  &lt;li&gt;ZYGOTE_PROCESS.startViaZygote(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;static ZygoteState connect(@NonNull LocalSocketAddress zygoteSocketAddress,
        @Nullable LocalSocketAddress usapSocketAddress)
        throws IOException {

    final LocalSocket zygoteSessionSocket = new LocalSocket();

    try {
        zygoteSessionSocket.connect(zygoteSocketAddress);
    } catch (IOException ex) {
    }
    
    return new ZygoteState(..)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;ZYGOTE_PROCESS.zygoteSendArgsAndGetResult(..)&lt;/li&gt;
  &lt;li&gt;ZYGOTE_PROCESS.attemptZygoteSendArgsAndGetResult(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private Process.ProcessStartResult attemptZygoteSendArgsAndGetResult(
        ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx {
    try {
        final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;
        final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;

        zygoteWriter.write(msgStr);
        zygoteWriter.flush();

        // Always read the entire result from the input stream to avoid leaving
        // bytes in the stream for future process starts to accidentally stumble
        // upon.
        Process.ProcessStartResult result = new Process.ProcessStartResult();
        result.pid = zygoteInputStream.readInt();
        result.usingWrapper = zygoteInputStream.readBoolean();

        if (result.pid &amp;lt; 0) {
            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);
        }

        return result;
    } catch (IOException ex) {
        zygoteState.close();
        throw new ZygoteStartFailedEx(ex);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Q：这里为什么不采用Binder进行通信？&lt;/p&gt;

&lt;p&gt;A：fork机制限制，仅支持单线程，而binder会创建多线程。&lt;/p&gt;

&lt;h3 id=&quot;232-zygote创建闹钟进程&quot;&gt;2.3.2 Zygote创建闹钟进程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ZygoteServer.runSelectLoop(..)&lt;/li&gt;
  &lt;li&gt;ZygoteConnection.processCommand(..)&lt;/li&gt;
  &lt;li&gt;Zygote.forkAndSpecialize(..)&lt;/li&gt;
  &lt;li&gt;Zygote.nativeForkAndSpecialize(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;int pid = Zygote.forkAndSpecialize(..);
if (pid == 0) {
    // in child
    handleChildProc(..);
} else {
    // In the parent
    handleParentProc(..);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;24-闹钟主线程初始化&quot;&gt;2.4 闹钟主线程初始化&lt;/h2&gt;

&lt;h3 id=&quot;241-闹钟向系统侧请求attachapplication&quot;&gt;2.4.1 闹钟向系统侧请求attachApplication&lt;/h3&gt;

&lt;p&gt;闹钟进程创建完成后初始化，上接 2.3.2：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Zygote.handleChildProc(..)&lt;/li&gt;
  &lt;li&gt;ZygoteInit.zygoteInit(..)&lt;/li&gt;
  &lt;li&gt;RuntimeInit.applicationInit(..)&lt;/li&gt;
  &lt;li&gt;RuntimeInit.findStaticMain(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.main(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.attach(..)&lt;/li&gt;
  &lt;li&gt;ActivityManagerService.attachApplication(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/application1.png&quot; alt=&quot;application1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统侧收到闹钟 attachApplication 通知，上接 2.2.3，在此之后才会真正启动Activity：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/application2.png&quot; alt=&quot;application2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外，Looper 也是在 ActivityThread.main(..) 中初始化的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;Looper.prepareMainLooper();
Looper.loop();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;242-闹钟处理系统侧bindapplication请求&quot;&gt;2.4.2 闹钟处理系统侧bindApplication请求&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityThread$ApplicationThread.bindApplication(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.sendMessage(H.BIND_APPLICATION, data) // 第一条消息&lt;/li&gt;
  &lt;li&gt;ActivityThread.handleBindApplication(data)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
private void handleBindApplication(AppBindData data) {
    ...
    // JVMTI
    if (agent != null) {
        handleAttachAgent(agent, data.info);
    }

    // 1.创建ContextImpl
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);

    // 2.创建Instrumentation
    if (ii != null) {
        initInstrumentation(ii, data, appContext);
    } else {
        mInstrumentation = new Instrumentation();
        mInstrumentation.basicInit(this);
    }

    try {
        // 3.创建 Application
        app = data.info.makeApplicationInner(data.restrictedBackupMode, null);
        ...
        if (!data.restrictedBackupMode) {
            if (!ArrayUtils.isEmpty(data.providers)) {
                // 初始化ContentProvider
                installContentProviders(app, data.providers);
            }
        }
        ...
        try {
            // call Instrumentation.onCreate()
            mInstrumentation.onCreate(data.instrumentationArgs);
        }
        catch (Exception e) {
        }
        ...
        try {
            // call Application.onCreate()
            mInstrumentation.callApplicationOnCreate(app);
        } catch (Exception e) {
        }
    } finally {
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;25-闹钟activity生命周期&quot;&gt;2.5 闹钟Activity生命周期&lt;/h2&gt;

&lt;p&gt;上接 2.2.3，实例化Activity：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityThread$ApplicationThread.scheduleTransaction(..)&lt;/li&gt;
  &lt;li&gt;ClientTransactionHandler.scheduleTransaction(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread$H.handleMessage(..)&lt;/li&gt;
  &lt;li&gt;TransactionExecutor.execute(..)&lt;/li&gt;
  &lt;li&gt;LaunchActivityItem.execute(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.handleLaunchActivity(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.performLaunchActivity(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;try {
    java.lang.ClassLoader cl = appContext.getClassLoader();
    activity = mInstrumentation.newActivity(
            cl, component.getClassName(), r.intent);
} catch (Exception e) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activity创建后依次执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStart()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onResume()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_lifecycle.png&quot; alt=&quot;act_lifecycle&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;26-activity绘制及显示到屏幕&quot;&gt;2.6 Activity绘制及显示到屏幕&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_draw1.png&quot; alt=&quot;act_draw1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在VSYNC-app周期内：SurfaceFlinger的app线程唤醒home主线程，接下来执行Choreographer的doFrame流程，包括input，animation，traversal阶段，在traversal中执行draw绘制并将绘制的内容同步给RenderThread线程。RenderThread线程先从buffer队列中dequeueBuffer申请一个buffer，填充内容，然后queueBuffer将buffer加入队列，并通知SurfaceFlinger。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_draw2.png&quot; alt=&quot;act_draw2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在VSYNC-sf周期内：处理MessageQueue::INVALIDATE消息，从各Layer的BufferQueue拿到最新的缓冲数据，并根据内容更新脏区域；处理MessageQueue::REFRESH消息，通过HWC合成各Layer的buffer，发送至显示设备进行显示。&lt;/p&gt;

&lt;h1 id=&quot;3-小结&quot;&gt;3. 小结&lt;/h1&gt;

&lt;p&gt;本文以在桌面点击图标启动闹钟应用为例，结合trace简单介绍了Activity启动流程中的关键细节，主要包括：Framework侧处理Activity启动请求、任务和返回栈、Activity生命周期、应用进程创建及初始化及绘制流程等。&lt;/p&gt;

&lt;p&gt;可延伸的知识点包括：Context、Window、View事件分发、View绘制流程、Handler机制、Binder机制、类加载机制、fork机制、ServiceManager、SurfaceFlinger、代码插桩、插件化等。&lt;/p&gt;

&lt;h1 id=&quot;4-参考文档&quot;&gt;4. 参考文档：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/37370c1d17fc&quot;&gt;Android应用启动全流程分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/cf531a3af828&quot;&gt;Android卡顿掉帧问题分析之工具篇&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>Activity</category>
        
        
      </item>
    
      <item>
        <title>DisplayArea树层级结构</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/class_hierarchy.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;RootWindowContainer：最顶层的管理者，直接管理 DisplayContent 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DisplayContent：对应一个真实或者虚拟的显示设备。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TaskDisplayArea：是系统中所有应用任务的父节点，用于管理 Task 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Task：代表一个任务，可以包含多个 Activity 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ActivityRecord：对应一个 Activity 节点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;WindowState：对应一个窗口。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1window相关概念&quot;&gt;1.Window相关概念&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Window Type主要分为三大类：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Application windows（应用窗口）: 1~99&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sub-windows（子窗口）: 1000~1999&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;System windows（系统窗口）: 2000~2999&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Window Layer分为36层：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;default int getMaxWindowLayer() {
    return 36;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Z-Order计算：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;mBaseLayer = WindowLayer * 10000 + 1000;
mSubLayer = SubWindowLayer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Window Type与Window Layer对应关系如下：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Window Type&lt;/th&gt;
      &lt;th&gt;VALUE&lt;/th&gt;
      &lt;th&gt;Window Layer&lt;/th&gt;
      &lt;th&gt;Leaf Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BASE_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;APPLICATION_LAYER = 2&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;LEAF_TYPE_TASK_CONTAINERS = 1&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_STARTING&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DRAWN_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;LAST_APPLICATION_WINDOW&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;99&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1000&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_MEDIA&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1001&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;-2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_SUB_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1002&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_ATTACHED_DIALOG&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1003&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_MEDIA_OVERLAY&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1004&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_ABOVE_SUB_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1005&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SEARCH_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PHONE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_ALERT&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2003&lt;/td&gt;
      &lt;td&gt;12|9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_KEYGUARD&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2004&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_TOAST&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2005&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2006&lt;/td&gt;
      &lt;td&gt;23|20&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRIORITY_PHONE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2007&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2008&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_KEYGUARD_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2009&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_ERROR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2010&lt;/td&gt;
      &lt;td&gt;27|9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_METHOD&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2011&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;LEAF_TYPE_IME_CONTAINERS = 2&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_METHOD_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2012&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_WALLPAPER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2013&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2014&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SECURE_SYSTEM_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2015&lt;/td&gt;
      &lt;td&gt;33&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DRAG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2016&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_SUB_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2017&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_POINTER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2018&lt;/td&gt;
      &lt;td&gt;35&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NAVIGATION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2019&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOLUME_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2020&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BOOT_PROGRESS&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2021&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_CONSUMER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2022&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NAVIGATION_BAR_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2024&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DISPLAY_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2026&lt;/td&gt;
      &lt;td&gt;29&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_MAGNIFICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2027&lt;/td&gt;
      &lt;td&gt;28&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRIVATE_PRESENTATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2030&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOICE_INTERACTION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2031&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_ACCESSIBILITY_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2032&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOICE_INTERACTION_STARTING&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2033&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DOCK_DIVIDER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2034&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_QS_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2035&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SCREENSHOT&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2036&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRESENTATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2037&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2038&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2039&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NOTIFICATION_SHADE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2040&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_ADDITIONAL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2041&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_CARWITH_NAVIGATION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2998&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;常见Window及Window Type：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Window&lt;/th&gt;
      &lt;th&gt;Window Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Activity&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BASE_APPLICATION&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TaskSnapshotWindow&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_STARTING&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dialog&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PopupWindow&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_PANEL&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Toast&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_TOAST&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;2为什么要构建displayarea树&quot;&gt;2.为什么要构建DisplayArea树？&lt;/h1&gt;

&lt;h2 id=&quot;21-需求分析&quot;&gt;2.1 需求分析&lt;/h2&gt;

&lt;p&gt;手机系统有N个类型的Window，需要划分Layer维护Window显示Z-order；&lt;/p&gt;

&lt;p&gt;有N个Feature（功能），每个Feature能够影响N个Layer层；&lt;/p&gt;

&lt;p&gt;窗口类型是可增加的，Feature是可增删的；&lt;/p&gt;

&lt;h2 id=&quot;22-方案设计&quot;&gt;2.2 方案设计&lt;/h2&gt;

&lt;p&gt;构建DisplayArea树，创建Feature节点，支持动态增删Feature，叶子节点维护Layer层级。&lt;/p&gt;

&lt;p&gt;以 DefaultTaskDisplayArea 节点为例：&lt;/p&gt;

&lt;p&gt;其父节点为 5|0|12 -&amp;gt; 3|0|14 -&amp;gt; 6|0|14 -&amp;gt; 4|0|31 -&amp;gt; DisplayContent，其含义为该节点的所有子节点均支持 FullscreenMagnification|5、OneHanded|3、HideDisplayCutout|6、WindowedMagnification|4 功能（Feature）。&lt;/p&gt;

&lt;p&gt;同时 DefaultTaskDisplayArea 节点的子节点的层级范围为 2|2，即所有子节点均为应用窗口，其Layer值是固定的。&lt;/p&gt;

&lt;h1 id=&quot;3构建displayarea树流程&quot;&gt;3.构建DisplayArea树流程&lt;/h1&gt;

&lt;h2 id=&quot;31-创建rootwindowcontainer&quot;&gt;3.1 创建RootWindowContainer&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;SystemServer.main(..)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SystemServer.run()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SystemServer.startOtherServices(..)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;vm = WindowManagerService.main(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
private WindowManagerService(..) {
    mRoot = new RootWindowContainer(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;32-创建displaycontent&quot;&gt;3.2 创建DisplayContent&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityManagerService.setWindowManager(wm)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ActivityTaskManagerService.setWindowManager(wm)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;RootWindowContainer.setWindowManager(wm)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// RootWindowContainer.java
private final ImeContainer mImeWindowsContainer = new ImeContainer(mWmService);
void setWindowManager(WindowManagerService wm) {
    ..
    final Display[] displays = mDisplayManager.getDisplays();
    for (int displayNdx = 0; displayNdx &amp;lt; displays.length; ++displayNdx) {
        final Display display = displays[displayNdx];
        final DisplayContent displayContent = new DisplayContent(display, this);
        addChild(displayContent, POSITION_BOTTOM);
        if (displayContent.mDisplayId == DEFAULT_DISPLAY) {
            mDefaultDisplay = displayContent;
        }
    }
    ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;33-创建defaulttaskdisplayarea&quot;&gt;3.3 创建DefaultTaskDisplayArea&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DisplayContent.java
DisplayContent(Display display, RootWindowContainer root) {
    ..
    final Transaction pendingTransaction = getPendingTransaction();
    configureSurfaces(pendingTransaction);
    pendingTransaction.apply();
    ..
}

private void configureSurfaces(Transaction transaction) {
    ..
    if (mDisplayAreaPolicy == null) {
        // Setup the policy and build the display area hierarchy.
        // Build the hierarchy only after creating the surface so it is reparented correctly
        mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(
                mWmService, this /* content */, this /* root */,
                mImeWindowsContainer);
    }
    ..
}

//DisplayAreaPolicy.java
static final class DefaultProvider implements DisplayAreaPolicy.Provider {
    @Override
    public DisplayAreaPolicy instantiate(WindowManagerService wmService,
            DisplayContent content, RootDisplayArea root,
            DisplayArea.Tokens imeContainer) {
        final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,
                &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);
        final List&amp;lt;TaskDisplayArea&amp;gt; tdaList = new ArrayList&amp;lt;&amp;gt;();
        tdaList.add(defaultTaskDisplayArea);

        // Define the features that will be supported under the root of the whole logical
        // display. The policy will build the DisplayArea hierarchy based on this.
        final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root);
        // Set the essential containers (even if the display doesn&apos;t support IME).
        rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);
        if (content.isTrusted()) {
            // Only trusted display can have system decorations.
            configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);
        }

        // Instantiate the policy with the hierarchy defined above. This will create and attach
        // all the necessary DisplayAreas to the root.
        return new DisplayAreaPolicyBuilder().setRootHierarchy(rootHierarchy).build(wmService);
    }
    
    private void configureTrustedHierarchyBuilder(HierarchyBuilder rootHierarchy,
            WindowManagerService wmService, DisplayContent content) {
        rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;WindowedMagnification&quot;,
                FEATURE_WINDOWED_MAGNIFICATION)
                .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                .setNewDisplayAreaSupplier(DisplayArea.Dimmable::new)
                .build());
        if (content.isDefaultDisplay) {
            rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;HideDisplayCutout&quot;,
                    FEATURE_HIDE_DISPLAY_CUTOUT)
                    .all()
                    .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL, TYPE_STATUS_BAR,
                            TYPE_NOTIFICATION_SHADE)
                    .build())
                    .addFeature(new Feature.Builder(wmService.mPolicy, &quot;OneHanded&quot;,
                            FEATURE_ONE_HANDED)
                            .all()
                            .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL,
                                    TYPE_SECURE_SYSTEM_OVERLAY)
                            .build());
        }
        rootHierarchy
                .addFeature(new Feature.Builder(wmService.mPolicy, &quot;FullscreenMagnification&quot;,
                        FEATURE_FULLSCREEN_MAGNIFICATION)
                        .all()
                        .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY, TYPE_INPUT_METHOD,
                                TYPE_INPUT_METHOD_DIALOG, TYPE_MAGNIFICATION_OVERLAY,
                                TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL)
                        .build())
                .addFeature(new Feature.Builder(wmService.mPolicy, &quot;ImePlaceholder&quot;,
                        FEATURE_IME_PLACEHOLDER)
                        .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG)
                        .build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 configureTrustedHierarchyBuilder(..) 方法中配置Feature及其能够影响到的Layer层：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Feature名&lt;/th&gt;
      &lt;th&gt;Feature ID&lt;/th&gt;
      &lt;th&gt;对应功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;WindowedMagnification&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;窗口放大镜功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HideDisplayCutout&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;隐藏刘海功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OneHanded&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;单手模式。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FullscreenMagnification&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;屏幕放大镜功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ImePlaceholder&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;特殊情况下用来放置输入法的节点。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在Feature类中使用一个长度为 getMaxWindowLayer() + 1 的boolean数组，用来标识该Feature能够影响到的Layer层：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;34-displayareapolicy构建过程&quot;&gt;3.4 DisplayAreaPolicy构建过程&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DisplayAreaPolicyBuilder.java
private void build(@Nullable List&amp;lt;HierarchyBuilder&amp;gt; displayAreaGroupHierarchyBuilders) {
    final WindowManagerPolicy policy = mRoot.mWmService.mPolicy;
    final int maxWindowLayerCount = policy.getMaxWindowLayer() + 1;
    final DisplayArea.Tokens[] displayAreaForLayer =
            new DisplayArea.Tokens[maxWindowLayerCount];
    final Map&amp;lt;Feature, List&amp;lt;DisplayArea&amp;lt;WindowContainer&amp;gt;&amp;gt;&amp;gt; featureAreas =
            new ArrayMap&amp;lt;&amp;gt;(mFeatures.size());
    for (int i = 0; i &amp;lt; mFeatures.size(); i++) {
        featureAreas.put(mFeatures.get(i), new ArrayList&amp;lt;&amp;gt;());
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;341-构建root节点&quot;&gt;3.4.1 构建root节点：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;PendingArea[] areaForLayer = new PendingArea[maxWindowLayerCount];
final PendingArea root = new PendingArea(null, 0, null);
Arrays.fill(areaForLayer, root);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;342-构建featurearea&quot;&gt;3.4.2 构建featureArea：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Create DisplayAreas to cover all defined features.
final int size = mFeatures.size();
for (int i = 0; i &amp;lt; size; i++) {
    final Feature feature = mFeatures.get(i);
    PendingArea featureArea = null;
    for (int layer = 0; layer &amp;lt; maxWindowLayerCount; layer++) {
        if (feature.mWindowLayers[layer]) {
            if (featureArea == null || featureArea.mParent != areaForLayer[layer]) {
                featureArea = new PendingArea(feature, layer, areaForLayer[layer]);
                areaForLayer[layer].mChildren.add(featureArea);
            }
            areaForLayer[layer] = featureArea;
        } else {
            featureArea = null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;黄色部分与上图是相对应的，创建的PendingArea显示格式为：Feature ID|minLayer&lt;/p&gt;

&lt;p&gt;构建出如下一棵树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/tree1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;343-构建-leafarea&quot;&gt;3.4.3 构建 leafArea：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Create Tokens as leaf for every layer.
PendingArea leafArea = null;
int leafType = LEAF_TYPE_TOKENS;
for (int layer = 0; layer &amp;lt; maxWindowLayerCount; layer++) {
    int type = typeOfLayer(policy, layer);
    if (leafArea == null || leafArea.mParent != areaForLayer[layer]
            || type != leafType) {
        leafArea = new PendingArea(null /* feature */, layer, areaForLayer[layer]);
        areaForLayer[layer].mChildren.add(leafArea);
        leafType = type;
        if (leafType == LEAF_TYPE_TASK_CONTAINERS) {
            addTaskDisplayAreasToApplicationLayer(areaForLayer[layer]);
            addDisplayAreaGroupsToApplicationLayer(areaForLayer[layer],
                    displayAreaGroupHierarchyBuilders);
            leafArea.mSkipTokens = true;
        } else if (leafType == LEAF_TYPE_IME_CONTAINERS) {
            leafArea.mExisting = mImeContainer;
            leafArea.mSkipTokens = true;
        }
    }
    leafArea.mMaxLayer = layer;
}

private static int typeOfLayer(WindowManagerPolicy policy, int layer) {
    if (layer == APPLICATION_LAYER) {
        return LEAF_TYPE_TASK_CONTAINERS; // 容纳App窗口的TaskDisplayArea
    } else if (layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD)
            || layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD_DIALOG)) {
        return LEAF_TYPE_IME_CONTAINERS; // 容纳输入法窗口的ImeContainer
    } else {
        return LEAF_TYPE_TOKENS; // 容纳其他非App类型窗口的DisplayArea.Tokens
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;黄色部分表示复用同一个leafArea，更新其mMaxLayer值，这里创建的PendingArea显示格式为：minLayer|maxLayer&lt;/p&gt;

&lt;h3 id=&quot;344-更新整棵树所有节点的maxlayer&quot;&gt;3.4.4 更新整棵树所有节点的maxLayer&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;int computeMaxLayer() {
    for (int i = 0; i &amp;lt; mChildren.size(); i++) {
        mMaxLayer = Math.max(mMaxLayer, mChildren.get(i).computeMaxLayer());
    }
    return mMaxLayer;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;345-构建整棵树&quot;&gt;3.4.5 构建整棵树&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;void instantiateChildren(DisplayArea&amp;lt;DisplayArea&amp;gt; parent, DisplayArea.Tokens[] areaForLayer,
        int level, Map&amp;lt;Feature, List&amp;lt;DisplayArea&amp;lt;WindowContainer&amp;gt;&amp;gt;&amp;gt; areas) {
    mChildren.sort(Comparator.comparingInt(pendingArea -&amp;gt; pendingArea.mMinLayer));
    for (int i = 0; i &amp;lt; mChildren.size(); i++) {
        final PendingArea child = mChildren.get(i);
        final DisplayArea area = child.createArea(parent, areaForLayer);
        if (area == null) {
            // TaskDisplayArea and ImeContainer can be set at different hierarchy, so it can
            // be null.
            continue;
        }
        parent.addChild(area, WindowContainer.POSITION_TOP);
        if (child.mFeature != null) {
            areas.get(child.mFeature).add(area);
        }
        child.instantiateChildren(area, areaForLayer, level + 1, areas);
    }
}

private DisplayArea createArea(DisplayArea&amp;lt;DisplayArea&amp;gt; parent,
        DisplayArea.Tokens[] areaForLayer) {
    if (mExisting != null) {
        // LEAF_TYPE_TASK_CONTAINERS
        // LEAF_TYPE_IME_CONTAINERS
        if (mExisting.asTokens() != null) {
            // Store the WindowToken container for layers
            fillAreaForLayers(mExisting.asTokens(), areaForLayer);
        }
        return mExisting;
    }
    if (mSkipTokens) {
        // LEAF_TYPE_TASK_CONTAINERS
        // LEAF_TYPE_IME_CONTAINERS
        return null;
    }
    DisplayArea.Type type;
    if (mMinLayer &amp;gt; APPLICATION_LAYER) {
        type = DisplayArea.Type.ABOVE_TASKS; // 位于App窗口之下的非App窗口
    } else if (mMaxLayer &amp;lt; APPLICATION_LAYER) {
        type = DisplayArea.Type.BELOW_TASKS; // 位于App窗口之上的非App窗口
    } else {
        type = DisplayArea.Type.ANY; // App窗口
    }
    if (mFeature == null) {
        final DisplayArea.Tokens leaf = new DisplayArea.Tokens(parent.mWmService, type,
                &quot;Leaf:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer);
        fillAreaForLayers(leaf, areaForLayer);
        return leaf;
    } else {
        return mFeature.mNewDisplayAreaSupplier.create(parent.mWmService, type,
                mFeature.mName + &quot;:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer, mFeature.mId);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整棵树的根节点是 DisplayContent，这里创建的DisplayArea显示格式为：Feature ID|minLayer|maxLayer；叶子节点的显示格式为：minLayer|maxLayer&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/tree2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;执行命令：adb shell dumpsys activity containers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;ACTIVITY MANAGER CONTAINERS (dumpsys activity containers)
ROOT 
  #0 Display 0 name=&quot;内置屏幕&quot;
   #2 Leaf:36:36 
    #1 WindowToken{7fb09c2 type=2024 android.os.BinderProxy@da9960d} 
     #0 e873d3 RoundCornerBottom 
    #0 WindowToken{2c592ae type=2024 android.os.BinderProxy@5ce3f29} 
     #0 164a84f RoundCornerTop 
   #1 HideDisplayCutout:32:35 
    #2 OneHanded:34:35 
     #0 FullscreenMagnification:34:35 
      #0 Leaf:34:35 
    #1 FullscreenMagnification:33:33 
     #0 Leaf:33:33 
    #0 OneHanded:32:32 
     #0 Leaf:32:32 
   #0 WindowedMagnification:0:31 
    #6 HideDisplayCutout:26:31 
     #0 OneHanded:26:31 
      #2 FullscreenMagnification:29:31 
       #0 Leaf:29:31 
      #1 Leaf:28:28 
       #1 WindowToken{6cffb72 type=2027 android.os.BinderProxy@9b9807d} 
        #0 e90cc40 GestureStubRight 
       #0 WindowToken{288fa0d type=2027 android.os.BinderProxy@3713ca4} 
        #0 1d77f10 GestureStubLeft 
      #0 FullscreenMagnification:26:27 
       #0 Leaf:26:27 
    #5 Leaf:24:25 
     #3 WindowToken{2cfd75e type=2024 android.os.BinderProxy@a18e899} 
      #0 6d1873f GestureStubHome 
     #2 WindowToken{4a05ae3 type=2024 android.os.BinderProxy@b34e312} 
      #0 28a0ce0 SecondaryHomeHandle0 
     #1 WindowToken{6986f7 type=2024 android.os.BinderProxy@f7da2f6} 
      #0 e17e964 pip-dismiss-overlay 
     #0 WindowToken{dfc6ab6 type=2019 android.os.BinderProxy@e0bfb78} 
      #0 bc113b7 NavigationBar0 
    #4 HideDisplayCutout:18:23 
     #0 OneHanded:18:23 
      #0 FullscreenMagnification:18:23 
       #0 Leaf:18:23 
        #1 WindowToken{2ecacd2 type=2017 android.os.BinderProxy@63e9b5d} 
         #0 7d9c1a3 control_center 
        #0 WindowToken{7960200 type=2017 android.os.BinderProxy@7c7083} 
         #0 b7b0a39 NotificationModalWindowManager 
    #3 OneHanded:17:17 
     #0 FullscreenMagnification:17:17 
      #0 Leaf:17:17 
       #0 WindowToken{37bf169 type=2040 android.os.BinderProxy@80f5833} 
        #0 f89f7ee NotificationShade 
    #2 HideDisplayCutout:16:16 
     #0 OneHanded:16:16 
      #0 FullscreenMagnification:16:16 
       #0 Leaf:16:16 
    #1 OneHanded:15:15 
     #0 FullscreenMagnification:15:15 
      #0 Leaf:15:15 
       #0 WindowToken{ac189b4 type=2000 android.os.BinderProxy@75516c6} 
        #0 194a9dd StatusBar 
    #0 HideDisplayCutout:0:14 
     #0 OneHanded:0:14 
      #1 ImePlaceholder:13:14 
       #0 ImeContainer 
        #0 WindowToken{720aa04 type=2011 android.os.Binder@d506617} 
         #0 f966473 InputMethod 
      #0 FullscreenMagnification:0:12 
       #2 Leaf:3:12 
        #0 WindowToken{ec3f545 type=2038 android.os.BinderProxy@fd8013a} 
         #0 329a9af ShellDropTarget 
       #1 DefaultTaskDisplayArea 
        #2 Task=18 
         #0 Task=19 
          #0 ActivityRecord{296e207 u0 com.miui.home/.launcher.Launcher} t19} 
           #0 9eb98f2 com.miui.home/com.miui.home.launcher.Launcher 
        #1 Task=4 
        #0 Task=5 
         #1 Task=7 
         #0 Task=6 
       #0 Leaf:0:1 
        #1 WallpaperWindowToken{d4d41d3 token=android.os.BinderProxy@2da4fc2} 
         #0 d44d722 com.miui.miwallpaper.wallpaperservice.MiuiKeyguardPictorialWallpaper 
        #0 WallpaperWindowToken{22dbaad token=android.os.Binder@fe41bc4} 
         #0 8db5a66 com.miui.miwallpaper.wallpaperservice.ImageWallpaper 
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到Activity是在DefaultTaskDisplayArea节点下，其他新创建的Window会根据Layer值插入到对应Leaf节点上。&lt;/p&gt;

&lt;h1 id=&quot;4参考资料&quot;&gt;4.参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7140289958085935141&quot;&gt;DisplayArea层级结构（一） —— DisplayArea层级结构的生成&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/7140289685879783432&quot;&gt;DisplayArea层级结构（二） —— 向DisplayArea层级结构添加窗口&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/7140289813516648456&quot;&gt;DisplayArea层级结构（三） —— 总结&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/shensky711/article/details/121530510&quot;&gt;WMS 层级结构 &amp;amp;&amp;amp; DisplayAreaGroup 引入&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/jieliaoyuan8279/article/details/123157937&quot;&gt;窗口层次: DisplayArea树&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/04/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/04/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>基于atrace统计应用绘制掉帧</title>
        <description>&lt;h1 id=&quot;0概述&quot;&gt;0.概述&lt;/h1&gt;

&lt;p&gt;ftrace：是一个内核函数跟踪器，function tracer，旨在帮助开发人员和系统设计者可以找到内核内部发生的事情。&lt;/p&gt;

&lt;p&gt;atrace：Android tracer，使用ftrace来跟踪Android上层的函数调用。为数据采集部分。&lt;/p&gt;

&lt;p&gt;systrace：atrace数据分析工具，将atrace采集上来的数据，以图形化的方式展现出来。&lt;/p&gt;

&lt;p&gt;抓取trace方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;开发者选项-系统跟踪，文件后缀为.perfetto-trace，二进制格式。&lt;/li&gt;
  &lt;li&gt;使用python脚本，文件后缀为.html。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Android SDK：Sdk/platform-tools/systrace.py&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://chromium.googlesource.com/catapult/&quot;&gt;Chrome catapult&lt;/a&gt;：catapult/systrace/bin/systrace&lt;/p&gt;

&lt;p&gt;命令：python2.7 systrace -a com.android.systemui am wm disk memreclaim mmc res sched freq binder_driver binder_lock dalvik pagecache database pm bionic rs gfx input view sm aidl sched freq idle&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;atrace命令&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;//开始&lt;/p&gt;

&lt;p&gt;adb shell atrace –async_start -b 10240 gfx input view wm am res sched freq dalvik idle pm hal disk memreclaim sync binder_lock binder_driver&lt;/p&gt;

&lt;p&gt;//结束&lt;/p&gt;

&lt;p&gt;adb shell atrace –async_stop &amp;gt; trace.atrace&lt;/p&gt;

&lt;h1 id=&quot;1atrace文件格式&quot;&gt;1.atrace文件格式&lt;/h1&gt;

&lt;p&gt;参考文档：https://www.kernel.org/doc/Documentation/trace/ftrace.txt&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/atrace/frame1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TASK-PID：线程名-线程ID&lt;/p&gt;

&lt;p&gt;TGID：进程ID&lt;/p&gt;

&lt;p&gt;CPU#：CPU ID，即线程运行在哪一个CPU上&lt;/p&gt;

&lt;p&gt;irqs-off：’d’ interrupts are disabled. ‘.’ otherwise.&lt;/p&gt;

&lt;p&gt;need-resched：’N’ both TIF_NEED_RESCHED and PREEMPT_NEED_RESCHED is set,&lt;/p&gt;

&lt;p&gt;​                          ‘n’ only TIF_NEED_RESCHED is set,&lt;/p&gt;

&lt;p&gt;​                          ‘p’ only PREEMPT_NEED_RESCHED is set,&lt;/p&gt;

&lt;p&gt;​                           ‘.’ otherwise.&lt;/p&gt;

&lt;p&gt;hardirq/softirq：’Z’ - NMI occurred inside a hardirq&lt;/p&gt;

&lt;p&gt;​                          ‘z’ - NMI is running&lt;/p&gt;

&lt;p&gt;​                          ‘H’ - hard irq occurred inside a softirq.&lt;/p&gt;

&lt;p&gt;​                          ‘h’ - hard irq is running&lt;/p&gt;

&lt;p&gt;​                          ‘s’ - soft irq is running&lt;/p&gt;

&lt;p&gt;​                          ‘.’ - normal context.&lt;/p&gt;

&lt;p&gt;preempt-depth：The level of preempt_disabled&lt;/p&gt;

&lt;p&gt;delay TIMESTAMP：时间戳，单位是秒.&lt;/p&gt;

&lt;p&gt;FUNCTION：函数: 信息&lt;/p&gt;

&lt;p&gt;realtime_ts：Unix时间戳&lt;/p&gt;

&lt;h1 id=&quot;2文件内容&quot;&gt;2.文件内容&lt;/h1&gt;

&lt;p&gt;Systrace抓取的trace数据，总体上可以分为两类：一类是Java和Native在用户层发生的函数调用，一类是内核态的事件信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;记录Java代码函数调用&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;Trace.traceBegin(Trace.TRACE_TAG_VIEW, “Choreographer#doFrame”);&lt;/p&gt;

&lt;p&gt;Trace.traceEnd(Trace.TRACE_TAG_VIEW);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;记录C++代码函数调用：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ATRACE_CALL();&lt;/p&gt;

&lt;p&gt;用户层的函数调用记录在文件节点：/sys/kernel/debug/tracing/trace_marker。&lt;/p&gt;

&lt;p&gt;此节点允许用户层写入字符串，ftrace会记录该写入操作时的时间戳，当用户在上层调用不同函数时，写入不同的调用信息，比如函数进入和退出分别写入，那么ftrace就可以记录跟踪函数的运行时间。&lt;/p&gt;

&lt;p&gt;内核态的事件信息，则不是统一的，需要激活各自对应的事件节点，让ftrace记录下不同事件的tracepoint。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;tracing_mark_write&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;tracing_mark_write函数的作用就是写入内容，格式定义在 system/core/libcutils/trace-dev.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C%2B%2B&quot;&gt;void atrace_begin_body(const char* name)
{
    WRITE_MSG(&quot;B|%d|&quot;, &quot;%s&quot;, name, &quot;&quot;);
}

void atrace_end_body()
{
    WRITE_MSG(&quot;E|%d&quot;, &quot;%s&quot;, &quot;&quot;, &quot;&quot;);
}

void atrace_async_begin_body(const char* name, int32_t cookie)
{
    WRITE_MSG(&quot;S|%d|&quot;, &quot;|%&quot; PRId32, name, cookie);
}

void atrace_async_end_body(const char* name, int32_t cookie)
{
    WRITE_MSG(&quot;F|%d|&quot;, &quot;|%&quot; PRId32, name, cookie);
}

void atrace_int_body(const char* name, int32_t value)
{
    WRITE_MSG(&quot;C|%d|&quot;, &quot;|%&quot; PRId32, name, value);
}

void atrace_int64_body(const char* name, int64_t value)
{
    WRITE_MSG(&quot;C|%d|&quot;, &quot;|%&quot; PRId64, name, value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中begin和end是以栈结构成对出现的，举个例子：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;… tracing_mark_write: B&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
      &lt;td&gt;name1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;… tracing_mark_write: B&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
      &lt;td&gt;name2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;… tracing_mark_write: E&lt;/td&gt;
      &lt;td&gt;1000  //匹配name2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;… tracing_mark_write: E&lt;/td&gt;
      &lt;td&gt;1000  //匹配name1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;用户侧 ATRACE_TAG_xxx 事件，定义在 frameworks/native/cmds/atrace/atrace.cpp&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;{ &quot;gfx&quot;,        &quot;Graphics&quot;,                 ATRACE_TAG_GRAPHICS, { } },
{ &quot;input&quot;,      &quot;Input&quot;,                    ATRACE_TAG_INPUT, { } },
{ &quot;view&quot;,       &quot;View System&quot;,              ATRACE_TAG_VIEW, { } },
{ &quot;webview&quot;,    &quot;WebView&quot;,                  ATRACE_TAG_WEBVIEW, { } },
{ &quot;wm&quot;,         &quot;Window Manager&quot;,           ATRACE_TAG_WINDOW_MANAGER, { } },
{ &quot;am&quot;,         &quot;Activity Manager&quot;,         ATRACE_TAG_ACTIVITY_MANAGER, { } },
{ &quot;sm&quot;,         &quot;Sync Manager&quot;,             ATRACE_TAG_SYNC_MANAGER, { } },
{ &quot;audio&quot;,      &quot;Audio&quot;,                    ATRACE_TAG_AUDIO, { } },
{ &quot;video&quot;,      &quot;Video&quot;,                    ATRACE_TAG_VIDEO, { } },
{ &quot;camera&quot;,     &quot;Camera&quot;,                   ATRACE_TAG_CAMERA, { } },
{ &quot;hal&quot;,        &quot;Hardware Modules&quot;,         ATRACE_TAG_HAL, { } },
{ &quot;res&quot;,        &quot;Resource Loading&quot;,         ATRACE_TAG_RESOURCES, { } },
{ &quot;dalvik&quot;,     &quot;Dalvik VM&quot;,                ATRACE_TAG_DALVIK, { } },
{ &quot;rs&quot;,         &quot;RenderScript&quot;,             ATRACE_TAG_RS, { } },
{ &quot;bionic&quot;,     &quot;Bionic C Library&quot;,         ATRACE_TAG_BIONIC, { } },
{ &quot;power&quot;,      &quot;Power Management&quot;,         ATRACE_TAG_POWER, { } },
{ &quot;pm&quot;,         &quot;Package Manager&quot;,          ATRACE_TAG_PACKAGE_MANAGER, { } },
{ &quot;ss&quot;,         &quot;System Server&quot;,            ATRACE_TAG_SYSTEM_SERVER, { } },
{ &quot;database&quot;,   &quot;Database&quot;,                 ATRACE_TAG_DATABASE, { } },
{ &quot;network&quot;,    &quot;Network&quot;,                  ATRACE_TAG_NETWORK, { } },
{ &quot;adb&quot;,        &quot;ADB&quot;,                      ATRACE_TAG_ADB, { } },
{ &quot;vibrator&quot;,   &quot;Vibrator&quot;,                 ATRACE_TAG_VIBRATOR, { } },
{ &quot;aidl&quot;,       &quot;AIDL calls&quot;,               ATRACE_TAG_AIDL, { } },
{ &quot;nnapi&quot;,      &quot;NNAPI&quot;,                    ATRACE_TAG_NNAPI, { } },
{ &quot;rro&quot;,        &quot;Runtime Resource Overlay&quot;, ATRACE_TAG_RRO, { } },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第1列是使用命令抓取systrace时的可选&lt;em&gt;categories。&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;内核侧 events/xxx/enable，定义在 frameworks/native/cmds/atrace/atrace.cpp&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Assembly%20language&quot;&gt;{ &quot;sched&quot;,      &quot;CPU Scheduling&quot;,   0, {
    { REQ,      &quot;events/sched/sched_switch/enable&quot; },
    { REQ,      &quot;events/sched/sched_wakeup/enable&quot; },
    { OPT,      &quot;events/sched/sched_waking/enable&quot; },
    { OPT,      &quot;events/sched/sched_blocked_reason/enable&quot; },
    { OPT,      &quot;events/sched/sched_cpu_hotplug/enable&quot; },
    { OPT,      &quot;events/sched/sched_pi_setprio/enable&quot; },
    { OPT,      &quot;events/sched/sched_process_exit/enable&quot; },
    { OPT,      &quot;events/cgroup/enable&quot; },
    { OPT,      &quot;events/oom/oom_score_adj_update/enable&quot; },
    { OPT,      &quot;events/task/task_rename/enable&quot; },
    { OPT,      &quot;events/task/task_newtask/enable&quot; },
} },
{ &quot;irq&quot;,        &quot;IRQ Events&quot;,   0, {
    { REQ,      &quot;events/irq/enable&quot; },
    { OPT,      &quot;events/ipi/enable&quot; },
} },
{ &quot;irqoff&quot;,     &quot;IRQ-disabled code section tracing&quot;, 0, {
    { REQ,      &quot;events/preemptirq/irq_enable/enable&quot; },
    { REQ,      &quot;events/preemptirq/irq_disable/enable&quot; },
} },
{ &quot;preemptoff&quot;, &quot;Preempt-disabled code section tracing&quot;, 0, {
    { REQ,      &quot;events/preemptirq/preempt_enable/enable&quot; },
    { REQ,      &quot;events/preemptirq/preempt_disable/enable&quot; },
} },
{ &quot;i2c&quot;,        &quot;I2C Events&quot;,   0, {
    { REQ,      &quot;events/i2c/enable&quot; },
    { REQ,      &quot;events/i2c/i2c_read/enable&quot; },
    { REQ,      &quot;events/i2c/i2c_write/enable&quot; },
    { REQ,      &quot;events/i2c/i2c_result/enable&quot; },
    { REQ,      &quot;events/i2c/i2c_reply/enable&quot; },
    { OPT,      &quot;events/i2c/smbus_read/enable&quot; },
    { OPT,      &quot;events/i2c/smbus_write/enable&quot; },
    { OPT,      &quot;events/i2c/smbus_result/enable&quot; },
    { OPT,      &quot;events/i2c/smbus_reply/enable&quot; },
} },
{ &quot;freq&quot;,       &quot;CPU Frequency&quot;,    0, {
    { REQ,      &quot;events/power/cpu_frequency/enable&quot; },
    { OPT,      &quot;events/power/clock_set_rate/enable&quot; },
    { OPT,      &quot;events/power/clock_disable/enable&quot; },
    { OPT,      &quot;events/power/clock_enable/enable&quot; },
    { OPT,      &quot;events/clk/clk_set_rate/enable&quot; },
    { OPT,      &quot;events/clk/clk_disable/enable&quot; },
    { OPT,      &quot;events/clk/clk_enable/enable&quot; },
    { OPT,      &quot;events/power/cpu_frequency_limits/enable&quot; },
    { OPT,      &quot;events/power/suspend_resume/enable&quot; },
} },
{ &quot;membus&quot;,     &quot;Memory Bus Utilization&quot;, 0, {
    { REQ,      &quot;events/memory_bus/enable&quot; },
} },
{ &quot;idle&quot;,       &quot;CPU Idle&quot;,         0, {
    { REQ,      &quot;events/power/cpu_idle/enable&quot; },
} },
{ &quot;disk&quot;,       &quot;Disk I/O&quot;,         0, {
    { OPT,      &quot;events/f2fs/f2fs_sync_file_enter/enable&quot; },
    { OPT,      &quot;events/f2fs/f2fs_sync_file_exit/enable&quot; },
    { OPT,      &quot;events/f2fs/f2fs_write_begin/enable&quot; },
    { OPT,      &quot;events/f2fs/f2fs_write_end/enable&quot; },
    { OPT,      &quot;events/ext4/ext4_da_write_begin/enable&quot; },
    { OPT,      &quot;events/ext4/ext4_da_write_end/enable&quot; },
    { OPT,      &quot;events/ext4/ext4_sync_file_enter/enable&quot; },
    { OPT,      &quot;events/ext4/ext4_sync_file_exit/enable&quot; },
    { REQ,      &quot;events/block/block_rq_issue/enable&quot; },
    { REQ,      &quot;events/block/block_rq_complete/enable&quot; },
} },
{ &quot;mmc&quot;,        &quot;eMMC commands&quot;,    0, {
    { REQ,      &quot;events/mmc/enable&quot; },
} },
{ &quot;load&quot;,       &quot;CPU Load&quot;,         0, {
    { REQ,      &quot;events/cpufreq_interactive/enable&quot; },
} },
{ &quot;sync&quot;,       &quot;Synchronization&quot;,  0, {
    // linux kernel &amp;lt; 4.9
    { OPT,      &quot;events/sync/enable&quot; },
    // linux kernel == 4.9.x
    { OPT,      &quot;events/fence/enable&quot; },
    // linux kernel &amp;gt; 4.9
    { OPT,      &quot;events/dma_fence/enable&quot; },
} },
{ &quot;workq&quot;,      &quot;Kernel Workqueues&quot;, 0, {
    { REQ,      &quot;events/workqueue/enable&quot; },
} },
{ &quot;memreclaim&quot;, &quot;Kernel Memory Reclaim&quot;, 0, {
    { REQ,      &quot;events/vmscan/mm_vmscan_direct_reclaim_begin/enable&quot; },
    { REQ,      &quot;events/vmscan/mm_vmscan_direct_reclaim_end/enable&quot; },
    { REQ,      &quot;events/vmscan/mm_vmscan_kswapd_wake/enable&quot; },
    { REQ,      &quot;events/vmscan/mm_vmscan_kswapd_sleep/enable&quot; },
    { OPT,      &quot;events/lowmemorykiller/enable&quot; },
} },
{ &quot;regulators&quot;,  &quot;Voltage and Current Regulators&quot;, 0, {
    { REQ,      &quot;events/regulator/enable&quot; },
} },
{ &quot;binder_driver&quot;, &quot;Binder Kernel driver&quot;, 0, {
    { REQ,      &quot;events/binder/binder_transaction/enable&quot; },
    { REQ,      &quot;events/binder/binder_transaction_received/enable&quot; },
    { REQ,      &quot;events/binder/binder_transaction_alloc_buf/enable&quot; },
    { OPT,      &quot;events/binder/binder_set_priority/enable&quot; },
} },
{ &quot;binder_lock&quot;, &quot;Binder global lock trace&quot;, 0, {
    { OPT,      &quot;events/binder/binder_lock/enable&quot; },
    { OPT,      &quot;events/binder/binder_locked/enable&quot; },
    { OPT,      &quot;events/binder/binder_unlock/enable&quot; },
} },
{ &quot;pagecache&quot;,  &quot;Page cache&quot;, 0, {
    { REQ,      &quot;events/filemap/enable&quot; },
} },
{ &quot;memory&quot;,  &quot;Memory&quot;, 0, {
    { OPT,      &quot;events/mm_event/mm_event_record/enable&quot; },
    { OPT,      &quot;events/kmem/rss_stat/enable&quot; },
    { OPT,      &quot;events/kmem/ion_heap_grow/enable&quot; },
    { OPT,      &quot;events/kmem/ion_heap_shrink/enable&quot; },
    { OPT,      &quot;events/ion/ion_stat/enable&quot; },
} },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;REQ即required的缩写，OPT即optional的缩写。&lt;/p&gt;

&lt;p&gt;与CPU调度相关：&lt;/p&gt;

&lt;p&gt;sched_wakeup / sched_waking：内核会通过try_to_wake_up把任务唤醒，这会涉及到这sched_wakeup和sched_waking两个tracepoint。&lt;/p&gt;

&lt;p&gt;sched_switch：当调度器决定schedule另一个task运行的时候，也就是任务切换的时候，会触发该tracepoint。&lt;/p&gt;

&lt;p&gt;Linux进程状态：&lt;/p&gt;

&lt;p&gt;D：Uninterruptible sleep (usually IO)&lt;/p&gt;

&lt;p&gt;R：Running or runnable (on run queue)&lt;/p&gt;

&lt;p&gt;S：Interruptible sleep (waiting for an event to complete)&lt;/p&gt;

&lt;p&gt;T：Stopped, either by a job control signal or because it is being traced.&lt;/p&gt;

&lt;p&gt;W：paging (not valid since the 2.6.xx kernel)&lt;/p&gt;

&lt;p&gt;X：dead (should never be seen)&lt;/p&gt;

&lt;p&gt;Z：Defunct (“zombie”) process, terminated but not reaped by its parent.&lt;/p&gt;

&lt;p&gt;binder通信相关：&lt;/p&gt;

&lt;p&gt;binder_transaction：client端发起请求&lt;/p&gt;

&lt;p&gt;binder_transaction_alloc_buf：分配内存&lt;/p&gt;

&lt;p&gt;binder_transaction_received：server端收到请求&lt;/p&gt;

&lt;h1 id=&quot;3应用绘制流程&quot;&gt;3.应用绘制流程&lt;/h1&gt;

&lt;p&gt;应用侧：buffer的生产者&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;线程&lt;/th&gt;
      &lt;th&gt;类#方法 - TAG&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;UIThread&lt;/td&gt;
      &lt;td&gt;Choreographer#doFrame –input   –animation –traversal —-ViewRootImpl.doTraversal ——ViewRootImpl.draw ——–ThreadedRenderer.draw - syncAndDrawFrame&lt;/td&gt;
      &lt;td&gt;构建Display List Display List的本质是一个缓冲区，它里面记录了即将要执行的绘制命令序列。这些绘制命令最终会转化为Open GL命令由GPU执行。这意味着我们在调用Canvas API绘制UI时，实际上只是将Canvas API调用及其参数记录在Display List中，然后等到下一个Vsync信号到来时，记录在Display List里面的绘制命令才会转化为Open GL命令由GPU执行。 UIThread和RenderThread都各自维护了一份应用程序窗口视图信息。各自维护了一份应用程序窗口视图信息的目的，就是为了可以互不干扰，进而实现最大程度的并行。RenderThread维护的应用程序窗口视图信息是来自于Main Thread的，当UIThread维护的应用程序窗口信息发生了变化时，就需要同步到RenderThread去。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RenderThread&lt;/td&gt;
      &lt;td&gt;DrawFrameTask::run - DrawFrame –DrawFrameTask::syncFrameState —-RenderNode::prepareTree –EglManager::beginFrame —-BufferQueueProducer::dequeueBuffer -&amp;gt; SF#dequeueBuffer –SkiaPipeline::renderFrame —-SkiaPipeline::renderLayersImpl ——drawLayer ——flush layers —-SkiaPipeline::renderFrameImpl —-flush commands –eglApi::eglSwapBuffersWithDamageKHR —-BufferQueueProducer::queueBuffer -&amp;gt; SF#onFrameAvailables&lt;/td&gt;
      &lt;td&gt;渲染Display List Android应用程序窗口的Root Render Node的Display List，包含了Android应用程序窗口所有的绘制命令，因此我们只要对Root Render Node的Display List进行渲染，就可以得到整个Android应用程序窗口的UI。     buffer被queue到buffer队列之后就会回调onFrameAvailable函数通知SurfaceFlinger进行消费&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hwuiTask0/1&lt;/td&gt;
      &lt;td&gt;DrawFrameTask::run() - DrawFrame CanvasContext::enqueueFrameWork CommonPool::async CommonPool::enqueue&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;SurfaceFlinger侧：buffer的消费者&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;消息&lt;/th&gt;
      &lt;th&gt;类#方法&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;INVALIDATE&lt;/td&gt;
      &lt;td&gt;onMessageReceived –SurfaceFlinger::onMessageInvalidate —-SurfaceFlinger::handleMessageTransaction —-SurfaceFlinger::handleMessageInvalidate ——SurfaceFlinger::handlePageFlip ——–BufferLayer::latchBuffer ———-BufferQueueConsumer::acquireBuffer —-Scheduler::chooseRefreshRateForContent —-SurfaceFlinger::performSetActiveConfig —-SurfaceFlinger::updateInputFlinger&lt;/td&gt;
      &lt;td&gt;CPU和GPU处理完之后将buffer入队BufferQueue，并调用onFrameAvailable通知SurfaceFlinger有可用buffer了； SurfaceFlinger通过内部MessageQueue调用requestNextVsync请求接收下一个VSYNC用于合成； 下一个VSYNC到了之后回调MessageQueue的handleMessage函数，实际调到SurfaceFlinger的onMessageReceived函数处理如下两种类型消息：INVALIDATE和REFRESH； 处理REFRESH消息时最终会调用acquireBuffer函数从BufferQueue中将之前APP绘制完成的buffer取出来合成。 处理REFRESH消息时最终会调用releaseBuffer函数将各layer合成后的buffer释放重新入队到BufferQueue中。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;REFRESH&lt;/td&gt;
      &lt;td&gt;onMessageReceived –SurfaceFlinger::onMessageRefresh —-CompositionEngine::present ——CompositionEngine::preComposition ——Output::prepare ——–Output::rebuildLayerStacks ——Output::present ——–Output::prepareFrame ———-Display::chooseCompositionStrategy ——–Output::finishFrame ———-Output::composeSurfaces ———-BufferQueueConsumer::acquireBuffer ——–Output::postFramebuffer ———-HWComposer::presentAndGetReleaseFences —-SurfaceFlinger::postComposition ——BufferQueueConsumer::releaseBuffer&lt;/td&gt;
      &lt;td&gt;preComposition：根据上次绘制的图层中是否有更新，来决定是否执行invalidate过程； rebuildLayerStacks：重建每个显示屏的所有可见Layer列表； setUpHWComposer：更新HWComposer的图层 doComposition：合成所有图层的图像 postComposition：回调每个layer的onPostComposition。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;4解析atrace文件统计绘制掉帧&quot;&gt;4.解析atrace文件统计绘制掉帧&lt;/h1&gt;

&lt;p&gt;以桌面左右滑动为例，如下截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/atrace/frame2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;VSYNC周期分为：VSYNC-app和VSYNC-sf&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在VSYNC-app周期内：SurfaceFlinger的app线程唤醒home主线程，接下来执行Choreographer的doFrame流程，包括input，animation，traversal阶段，在traversal中执行draw绘制并将绘制的内容同步给RenderThread线程。RenderThread线程先从buffer队列中dequeueBuffer申请一个buffer，填充内容，然后queueBuffer将buffer加入队列，并通知SurfaceFlinger。&lt;/li&gt;
  &lt;li&gt;在VSYNC-sf周期内：处理MessageQueue::INVALIDATE消息，从各Layer的BufferQueue拿到最新的缓冲数据，并根据内容更新脏区域；处理MessageQueue::REFRESH消息，通过HWC合成各Layer的buffer，发送至显示设备进行显示。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对应atrace中的日志：&lt;/p&gt;

&lt;p&gt;// EventThread线程sf-app唤醒home主线程&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;app-1786  ( 1049) [002] d..4 14425.778934: sched_wakeup: comm=com.miui.home pid=3022 prio=98 target_cpu=005

&amp;lt;idle&amp;gt;-0     (-----) [005] d..2 14425.778938: sched_switch: prev_comm=swapper/5 prev_pid=0 prev_prio=120 prev_state=R ==&amp;gt; next_comm=com.miui.home next_pid=3022 next_prio=98
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;// home主线程&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;...&amp;gt;-3022  ( 3022) [005] .... 14425.779000: tracing_mark_write: B|3022|Choreographer#doFrame

&amp;lt;...&amp;gt;-3022  ( 3022) [005] .... 14425.779010: tracing_mark_write: B|3022|animation

&amp;lt;...&amp;gt;-3022  ( 3022) [005] .... 14425.779599: tracing_mark_write: B|3022|traversal

&amp;lt;...&amp;gt;-3022  ( 3022) [005] .... 14425.779695: tracing_mark_write: B|3022|draw

&amp;lt;...&amp;gt;-3022  ( 3022) [005] .... 14425.779745: tracing_mark_write: B|3022|syncAndDrawFrame
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;// home主线程唤醒RenderThread线程&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;...&amp;gt;-3022  ( 3022) [005] d..4 14425.779767: sched_wakeup: comm=RenderThread pid=3253 prio=98 target_cpu=006
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;// RenderThread线程&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;...&amp;gt;-3253  ( 3022) [006] .... 14425.779787: tracing_mark_write: B|3022|DrawFrame

&amp;lt;...&amp;gt;-3253  ( 3022) [004] .... 14425.780064: tracing_mark_write: B|3022|syncFrameState

&amp;lt;...&amp;gt;-3253  ( 3022) [004] .... 14425.780294: tracing_mark_write: B|3022|beginFrame

&amp;lt;...&amp;gt;-3253  ( 3022) [004] .... 14425.780336: tracing_mark_write: B|3022|dequeueBuffer

&amp;lt;...&amp;gt;-3253  ( 3022) [004] .... 14425.780615: tracing_mark_write: B|3022|renderFrame

&amp;lt;...&amp;gt;-3253  ( 3022) [004] .... 14425.782260: tracing_mark_write: B|3022|eglSwapBuffersWithDamageKHR

&amp;lt;...&amp;gt;-3253  ( 3022) [004] .... 14425.782401: tracing_mark_write: B|3022|queueBuffer
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;// 更新buffer数量&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;...&amp;gt;-3253  ( 3022) [004] .... 14425.782772: tracing_mark_write: C|3022|GPU completion|1

&amp;lt;...&amp;gt;-3299  ( 1049) [001] .... 14425.782498: tracing_mark_write: C|1049|com.miui.home/com.miui.home.launcher.Launcher#0|1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;// MessageQueue::INVALIDATE&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;surfaceflinger-1049  ( 1049) [000] .... 14425.778852: tracing_mark_write: B|1049|onMessageReceived

surfaceflinger-1049  ( 1049) [000] .... 14425.778856: tracing_mark_write: B|1049|onMessageInvalidate

surfaceflinger-1049  ( 1049) [000] .... 14425.778918: tracing_mark_write: B|1049|handleMessageInvalidate
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;// MessageQueue::REFRESH&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;surfaceflinger-1049  ( 1049) [000] .... 14425.779283: tracing_mark_write: B|1049|onMessageReceived

surfaceflinger-1049  ( 1049) [000] .... 14425.779288: tracing_mark_write: B|1049|onMessageRefresh
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;// hwc&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;...&amp;gt;-1157  (  931) [004] .... 14425.779796: tracing_mark_write: B|931|HIDL::IComposerClient::executeCommands_2_2::server
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;// crtc&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;crtc_commit:128-373   (  373) [003] .... 14425.788972: tracing_mark_write: C|373|commit|1

crtc_commit:128-373   (  373) [003] .... 14425.788972: tracing_mark_write: C|373|commit|0
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;5参考文档&quot;&gt;5.参考文档&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_34211365/category_10070121.html&quot;&gt;Android图形系统&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.kancloud.cn/alex_wsc/androids/473752&quot;&gt;Android应用程序UI架构&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gityuan.com/2017/02/11/surface_flinger/&quot;&gt;SurfaceFlinger启动篇&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gityuan.com/2017/02/18/surface_flinger_2/&quot;&gt;SurfaceFlinger绘图篇&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/SSSxCCC/article/details/119250538&quot;&gt;SurfaceFlinger中Layer的合成&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.tencent.com/developer/article/1639711&quot;&gt;HWC在SurfaceFlinger中的角色&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Oct 2022 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/10/24/%E5%9F%BA%E4%BA%8Eatrace%E7%BB%9F%E8%AE%A1%E5%BA%94%E7%94%A8%E7%BB%98%E5%88%B6%E6%8E%89%E5%B8%A7/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/10/24/%E5%9F%BA%E4%BA%8Eatrace%E7%BB%9F%E8%AE%A1%E5%BA%94%E7%94%A8%E7%BB%98%E5%88%B6%E6%8E%89%E5%B8%A7/</guid>
        
        <category>Android</category>
        
        <category>atrace</category>
        
        
      </item>
    
      <item>
        <title>Android meminfo 字段详解</title>
        <description>&lt;p&gt;对于Android内存的统计拆分，需要从系统到进程，再细分到内存分类。Android的内存通常被多个进程共享，一个进程占用的内存涉及到虚拟内存、物理内存、私有、共享、图形显存等等。想要详细统计一个进程的内存占用，就需要了解Android 的内存管理机制和对内存的分类拆解。&lt;/p&gt;

&lt;h1 id=&quot;1android-内存管理&quot;&gt;1.Android 内存管理&lt;/h1&gt;

&lt;p&gt;Android内存的管理核心是&lt;strong&gt;paging&lt;/strong&gt;和&lt;strong&gt;memory-mapping（mmap）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/memory/mmap.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-paging&quot;&gt;1.1 paging&lt;/h2&gt;

&lt;p&gt;Andoid系统中使用虚拟内存地址来索引内存，虚拟内存被划分为固定大小的page页，典型的页大小为4K。内存分配最开始都是在虚拟内存上分配，当需要访问这段内存的时候，如果发现它没有存在于物理内存上（即MMU不能找到这个虚地址va对应的物理地址pa），即发生了缺页（page fault），缺页有几种可能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Bug，程序访问了它不应该访问的虚地址空间，android系统会触发访问不合法，kill掉进程。​&lt;/li&gt;
  &lt;li&gt;Va是合法的，但是这块va对应的pa还从来没有被分配出来过（例如你mmap的一段内存空间，但是从来没用过，这时第一次在这块内存上写入），这叫做lazy-allocation，这时系统会真正分配一段物理内存给你用，然后在页表上对应好这段pa和va。注意第一次写入这里才算真正占用了物理内存，mmap的分配并不算。​&lt;/li&gt;
  &lt;li&gt;Va是合法的，但是这va对应的pa内容当前并没有在物理内存上，而是被swap到一个backup的file上，这时系统会给这个page在pa上分配物理内存，然后将这块内容从文件读回到物理内存上（swap-in）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/memory/page.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;12-swap--zram&quot;&gt;1.2 swap &amp;amp; zram&lt;/h2&gt;

&lt;p&gt;典型的linux系统的虚拟内存都有swap操作，即一段物理内存在一段时间不用的时候，为了节省物理内存将他们备份到它的backup file上，一段时间后缺页时再换回。&lt;/p&gt;

&lt;p&gt;但是在android上大多数情况是没有这套swap机制的，因为对于移动端的IO代价太大，所以大多数情况被映射到pa的page是不能被swap的。只有一种情况除外，即如果这段虚拟地址段具有backup file，并且当他被swap-in到pa后是只读的，那么它是有机会被swap-out回disk的，因为swap这种内存的代价很小，他们不会在物理内存上被更改，通常这类情况包括那些代码文件的mmap（如dex、so等）。&lt;/p&gt;

&lt;p&gt;此外android上还使用了一种特殊的ZRAM机制来压缩一些物理内存上的page，但是并不把他们swap-out到disk上，而是仍然在ram中，这是一段被压缩了的page，系统会选择压缩一些page存储在内存中以腾出一些物理内存的占用。&lt;/p&gt;

&lt;h2 id=&quot;13-mmap&quot;&gt;1.3 mmap&lt;/h2&gt;

&lt;p&gt;Linux上一个重要的特性是memory mapping。如上面所述，va和pa之间通过mmu建立了一个对应关系，通过page fault来触发pa的分配，此外va还会对应一个backup file，作为swap-in/out时的备份存储。这个va和backup file之间的对应关系就叫做memory mapping，我们可以利用这个机制做文件读取。&lt;/p&gt;

&lt;p&gt;第一种是映射文件到内存做读取， 这时提供一个文件句柄，然后将文件内容映射到一段虚拟内存地址空间，这样就做到了通过访问虚拟地址空间–造成缺页—swapin backup file的方式来根据需要读取文件。他相比传统的文件读取效率更高。&lt;/p&gt;

&lt;p&gt;第二种是创建一个匿名映射，匿名映射没有backupfile，只是单纯分配一块虚拟内存空间，这其实是android上调用new一个对象做的事情，我们new一块int的数组，事实上在new后很可能是通过mmap分配了一块虚拟内存空间，而只有当第一次写入的时候才触发缺页而占用真正的物理内存，所以统计android的物理内存占用不是看new了多少，或者文件映射了多少，而是实际上虚拟内存缺页了多少。&lt;/p&gt;

&lt;h1 id=&quot;2meminfo-数据详解&quot;&gt;2.meminfo 数据详解&lt;/h1&gt;

&lt;p&gt;通过命令 dumpsys meminfo package_name|pid 查看指定进程的内存使用情况。通过输出的信息，可以看出来应用在内存哪里分配出现了问题，比如native heap分配高，就要查一下自己的native部分的代码哪里分配后没有及时释放。&lt;/p&gt;

&lt;p&gt;下面是system_server进程的meminfo。
&lt;img src=&quot;/img/memory/meminfo.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里面可以看到pss、privatedirty、privateclean、swapped diry这几个重要的指标。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;PSS&lt;/strong&gt;&lt;br /&gt;&lt;em&gt;Proportional Set Size&lt;/em&gt;&lt;/th&gt;
      &lt;th&gt;进程实际占用的物理内存大小，但是android内存涉及到在系统中同其他进程共享一部分库（可能是so，可能是字体文件等的mmap），所以这里面会考虑这个因素计算你的进程平摊的这部分共享库的大小，这里的proportional就意味着统计了这个平摊后的物理内存。这是衡量进程占用内存的最真实指标。&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;RSS&lt;/strong&gt;&lt;br /&gt;&lt;em&gt;Resident Set Size&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;常驻内存大小，是单个进程实际占用的内存大小；RSS 易被误导的原因在于， 它包括了该进程所使用的所有共享库的全部内存大小。对于单个共享库， 尽管无论多少个进程使用， 实际该共享库只会被装入内存一次。 对于单个进程的内存使用大小， RSS  不是一个精确的描述。&lt;br /&gt;Rss=Shared_Clean+Shared_Dirty+Private_Clean+Private_Dirty&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;USS&lt;/strong&gt;&lt;br /&gt;&lt;em&gt;Unique Set Size&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;进程独占的内存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;VSS&lt;/strong&gt;&lt;br /&gt;&lt;em&gt;Virtual Set Size&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;VSS= RSS+ 未分配实际物理内存&lt;br /&gt;内存的大小关系：VSS &amp;gt;= RSS &amp;gt;= PSS &amp;gt;= USS&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;swappablePss&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;能够被共享的内存。&lt;br /&gt;&lt;em&gt;sharing_proportion&lt;/em&gt; = (pss - uss) / (shared_clean + shared_dirty)&lt;br /&gt;&lt;em&gt;swapable_pss&lt;/em&gt; = (&lt;em&gt;sharing_proportion&lt;/em&gt; * shared_clean) + private_clean&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;privateDirty&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;privateClean&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;它们指的是每个进程独有的内存页面。PrivateDirty指的是进程独有的脏页面，即进程已经修改但尚未提交到磁盘的页面；PrivateClean指的是进程独有的干净页面，即进程已经提交到磁盘的页面。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;sharedDirty&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;sharedClean&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;指的是进程和别的进程共享的内存页面。sharedDirty是该过程和至少一个其他过程所引用的映射中的页面，并且由这些过程中的至少一个过程写入的页面；sharedClean是指该进程和至少一个其他进程已引用但未由任何进程修改的映射中的页面。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Swapped Dirty&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;指的并不是被swap-out出去的内存，而是android系统中zram机制压缩掉的部分Private Dirty部分的不常用物理内存，这个重要度等同于Private Dirty，因为哪些Private Dirty会被压缩不能被控制，所以这部分多通常也是Private Dirty 的。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;因为PSS中已经包含了Private Dirty和Private Clean，但是没包含swapped dity，所以最终衡量你的进程对物理内存的占用应该是取PSS+Swapped Dirty。&lt;/p&gt;

&lt;p&gt;这里统计的所有值都是物理内存大小，即缺页的那些虚拟内存的大小，而不是真正虚拟内存的大小，注意这里看到的所有内存大小都是真真实实占着你的物理内存的。比如，new 1个int[1024]，在对这块内存写入之前它都不会占用物理内存并体现在这里。&lt;/p&gt;

&lt;h2 id=&quot;21-数据来源&quot;&gt;2.1 数据来源&lt;/h2&gt;

&lt;p&gt;根据属性的不同，进程的虚拟地址空间被划分成若干个vma，每一个vma通过vm_next和vm_prev组成双向链表，链表头位于进程的task-&amp;gt;mm-&amp;gt;mmap。通过cat proc/&lt;pid&gt;/maps可以得到该进程的maps数据如下。每一行的vma对应着起始地址、结束地址、属性、偏移地址、主从设备号、inode编号和文件名。当通过proc接口读取进程的smaps文件时，内核会首先找到该进程的vma链表头，遍历链表中的每一个vma， 通过walk_page_vma统计这块vma的使用情况,最后显示出来。&lt;/pid&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/memory/vma.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;smaps&lt;/strong&gt; 文件是基于maps 的扩展，它展示了一个进程的内存消耗，比同一目录下的maps文件更为详细。如下是maps中一条vma的详细数据，全部数据可通过cat /proc/&lt;pid&gt;/smaps获取。&lt;/pid&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;7fce3a5000-7fceba4000 rw-p 00000000 00:00 0                            [stack]&lt;br /&gt;
Size:               8188 kB&lt;br /&gt;
KernelPageSize:        4 kB&lt;br /&gt;
MMUPageSize:           4 kB&lt;br /&gt;
Rss:                 156 kB&lt;br /&gt;
Pss:                 152 kB&lt;br /&gt;
Shared_Clean:          0 kB&lt;br /&gt;
Shared_Dirty:          4 kB&lt;br /&gt;
Private_Clean:         0 kB&lt;br /&gt;
Private_Dirty:       152 kB&lt;br /&gt;
Referenced:          156 kB&lt;br /&gt;
Anonymous:           156 kB&lt;br /&gt;
LazyFree:              0 kB&lt;br /&gt;
AnonHugePages:         0 kB&lt;br /&gt;
ShmemPmdMapped:        0 kB&lt;br /&gt;
FilePmdMapped:         0 kB&lt;br /&gt;
Shared_Hugetlb:        0 kB&lt;br /&gt;
Private_Hugetlb:       0 kB&lt;br /&gt;
Swap:                  0 kB&lt;br /&gt;
SwapPss:               0 kB&lt;br /&gt;
Locked:                0 kB&lt;br /&gt;
THPeligible:    0&lt;br /&gt;
VmFlags: rd wr mr mw me gd ac &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;AMS中dump meminfo功能最终也是通过JNI调用libmeminfo读取进程smaps的节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/memory/smaps.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/memory/libmeminfo.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;22-内存分类&quot;&gt;2.2 内存分类&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Native Heap&lt;/strong&gt;：C/C++层直接通过malloc分配的内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dalvik Heap/other&lt;/strong&gt;：Java堆分配的内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stack&lt;/strong&gt;：栈分配的内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ashmem&lt;/strong&gt;：进程的匿名共享内存 Anonymous Shared Memory。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GFX dev&lt;/strong&gt;：通俗来说是显存，Android 显存和内存在同样的物理设备上，所以统计的总内存是包括显存的，至于adb如何知道哪些是显存，是因为gles和egl的so库在分配显存的时候也是使用的带backup文件的mmap，adb只是简单的统计了所有gles和egl的mmap将其视为显存，这部分通常就是在gpu上的资源，gpu上的资源由很多种，占比较多的就是texture，buffer，shader programe，通常是游戏应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Other dev&lt;/strong&gt;：除显卡外所有其他硬件设备的mmap后的物理内存，可能包括声卡等，通常不多。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.so mmap&lt;/strong&gt;：这个就是so库本身文件mmap占用的物理内存，随着程序运行会逐渐的读取so文件，造成和缺页的部分就是在物理内存产生占用，这部分大就是so库太大了，但是这部分因为有很多是readonly的mmap，所以有更大的机会被swap-out出去。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.apk .dex oat .art mmap&lt;/strong&gt;：这些都是android 程序文件本身被mmap占用的内存，和so的性质差不多。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Other mmap&lt;/strong&gt;：是所有除了上面的之外其他的所有非匿名方式的mmap。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Unkonwn&lt;/strong&gt;：在meminf中它指除了部分已知的有名字的匿名映射（以anon:为前缀，例如”[anon:dalvik-“）之外的所有的匿名mmap，还有其他的未命名的vma（name字段不显示），因为无法分辨来源，就统计在unkown中。例如，看到anon:dalvik-*，那它一般是dalvik 虚拟机的分配，这个最终会被统计到meminfo的dalvik里。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;anon&lt;/strong&gt;：这个就是匿名mmap映射，除了部分已知的匿名映射如”[anon:dalvik-“, “[anon:stack_and_tls:”等，其他匿名映射所占用的内存最终会被统计到meminfo的unkown里。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;anon:libc_malloc&lt;/strong&gt; ：这个是通过malloc方法进入的mmap，即所有的new，malloc调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kgsl-3d&lt;/strong&gt;：则是gles对显存硬件的虚拟内存映射，换句话说就是显存，meminf正是统计这个标签来获取gfx的大小。&lt;/p&gt;

&lt;p&gt;更详细的拆解在&lt;a href=&quot;https://android.googlesource.com/platform/frameworks/base/+/master/core/jni/android_os_Debug.cpp&quot;&gt;android_os_Debug.cpp&lt;/a&gt;中。&lt;/p&gt;

&lt;h2 id=&quot;23-unknown&quot;&gt;2.3 Unknown&lt;/h2&gt;

&lt;p&gt;根据&lt;a href=&quot;https://android.googlesource.com/platform/frameworks/base/+/master/core/jni/android_os_Debug.cpp&quot;&gt;android_os_Debug.cpp&lt;/a&gt;中对smaps的分类，当前meminfo中对内存的统计，匿名映射除了下面这几个字段前缀的可以被统计以外，其他有名的匿名映射和没有名字的vma则被统计到Unknown字段中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“[anon:dalvik-“, “[anon:stack_and_tls:”, “[anon:libc_malloc]”,&lt;/p&gt;

  &lt;p&gt;“[anon:scudo:”, “[anon:GWP-ASan”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;24-alloc-内存&quot;&gt;2.4 Alloc 内存&lt;/h2&gt;

&lt;p&gt;在数据面板右侧可以看到对已分配和释放内存的累计记录，包括native和dalvik分配（alloc）和释放（free）内存的统计。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/memory/alloc.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;25-total&quot;&gt;2.5 Total&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/memory/total.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TOTAL是对每一列的汇总求和，其中Pss列有所不同，Pss列的TOTAL值是Pss Total和SwapPss两列之和。&lt;/p&gt;

&lt;h2 id=&quot;26-app-summary&quot;&gt;2.6 App Summary&lt;/h2&gt;

&lt;p&gt;App Summary部分是对上述细分领域的聚合，提供更直观的统计数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java Heap&lt;/strong&gt;：（Dalvik Heap 的 Private Dirty 数据) + （ .art mmap 部分的 Private Dirty 和 Private Clean 数据) + getOtherPrivate ( OTHER_ART ) 。这里的 .art 是应用的 dex 文件预编译后的 art 文件，所以也是属于该应用的 JavaHeap。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Native Heap&lt;/strong&gt;：Native Heap 的 Private Dirty 数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;：.so .jar .apk .ttf .dex .oat 等资源加总。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stack&lt;/strong&gt;：getOtherPrivateDirty ( OTHER_STACK )。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Graphics&lt;/strong&gt;：gl，gfx，egl 的数据加总。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Private Other&lt;/strong&gt;：Native Heap + Dalvik Heap - 其他的 Private Dirty + Private Clean&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;System&lt;/strong&gt;：Total Pss  -  Private Dirty - Private Clean。主要是系统占用的内存，如共享的字体、图像资源等。&lt;/p&gt;

&lt;h1 id=&quot;3graphics-memory&quot;&gt;3.Graphics memory&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;name&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;description&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;EGL mtrack&lt;/td&gt;
      &lt;td&gt;这个部分是gralloc的内存使用。主要是SurfaceView和TextureView的总和。它也包括了帧缓冲区，因此大小也会取决于framebuffers的尺寸。支持的屏幕分辨率越高，EGL mtrack的数目越高。在这个测试中，帧缓冲区的分辨率被降低了来确保比较好的性能。降低帧缓存的大小也会降低这些缓存需要的内存量。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;GL mtrack   &amp;amp; Gfx dev&lt;/td&gt;
      &lt;td&gt;GL和Gfx是驱动反馈的GPU内存，主要是GL纹理大小的总和，GL命令缓冲区，固定的全局驱动RAM消耗以及Shader。注意：客户空间驱动和内核空间驱动共享同一个内存空间。在某些Android版本上，这个部分会被重复计算两次，因此Gfx dev要比实际上使用的数值更大。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;31-gfx-dev&quot;&gt;3.1 Gfx dev&lt;/h2&gt;

&lt;p&gt;Gfx dev的值是从/sys/class/kgsl/kgsl/proc/&lt;pid&gt;/gpumem_mapped下读取的，这里主要为/dev/kgsl-3d0占用的空间，gpu使用的内存。smaps中所有kgsl-3d0内存加起来等于gpumem_mapped中读到的内存。&lt;/pid&gt;&lt;/p&gt;

&lt;h2 id=&quot;32-egl-mtrack&quot;&gt;3.2 EGL mtrack&lt;/h2&gt;

&lt;p&gt;主要是APP eglWindowSurface，包括normal HWUI based app windowsurface，SurfaceView，TextureView。这部分内存是从SurfaceFlinger 分配的，可以跟 dumpsys SurfaceFlingher 的 Alloated buffers 可以对应上。&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Oct 2022 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/10/10/Android-meminfo%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/10/10/Android-meminfo%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>Android</category>
        
        <category>Memory</category>
        
        
      </item>
    
      <item>
        <title>内存泄漏治理shark解析hprof文件</title>
        <description>&lt;p&gt;解析hprof文件主要分为如下几个步骤，逐一来介绍。&lt;/p&gt;

&lt;h1 id=&quot;1parsing_heap_dump&quot;&gt;1.PARSING_HEAP_DUMP&lt;/h1&gt;

&lt;p&gt;这一步是解析hprof文件，包含两部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解析Header部分&lt;/li&gt;
  &lt;li&gt;解析Records部分&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;hprof文件格式参考：http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html&lt;/p&gt;

&lt;p&gt;重点在读取Records部分，读取逻辑在 StreamingHprofReader 这个类，处理逻辑在&lt;/p&gt;

&lt;p&gt;HprofInMemoryIndex 这个类中，这里共读取了两遍：&lt;/p&gt;

&lt;p&gt;第1遍，收集数据信息，包括 类/实例/object数组/原始类型数组 的数量、数据最大长度等等。&lt;/p&gt;

&lt;p&gt;第2遍，生成 类/实例/object数组/原始类型数组 的信息，以支持随机读取。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;支持随机读取所需信息，以Byte数组形式存储&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;类&lt;/td&gt;
      &lt;td&gt;ID，文件中位置，父类ID，实例大小，数据长度，数组下标&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;实例&lt;/td&gt;
      &lt;td&gt;ID，文件中位置，类ID，数据长度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;object数组&lt;/td&gt;
      &lt;td&gt;ID，文件中位置，类ID，数据长度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;primitive数组&lt;/td&gt;
      &lt;td&gt;ID，文件中位置，原始类型，数据长度&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里解释下为什么要读两遍：&lt;/p&gt;

&lt;p&gt;主要是从节省内存的角度考虑，比如 文件中位置 这个数值，第一遍读取后我们可以获得文件的大小，从而可以确定存储 文件中位置 这个数值所需要的byte数量，从而避免直接使用int或long存储节省内存。&lt;/p&gt;

&lt;p&gt;这里有两个知识点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.Shark 比 Haha 占用内存小的原因？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Shark并不会直接把所有的Records都读取到内存中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.gc root对象都有哪些？&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Kotlin&quot;&gt;fun defaultIndexedGcRootTags(): EnumSet&amp;lt;HprofRecordTag&amp;gt; = EnumSet.of(
  HprofRecordTag.ROOT_JNI_GLOBAL,
  HprofRecordTag.ROOT_JAVA_FRAME,
  HprofRecordTag.ROOT_JNI_LOCAL,
  HprofRecordTag.ROOT_MONITOR_USED,
  HprofRecordTag.ROOT_NATIVE_STACK,
  HprofRecordTag.ROOT_STICKY_CLASS,
  HprofRecordTag.ROOT_THREAD_BLOCK,
  HprofRecordTag.ROOT_THREAD_OBJECT,
  HprofRecordTag.ROOT_JNI_MONITOR
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;2extracting_metadata&quot;&gt;2.EXTRACTING_METADATA&lt;/h1&gt;

&lt;p&gt;这一步是解析一些常量值，具体参考 AndroidMetadataExtractor 这个类。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Kotlin&quot;&gt;override fun extractMetadata(graph: HeapGraph): Map&amp;lt;String, String&amp;gt; {
  val metadata = mutableMapOf&amp;lt;String, String&amp;gt;()

  val build = AndroidBuildMirror.fromHeapGraph(graph)
  metadata[&quot;Build.VERSION.SDK_INT&quot;] = build.sdkInt.toString()
  metadata[&quot;Build.MANUFACTURER&quot;] = build.manufacturer
  metadata[&quot;LeakCanary version&quot;] = readLeakCanaryVersion(graph)
  metadata[&quot;App process name&quot;] = readProcessName(graph)
  metadata[&quot;Class count&quot;] = graph.classCount.toString()
  metadata[&quot;Instance count&quot;] = graph.instanceCount.toString()
  metadata[&quot;Primitive array count&quot;] = graph.primitiveArrayCount.toString()
  metadata[&quot;Object array count&quot;] = graph.objectArrayCount.toString()
  metadata[&quot;Thread count&quot;] = readThreadCount(graph).toString()
  metadata[&quot;Heap total bytes&quot;] = readHeapTotalBytes(graph).toString()
  metadata.putBitmaps(graph)
  metadata.putDbLabels(graph)

  return metadata
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3finding_retained_objects&quot;&gt;3.FINDING_RETAINED_OBJECTS&lt;/h1&gt;

&lt;p&gt;这一步是找出泄漏对象。Android中常见的泄漏对象定义在 AndroidObjectInspectors 这个类中，&lt;/p&gt;

&lt;p&gt;以 Activity 为例，当 Activity 实例中 mDestroyed == true 时，也就是 Activity 执行完 onDestroyed 回调，Activity 实例仍存在则判定为内存泄漏。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Kotlin&quot;&gt;override val leakingObjectFilter = { heapObject: HeapObject -&amp;gt;
  heapObject is HeapInstance &amp;amp;&amp;amp;
    heapObject instanceOf &quot;android.app.Activity&quot; &amp;amp;&amp;amp;
    heapObject[&quot;android.app.Activity&quot;, &quot;mDestroyed&quot;]?.value?.asBoolean == true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;4finding_paths_to_retained_objects&quot;&gt;4.FINDING_PATHS_TO_RETAINED_OBJECTS&lt;/h1&gt;

&lt;p&gt;这一步是找出泄漏最短路径。核心逻辑在 PathFinder 类，首先遍历所有的 gc roots 对象，然后依次递归遍历其所引用的子对象，直至找出包含上一步找出的所有泄漏对象。因为在遍历过程中可以创建父子关系，所以从泄漏对象一直找parent，即为最短泄漏路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Kotlin&quot;&gt;private fun State.findPathsFromGcRoots(): PathFindingResults {
  enqueueGcRoots()

  val shortestPathsToLeakingObjects = mutableListOf&amp;lt;ReferencePathNode&amp;gt;()
  visitingQueue@ while (queuesNotEmpty) {
    val node = poll()
    if (leakingObjectIds.contains(node.objectId)) {
      shortestPathsToLeakingObjects.add(node)
      // Found all refs, stop searching (unless computing retained size)
      if (shortestPathsToLeakingObjects.size == leakingObjectIds.size()) {
        if (computeRetainedHeapSize) {
          listener.onAnalysisProgress(FINDING_DOMINATORS)
        } else {
          break@visitingQueue
        }
      }
    }

    val heapObject = graph.findObjectById(node.objectId)
    objectReferenceReader.read(heapObject).forEach { reference -&amp;gt;
      val newNode = ChildNode(
        objectId = reference.valueObjectId,
        parent = node,
        lazyDetailsResolver = reference.lazyDetailsResolver
      )
      enqueue(newNode, isLowPriority = reference.isLowPriority)
    }
  }
  return PathFindingResults(
    shortestPathsToLeakingObjects,
    if (visitTracker is Dominated) visitTracker.dominatorTree else null
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里还包含了关键一步，去重最短路径，逻辑在 HeapAnalyzer.deduplicateShortestPaths() ，也就是相同泄漏路径会被合并。举个例子，比如2个不同Activity都是注册了同一listener导致的泄漏，因此泄漏路径是一致的，会被自动合并。&lt;/p&gt;

&lt;h1 id=&quot;5finding_dominators&quot;&gt;5.FINDING_DOMINATORS&lt;/h1&gt;

&lt;p&gt;如果需要计算泄漏对象导致内存泄漏大小，会在上一步的基础上遍历所有对象。&lt;/p&gt;

&lt;p&gt;备注：为了提升效率，我们去掉了这部分功能。&lt;/p&gt;

&lt;h1 id=&quot;6inspecting_objects&quot;&gt;6.INSPECTING_OBJECTS&lt;/h1&gt;

&lt;p&gt;这一步是描述对象是否有泄漏及泄漏原因，还是以 Activity 为例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Kotlin&quot;&gt;override fun inspect(
  reporter: ObjectReporter
) {
  reporter.whenInstanceOf(&quot;android.app.Activity&quot;) { instance -&amp;gt;
    // Activity.mDestroyed was introduced in 17.
    // https://android.googlesource.com/platform/frameworks/base/+
    // /6d9dcbccec126d9b87ab6587e686e28b87e5a04d
    val field = instance[&quot;android.app.Activity&quot;, &quot;mDestroyed&quot;]

    if (field != null) {
      if (field.value.asBoolean!!) {
        leakingReasons += field describedWithValue &quot;true&quot;
      } else {
        notLeakingReasons += field describedWithValue &quot;false&quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;7computing_native_retained_size&quot;&gt;7.COMPUTING_NATIVE_RETAINED_SIZE&lt;/h1&gt;

&lt;p&gt;这一步是计算 Native 内存泄漏大小，主要逻辑在 AndroidNativeSizeMapper 类。&lt;/p&gt;

&lt;h1 id=&quot;8computing_retained_size&quot;&gt;8.COMPUTING_RETAINED_SIZE&lt;/h1&gt;

&lt;p&gt;这一步是计算泄漏对象导致内存泄漏大小，主要逻辑在 DominatorTree 类。&lt;/p&gt;

&lt;h1 id=&quot;9building_leak_traces&quot;&gt;9.BUILDING_LEAK_TRACES&lt;/h1&gt;

&lt;p&gt;这一步是生成泄漏堆栈，包括：ApplicationLeak，LibraryLeak。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Kotlin&quot;&gt;private fun FindLeakInput.buildLeakTraces(
  shortestPaths: List&amp;lt;ShortestPath&amp;gt;,
  inspectedObjectsByPath: List&amp;lt;List&amp;lt;InspectedObject&amp;gt;&amp;gt;,
  retainedSizes: Map&amp;lt;Long, Pair&amp;lt;Int, Int&amp;gt;&amp;gt;?
): Pair&amp;lt;List&amp;lt;ApplicationLeak&amp;gt;, List&amp;lt;LibraryLeak&amp;gt;&amp;gt; {
  listener.onAnalysisProgress(BUILDING_LEAK_TRACES)

  val applicationLeaksMap = mutableMapOf&amp;lt;String, MutableList&amp;lt;LeakTrace&amp;gt;&amp;gt;()
  val libraryLeaksMap =
    mutableMapOf&amp;lt;String, Pair&amp;lt;LibraryLeakReferenceMatcher, MutableList&amp;lt;LeakTrace&amp;gt;&amp;gt;&amp;gt;()

  shortestPaths.forEachIndexed { pathIndex, shortestPath -&amp;gt;
    val inspectedObjects = inspectedObjectsByPath[pathIndex]

    val leakTraceObjects = buildLeakTraceObjects(inspectedObjects, retainedSizes)

    val referencePath = buildReferencePath(shortestPath, leakTraceObjects)

    val leakTrace = LeakTrace(
      gcRootType = GcRootType.fromGcRoot(shortestPath.root.gcRoot),
      referencePath = referencePath,
      leakingObject = leakTraceObjects.last()
    )

    val firstLibraryLeakMatcher = shortestPath.firstLibraryLeakMatcher()
    if (firstLibraryLeakMatcher != null) {
      val signature: String = firstLibraryLeakMatcher.pattern.toString()
        .createSHA1Hash()
      libraryLeaksMap.getOrPut(signature) { firstLibraryLeakMatcher to mutableListOf() }
        .second += leakTrace
    } else {
      applicationLeaksMap.getOrPut(leakTrace.signature) { mutableListOf() } += leakTrace
    }
  }
  val applicationLeaks = applicationLeaksMap.map { (_, leakTraces) -&amp;gt;
    ApplicationLeak(leakTraces)
  }
  val libraryLeaks = libraryLeaksMap.map { (_, pair) -&amp;gt;
    val (matcher, leakTraces) = pair
    LibraryLeak(leakTraces, matcher.pattern, matcher.description)
  }
  return applicationLeaks to libraryLeaks
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;10reporting_heap_analysis&quot;&gt;10.REPORTING_HEAP_ANALYSIS&lt;/h1&gt;

&lt;p&gt;最后一步，报告分析结果，包括：HeapAnalysisSuccess，HeapAnalysisFailure。&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Sep 2022 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/09/30/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%B2%BB%E7%90%86-shark%E8%A7%A3%E6%9E%90hprof%E6%96%87%E4%BB%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/09/30/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%B2%BB%E7%90%86-shark%E8%A7%A3%E6%9E%90hprof%E6%96%87%E4%BB%B6/</guid>
        
        <category>Android</category>
        
        <category>LeakCanary-shark</category>
        
        
      </item>
    
      <item>
        <title>内存泄漏治理-LeakCanary库解析</title>
        <description>&lt;h1 id=&quot;1认识-leakcanary&quot;&gt;1.认识 LeakCanary&lt;/h1&gt;

&lt;h2 id=&quot;11-什么是内存泄漏&quot;&gt;1.1 什么是内存泄漏&lt;/h2&gt;

&lt;p&gt;内存泄漏（Memory Leaks）指不再使用的对象或数据没有被回收，随着内存泄漏的堆积，应用性能会逐渐变差，甚至发生 OOM 奔溃。在 Android 应用中的内存泄漏可以分为 2 类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Java 内存泄露： 不再使用的对象被生命周期更长的 GC Root 引用，无法被判定为垃圾对象而导致内存泄漏（LeakCanary 只能监控 Java 内存泄漏）。&lt;/li&gt;
  &lt;li&gt;Native 内存泄露： Native 内存没有垃圾回收机制，未手动回收导致内存泄漏。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;12-为什么要使用-leakcanary&quot;&gt;1.2 为什么要使用 LeakCanary?&lt;/h2&gt;

&lt;p&gt;LeakCanray 是 Square 开源的 Java 内存泄漏分析工具，用于在实验室阶段检测 Android 应用中常见中的内存泄漏。&lt;/p&gt;

&lt;p&gt;LeakCanary 的特点或优势在于提前预判出 Android 应用中最常见且影响较大的内存泄漏场景，并对此做针对性的监测手段。 这使得 LeakCanary 相比于其他排查内存泄漏的方案（如分析 OOM 异常时的堆栈日志、MAT 分析工具）更加高效。因为当内存泄漏堆积而内存不足时，应用可能从任何一次无关紧要的内存分配中抛出 OOM，堆栈日志只能体现最后一次内存分配的堆栈信息，而无法体现出导致发生 OOM 的主要原因。&lt;/p&gt;

&lt;p&gt;目前，LeakCanary 支持以下五种 Android 场景中的内存泄漏监测：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;已销毁的 Activity 对象（进入 DESTROYED 状态）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;已销毁的 Fragment 对象和 Fragment View 对象（进入 DESTROYED 状态）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;已清除的的 ViewModel 对象（进入 CLEARED 状态）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;已销毁的的 Service 对象（进入 DESTROYED 状态）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;已从 WindowManager 中移除的 RootView 对象&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;2-leakcanary监控内存泄漏原理&quot;&gt;2. LeakCanary监控内存泄漏原理&lt;/h1&gt;

&lt;h2 id=&quot;21-activitywatcher&quot;&gt;2.1 ActivityWatcher&lt;/h2&gt;

&lt;p&gt;通过 Application.registerActivityLifecycleCallbacks(…) 接口监听 Activity.onDestroy() 事件，将当前 Activity 对象交给 ObjectWatcher 监控：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Kotlin&quot;&gt;private val lifecycleCallbacks =
  object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
    override fun onActivityDestroyed(activity: Activity) {
      reachabilityWatcher.expectWeaklyReachable(
        activity, &quot;${activity::class.java.name} received Activity#onDestroy() callback&quot;
      )
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;22-fragmentandviewmodelwatcher&quot;&gt;2.2 FragmentAndViewModelWatcher&lt;/h2&gt;

&lt;p&gt;通过 Application.registerActivityLifecycleCallbacks(…) 接口监听 Activity.onCreate() 事件，再通过 FragmentManager.registerFragmentLifecycleCallbacks(…) 接口监听 Fragment 的生命周期：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Kotlin&quot;&gt;private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {

  override fun onFragmentCreated(
    fm: FragmentManager,
    fragment: Fragment,
    savedInstanceState: Bundle?
  ) {
    ViewModelClearedWatcher.install(fragment, reachabilityWatcher)
  }

  override fun onFragmentViewDestroyed(
    fm: FragmentManager,
    fragment: Fragment
  ) {
    val view = fragment.view
    if (view != null) {
      reachabilityWatcher.expectWeaklyReachable(
        view, &quot;${fragment::class.java.name} received Fragment#onDestroyView() callback &quot; +
        &quot;(references to its views should be cleared to prevent leaks)&quot;
      )
    }
  }

  override fun onFragmentDestroyed(
    fm: FragmentManager,
    fragment: Fragment
  ) {
    reachabilityWatcher.expectWeaklyReachable(
      fragment, &quot;${fragment::class.java.name} received Fragment#onDestroy() callback&quot;
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 Android Framework 未提供设置 ViewModel.onClear() 全局监听的方法，所以 LeakCanary 是通过 Hook 的方式实现。即：在 Activity.onCreate() 和 Fragment.onCreate() 事件中实例化一个自定义ViewModel，在进入 ViewModel.onClear() 方法时，通过反射获取当前作用域中所有的 ViewModel 对象交给 ObjectWatcher 监控：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Kotlin&quot;&gt;override fun invoke(activity: Activity) {
  if (activity is FragmentActivity) {
    val supportFragmentManager = activity.supportFragmentManager
    supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
    ViewModelClearedWatcher.install(activity, reachabilityWatcher)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;23-rootviewwatcher&quot;&gt;2.3 RootViewWatcher&lt;/h2&gt;

&lt;p&gt;由于 Android Framework 未提供设置全局监听 RootView 从 WindowManager 中移除的方法，所以 LeakCanary 是通过 Hook 的方式实现的，这一块是通过 squareup 另一个开源库 curtains 实现的。&lt;/p&gt;

&lt;p&gt;RootView 监控这部分源码也比较复杂了，需要通过 2 步 Hook 来实现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Hook WMS 服务内部的 WindowManagerGlobal.mViews RootView 列表，获取 RootView 新增和移除的时机&lt;/li&gt;
  &lt;li&gt;检查 View 对应的 Window 类型，如果是 Dialog 或 DreamService 等类型，则在注册 View.addOnAttachStateChangeListener() 监听，在其中的 onViewDetachedFromWindow() 回调中将 View 对象交给 ObjectWatcher 监控&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Kotlin&quot;&gt;private val listener = OnRootViewAddedListener { rootView -&amp;gt;
  val trackDetached = when(rootView.windowType) {
    PHONE_WINDOW -&amp;gt; {
      when (rootView.phoneWindow?.callback?.wrappedCallback) {
        // Activities are already tracked by ActivityWatcher
        is Activity -&amp;gt; false
        is Dialog -&amp;gt; {
          // Use app context resources to avoid NotFoundException
          // https://github.com/square/leakcanary/issues/2137
          val resources = rootView.context.applicationContext.resources
          resources.getBoolean(R.bool.leak_canary_watcher_watch_dismissed_dialogs)
        }
        // Probably a DreamService
        else -&amp;gt; true
      }
    }
    // Android widgets keep detached popup window instances around.
    POPUP_WINDOW -&amp;gt; false
    TOOLTIP, TOAST, UNKNOWN -&amp;gt; true
  }
  if (trackDetached) {
    rootView.addOnAttachStateChangeListener(object : OnAttachStateChangeListener {

      val watchDetachedView = Runnable {
        reachabilityWatcher.expectWeaklyReachable(
          rootView, &quot;${rootView::class.java.name} received View#onDetachedFromWindow() callback&quot;
        )
      }

      override fun onViewAttachedToWindow(v: View) {
        mainHandler.removeCallbacks(watchDetachedView)
      }

      override fun onViewDetachedFromWindow(v: View) {
        mainHandler.post(watchDetachedView)
      }
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;24-servicewatcher&quot;&gt;2.4 ServiceWatcher&lt;/h2&gt;

&lt;p&gt;由于 Android Framework 未提供设置 Service#onDestroy() 全局监听的方法，所以 LeakCanary 是通过 Hook 的方式实现的。&lt;/p&gt;

&lt;p&gt;Service 监控这部分源码比较复杂了，需要通过 2 步 Hook 来实现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Hook 主线程消息循环的 mH.mCallback 回调，监听其中的 STOP_SERVICE 消息，将即将 Destroy 的 Service 对象暂存起来（由于 ActivityThread.H 中没有 DESTROY_SERVICE 消息，所以不能直接监听到 onDestroy() 事件，需要第 2 步）&lt;/li&gt;
  &lt;li&gt;使用动态代理 Hook AMS 与 App 通信的的 IActivityManager Binder 对象，代理其中的 serviceDoneExecuting() 方法，视为 Service.onDestroy() 的执行时机，拿到暂存的 Service 对象交给 ObjectWatcher 监控&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;override fun install() {
  checkMainThread()
  check(uninstallActivityThreadHandlerCallback == null) {
    &quot;ServiceWatcher already installed&quot;
  }
  check(uninstallActivityManager == null) {
    &quot;ServiceWatcher already installed&quot;
  }
  try {
    swapActivityThreadHandlerCallback { mCallback -&amp;gt;
      uninstallActivityThreadHandlerCallback = {
        swapActivityThreadHandlerCallback {
          mCallback
        }
      }
      Handler.Callback { msg -&amp;gt;
        // https://github.com/square/leakcanary/issues/2114
        // On some Motorola devices (Moto E5 and G6), the msg.obj returns an ActivityClientRecord
        // instead of an IBinder. This crashes on a ClassCastException. Adding a type check
        // here to prevent the crash.
        if (msg.obj !is IBinder) {
          return@Callback false
        }

        if (msg.what == STOP_SERVICE) {
          val key = msg.obj as IBinder
          activityThreadServices[key]?.let {
            onServicePreDestroy(key, it)
          }
        }
        mCallback?.handleMessage(msg) ?: false
      }
    }
    swapActivityManager { activityManagerInterface, activityManagerInstance -&amp;gt;
      uninstallActivityManager = {
        swapActivityManager { _, _ -&amp;gt;
          activityManagerInstance
        }
      }
      Proxy.newProxyInstance(
        activityManagerInterface.classLoader, arrayOf(activityManagerInterface)
      ) { _, method, args -&amp;gt;
        if (METHOD_SERVICE_DONE_EXECUTING == method.name) {
          val token = args!![0] as IBinder
          if (servicesToBeDestroyed.containsKey(token)) {
            onServiceDestroyed(token)
          }
        }
        try {
          if (args == null) {
            method.invoke(activityManagerInstance)
          } else {
            method.invoke(activityManagerInstance, *args)
          }
        } catch (invocationException: InvocationTargetException) {
          throw invocationException.targetException
        }
      }
    }
  } catch (ignored: Throwable) {
    SharkLog.d(ignored) { &quot;Could not watch destroyed services&quot; }
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 24 Sep 2022 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/09/24/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%B2%BB%E7%90%86-LeakCanary%E5%BA%93%E8%A7%A3%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/09/24/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%B2%BB%E7%90%86-LeakCanary%E5%BA%93%E8%A7%A3%E6%9E%90/</guid>
        
        <category>Android</category>
        
        <category>MemoryLeak</category>
        
        <category>LeakCanary</category>
        
        
      </item>
    
  </channel>
</rss>
