<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android学习笔记</title>
    <description>Android学习笔记</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 30 Aug 2023 21:54:40 +0800</pubDate>
    <lastBuildDate>Wed, 30 Aug 2023 21:54:40 +0800</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>抖音Android基础技术大揭秘</title>
        <description>&lt;h1 id=&quot;1抖音android基础技术大揭秘-vol01&quot;&gt;1.抖音Android基础技术大揭秘 Vol.01&lt;/h1&gt;

&lt;p&gt;掘金：&lt;a href=&quot;https://live.juejin.cn/4354/6654710&quot;&gt;字节跳动技术沙龙（第10期）&lt;/a&gt;&lt;br /&gt;
B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1eh4y1s7kR&quot;&gt;字节跳动技术沙龙（第10期）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin1.png&quot; alt=&quot;douyin1&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2抖音android基础技术大揭秘-vol02&quot;&gt;2.抖音Android基础技术大揭秘 Vol.02&lt;/h1&gt;

&lt;p&gt;掘金：&lt;a href=&quot;https://live.juejin.cn/4354/9932368&quot;&gt;字节跳动技术沙龙（第12期）&lt;/a&gt;&lt;br /&gt;
B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1bc411V7tE&quot;&gt;字节跳动技术沙龙（第12期）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin2.png&quot; alt=&quot;douyin2&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3抖音android基础技术大揭秘-vol03&quot;&gt;3.抖音Android基础技术大揭秘 Vol.03&lt;/h1&gt;

&lt;p&gt;掘金：&lt;a href=&quot;https://live.byteoc.com/9281/2307433&quot;&gt;抖音Android基础技术大揭秘第三期&lt;/a&gt;&lt;br /&gt;
B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1Fh4y1X71b&quot;&gt;抖音Android基础技术大揭秘第三期&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin3.png&quot; alt=&quot;douyin3&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4抖音android基础技术大揭秘-vol04&quot;&gt;4.抖音Android基础技术大揭秘 Vol.04&lt;/h1&gt;

&lt;p&gt;B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1zu4y1o74x/&quot;&gt;抖音Android基础技术大揭秘第四期&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin4.png&quot; alt=&quot;douyin4&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 29 May 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/05/29/%E6%8A%96%E9%9F%B3Android%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E5%A4%A7%E6%8F%AD%E7%A7%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/05/29/%E6%8A%96%E9%9F%B3Android%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E5%A4%A7%E6%8F%AD%E7%A7%98/</guid>
        
        <category>Android</category>
        
        <category>Performance</category>
        
        <category>Stability</category>
        
        
      </item>
    
      <item>
        <title>Android资源加载流程</title>
        <description>&lt;p&gt;官方文档：&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/topics/resources/providing-resources?hl=zh-cn&quot;&gt;应用资源概览&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/studio/command-line/aapt2?hl=zh-cn&quot;&gt;AAPT2&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;1资源文件类型&quot;&gt;1.资源文件类型&lt;/h1&gt;

&lt;p&gt;Android应用程序资源可以分为两大类，分别是assets和res：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;assets&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;assets类资源放在工程根目录的assets子目录下，它里面保存的是一些原始的文件，可以以任何方式来进行组织。这些文件最终会被原装不动地打包在apk文件中。如果我们要在程序中访问这些文件，那么就需要指定文件名来访问。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;res&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;res类资源放在工程根目录的res子目录下，它里面保存的文件大多数都会被编译，并且都会被赋予资源ID。这样我们就可以在程序中通过R类来访问res类的资源。res类资源按照不同的用途可以进一步划分为以下子类型：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;目录&lt;/th&gt;
      &lt;th&gt;资源类型&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;animator/&lt;/td&gt;
      &lt;td&gt;用于定义属性动画的 XML 文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;anim/&lt;/td&gt;
      &lt;td&gt;用于定义补间动画的 XML 文件。属性动画也可保存在此目录中，但为了区分这两种类型，属性动画首选 animator/ 目录。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;color/&lt;/td&gt;
      &lt;td&gt;定义颜色状态列表的 XML 文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;drawable/&lt;/td&gt;
      &lt;td&gt;位图文件（PNG、.9.png、JPG 或 GIF）或编译为以下可绘制资源子类型的 XML 文件：位图文件九宫图（可调整大小的位图）状态列表形状动画可绘制对象其他可绘制对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mipmap/&lt;/td&gt;
      &lt;td&gt;适用于不同启动器图标密度的可绘制对象文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;layout/&lt;/td&gt;
      &lt;td&gt;用于定义界面布局的 XML 文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;menu/&lt;/td&gt;
      &lt;td&gt;用于定义应用菜单（例如选项菜单、上下文菜单或子菜单）的 XML 文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;raw/&lt;/td&gt;
      &lt;td&gt;需以原始形式保存的任意文件。如要使用原始 InputStream 打开这些资源，请使用资源 ID（即 R.raw.filename）调用 Resources.openRawResource()。但是，如需访问原始文件名和文件层次结构，请考虑将资源保存在 assets/ 目录（而非 res/raw/）下。assets/ 中的文件没有资源 ID，因此您只能使用 AssetManager 读取这些文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;values/&lt;/td&gt;
      &lt;td&gt;包含字符串、整数和颜色等简单值的 XML 文件。其他 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;res/&lt;/code&gt; 子目录中的 XML 资源文件会根据 XML 文件名定义单个资源，而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;values/&lt;/code&gt; 目录中的文件可描述多个资源。对于此目录中的文件，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;resources&amp;gt;&lt;/code&gt; 元素的每个子元素均会定义一个资源。例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;string&amp;gt;&lt;/code&gt; 元素会创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R.string&lt;/code&gt; 资源，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;color&amp;gt;&lt;/code&gt; 元素会创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R.color&lt;/code&gt; 资源。由于每个资源均使用自己的 XML 元素进行定义，因此您可以随意命名文件，并在某个文件中放入不同的资源类型。但是，您可能需要将独特的资源类型放在不同的文件中，使其一目了然。例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：arrays.xml 用于资源数组（类型化数组）colors.xml 用于颜色值dimens.xml 用于维度值strings.xml 用于字符串值styles.xml 用于样式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;xml/&lt;/td&gt;
      &lt;td&gt;可在运行时通过调用 Resources.getXML() 读取的任意 XML 文件。各种 XML 配置文件（例如搜索配置）都必须保存在此处。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;font/&lt;/td&gt;
      &lt;td&gt;带有扩展名的字体文件（例如 TTF、OTF 或 TTC），或包含 &lt;font-family&gt; 元素的 XML 文件。&lt;/font-family&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上述资源文件，除了raw类型资源和drawable类型资源的Bitmap文件之外，其它的资源文件均为文本格式的XML文件，它们在打包的过程中，会被编译成二进制格式的XML文件。这些二进制格式的XML文件分别有一个字符串资源池，用来保存文件中引用到的每一个字符串，包括XML元素标签、属性名称、属性值，以及其它的一切文本值所使用到的字符串。这样原来在文本格式的XML文件中的每一个放置字符串的地方在二进制格式的XML文件中都被替换成一个索引到字符串资源池的整数值。这样做有两个好处：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;文件占用更小。例如，假设在原来的文本格式的XML文件中，有四个地方使用的都是同一个字符串，那么在最终编译出来的二进制格式的XML文件中，字符串资源池只有一份字符串值，而引用它的四个地方只占用一个整数值。&lt;/li&gt;
  &lt;li&gt;解析速度更快。由于在二进制格式的XML文件中，所有的XML元素标签和属性等值都是使用整数来描述的，因此，在解析的过程中，就不再需要进行字符串解析，这样就可以提高解析速度。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Android资源打包工具aapt在编译和打包资源的过程中，会执行以下两个额外的操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;赋予每一个非assets资源一个ID值，这些ID值以常量的形式定义在一个R.java文件中。&lt;/li&gt;
  &lt;li&gt;生成一个resources.arsc文件，用来描述那些具有ID值的资源的配置信息，它的内容就相当于是一个资源索引表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;resources.arsc文件格式定义在 &lt;a href=&quot;https://android.googlesource.com/platform/frameworks/base/+/56a2301/include/androidfw/ResourceTypes.h&quot;&gt;ResourceTypes.h&lt;/a&gt; ，资源ID是一个4字节的无符号整数 0xPPTTEEEE 的形式，其中 PP 是 PackageId，TT 是 TypeIndex，EEEE 是EntryIndex。Package ID中7f是应用包资源，01是系统资源。&lt;/p&gt;

&lt;h1 id=&quot;2资源管理器&quot;&gt;2.资源管理器&lt;/h1&gt;

&lt;p&gt;上文提到Android应用程序资源可以分为assets和res两大类，在代码中访问这两大类资源分别使用的AssetManager和Resources，可以通过Context获取到实例，实现类是ContextImpl：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ContextImpl.java
public AssetManager getAssets() {
    return getResources().getAssets();
}

@Override
public Resources getResources() {
    return mResources;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/ResourceLoader/resource1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;应用启动流程中，在创建Application实例前会先创建ContextImpl实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// LoadedApk.java
private Application makeApplicationInner(boolean forceDefaultAppClass,
        Instrumentation instrumentation, boolean allowDuplicateInstances) {
    ...
    try {
        final java.lang.ClassLoader cl = getClassLoader();
        ...
        // 创建ContextImpl实例
        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
        ...
        app = mActivityThread.mInstrumentation.newApplication(
                cl, appClass, appContext);
        appContext.setOuterContext(app);
    } catch (Exception e) {
        ...
    } 
    ...
    return app;
}

// ContextImpl.java
static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo) {
    return createAppContext(mainThread, packageInfo, null);
}

static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo,
        String opPackageName) {
    if (packageInfo == null) throw new IllegalArgumentException(&quot;packageInfo&quot;);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo,
        ContextParams.EMPTY, null, null, null, null, null, 0, null, opPackageName);
    context.setResources(packageInfo.getResources());
    context.mContextType = isSystemOrSystemUI(context) ? CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI
            : CONTEXT_TYPE_NON_UI;
    return context;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建完ContextImpl实例后会调用LoadedApk.getResources()方法初始化mResources成员变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// LoadedApk.java
public Resources getResources() {
    if (mResources == null) {
        final String[] splitPaths = getSplitPaths(null);
        ...
        mResources = ResourcesManager.getInstance().getResources(null, mResDir,
                splitPaths, mLegacyOverlayDirs, mOverlayPaths,
                mApplicationInfo.sharedLibraryFiles, null, null, getCompatibilityInfo(),
                getClassLoader(), null);
    }
    return mResources;
}

private void setApplicationInfo(ApplicationInfo aInfo) {
    final int myUid = Process.myUid();
    aInfo = adjustNativeLibraryPaths(aInfo);
    mApplicationInfo = aInfo;
    mAppDir = aInfo.sourceDir;
    mResDir = aInfo.uid == myUid ? aInfo.sourceDir : aInfo.publicSourceDir;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的mResDir与mAppDir都是aInfo.sourceDir，也就是/data/app/xx/xx/base.apk。&lt;/p&gt;

&lt;p&gt;继续查看创建Resources的逻辑，这里传入的activityToken为null：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesManager.java
public Resources getResources(
        @Nullable IBinder activityToken,
        @Nullable String resDir,
        @Nullable String[] splitResDirs,
        @Nullable String[] legacyOverlayDirs,
        @Nullable String[] overlayPaths,
        @Nullable String[] libDirs,
        @Nullable Integer overrideDisplayId,
        @Nullable Configuration overrideConfig,
        @NonNull CompatibilityInfo compatInfo,
        @Nullable ClassLoader classLoader,
        @Nullable List&amp;lt;ResourcesLoader&amp;gt; loaders) {
    try {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, &quot;ResourcesManager#getResources&quot;);
        final ResourcesKey key = new ResourcesKey(
                resDir,
                splitResDirs,
                combinedOverlayPaths(legacyOverlayDirs, overlayPaths),
                libDirs,
                overrideDisplayId != null ? overrideDisplayId : INVALID_DISPLAY,
                overrideConfig,
                compatInfo,
                loaders == null ? null : loaders.toArray(new ResourcesLoader[0]));
        classLoader = classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();

        final ApkAssetsSupplier assetsSupplier = createApkAssetsSupplierNotLocked(key);
        ...
        Resources resources;
        // 每个Activity会创建一个对应的Resources
        if (activityToken != null) {
            Configuration initialOverrideConfig = new Configuration(key.mOverrideConfiguration);
            rebaseKeyForActivity(activityToken, key, overrideDisplayId != null);
            resources = createResourcesForActivity(activityToken, key, initialOverrideConfig,
                    overrideDisplayId, classLoader, assetsSupplier);
        } else {
            resources = createResources(key, classLoader, assetsSupplier);
        }
        return resources;
    } finally {
    }
}

private Resources createResources(@NonNull ResourcesKey key, @NonNull ClassLoader classLoader,
        @Nullable ApkAssetsSupplier apkSupplier) {
    synchronized (mLock) {
        ResourcesImpl resourcesImpl = findOrCreateResourcesImplForKeyLocked(key, apkSupplier);
        ...
        return createResourcesLocked(classLoader, resourcesImpl, key.mCompatInfo);
    }
}

private @NonNull Resources createResourcesLocked(@NonNull ClassLoader classLoader,
        @NonNull ResourcesImpl impl, @NonNull CompatibilityInfo compatInfo) {
    cleanupReferences(mResourceReferences, mResourcesReferencesQueue);

    Resources resources = compatInfo.needsCompatResources() ? new CompatResources(classLoader)
            : new Resources(classLoader);
    resources.setImpl(impl);
    resources.setCallbacks(mUpdateCallbacks);
    mResourceReferences.add(new WeakReference&amp;lt;&amp;gt;(resources, mResourcesReferencesQueue));
    return resources;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建ResourcesImpl的实例，可以看到ResourcesImpl的实例会被弱引用缓存到mResourceImpls中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesManager.java
private @Nullable ResourcesImpl findOrCreateResourcesImplForKeyLocked(
        @NonNull ResourcesKey key, @Nullable ApkAssetsSupplier apkSupplier) {
    ResourcesImpl impl = findResourcesImplForKeyLocked(key);
    if (impl == null) {
        impl = createResourcesImpl(key, apkSupplier);
        if (impl != null) {
            mResourceImpls.put(key, new WeakReference&amp;lt;&amp;gt;(impl));
        }
    }
    return impl;
}

private @Nullable ResourcesImpl createResourcesImpl(@NonNull ResourcesKey key,
        @Nullable ApkAssetsSupplier apkSupplier) {
    final AssetManager assets = createAssetManager(key, apkSupplier);
    ...
    final ResourcesImpl impl = new ResourcesImpl(assets, displayMetrics, config, daj);
    return impl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建AssetManager的实例，关键操作是addApkAssets方法，参数是ApkAssets对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesManager.java
protected @Nullable AssetManager createAssetManager(@NonNull final ResourcesKey key) {
    return createAssetManager(key, /* apkSupplier */ null);
}

private @Nullable AssetManager createAssetManager(@NonNull final ResourcesKey key,
        @Nullable ApkAssetsSupplier apkSupplier) {
    final AssetManager.Builder builder = new AssetManager.Builder();

    final ArrayList&amp;lt;ApkKey&amp;gt; apkKeys = extractApkKeys(key);
    for (int i = 0, n = apkKeys.size(); i &amp;lt; n; i++) {
        final ApkKey apkKey = apkKeys.get(i);
        try {
            // 添加到mUserApkAssets
            builder.addApkAssets(
                    (apkSupplier != null) ? apkSupplier.load(apkKey) : loadApkAssets(apkKey));
        } catch (IOException e) {
        }
    }

    if (key.mLoaders != null) {
        for (final ResourcesLoader loader : key.mLoaders) {
            // 添加到mLoaders
            builder.addLoader(loader);
        }
    }

    return builder.build();
}

private static @NonNull ArrayList&amp;lt;ApkKey&amp;gt; extractApkKeys(@NonNull final ResourcesKey key) {
    final ArrayList&amp;lt;ApkKey&amp;gt; apkKeys = new ArrayList&amp;lt;&amp;gt;();

    if (key.mResDir != null) {
        apkKeys.add(new ApkKey(key.mResDir, false /*sharedLib*/, false /*overlay*/));
    }
    if (key.mSplitResDirs != null) { ... }
    if (key.mLibDirs != null) { ... }
    if (key.mOverlayPaths != null)  { ... }

    return apkKeys;
}

// AssetManager.java
public AssetManager build() {
    final ApkAssets[] systemApkAssets = getSystem().getApkAssets();
    ...
    final int totalApkAssetCount = systemApkAssets.length + mUserApkAssets.size()
            + loaderApkAssets.size();
    final ApkAssets[] apkAssets = new ApkAssets[totalApkAssetCount];
    // 简化为apkAssets = systemApkAssets + mUserApkAssets + mLoaders去重
    ...

    final AssetManager assetManager = new AssetManager(false /*sentinel*/);
    assetManager.mApkAssets = apkAssets;
    AssetManager.nativeSetApkAssets(assetManager.mObject, apkAssets,
            false /*invalidateCaches*/);
    assetManager.mLoaders = mLoaders.isEmpty() ? null
            : mLoaders.toArray(new ResourcesLoader[0]);

    return assetManager;
}

// 创建加载系统资源的ApkAssets
public static AssetManager getSystem() {
    synchronized (sSync) {
        createSystemAssetsInZygoteLocked(false, FRAMEWORK_APK_PATH);
        return sSystem;
    }
}

public static void createSystemAssetsInZygoteLocked(boolean reinitialize,
        String frameworkPath) {
    try {
        final ArrayList&amp;lt;ApkAssets&amp;gt; apkAssets = new ArrayList&amp;lt;&amp;gt;();
        // &quot;/system/framework/framework-res.apk&quot;
        apkAssets.add(ApkAssets.loadFromPath(frameworkPath, ApkAssets.PROPERTY_SYSTEM));

        final String[] systemIdmapPaths =
                OverlayConfig.getZygoteInstance().createImmutableFrameworkIdmapsInZygote();
        for (String idmapPath : systemIdmapPaths) {
            // Android系统资源覆盖机制
            apkAssets.add(ApkAssets.loadOverlayFromPath(idmapPath, ApkAssets.PROPERTY_SYSTEM));
        }
        sSystemApkAssetsSet = new ArraySet&amp;lt;&amp;gt;(apkAssets);
        sSystemApkAssets = apkAssets.toArray(new ApkAssets[apkAssets.size()]);
        if (sSystem == null) {
            sSystem = new AssetManager(true /*sentinel*/);
        }
        sSystem.setApkAssets(sSystemApkAssets, false /*invalidateCaches*/);
    } catch (IOException e) {
    }
}

private AssetManager(boolean sentinel) {
    mObject = nativeCreate();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Android资源覆盖机制参考官方文档：&lt;a href=&quot;https://source.android.com/docs/core/runtime/rros&quot;&gt;Change the value of an app’s resources at runtime&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接下来创建ApkAssets的实例，在构造方法中调用native方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesManager.java
ApkAssets load(final ApkKey apkKey) throws IOException {
    ApkAssets apkAssets = mLocalCache.get(apkKey);
    if (apkAssets == null) {
        apkAssets = loadApkAssets(apkKey);
        mLocalCache.put(apkKey, apkAssets);
    }
    return apkAssets;
}

private @NonNull ApkAssets loadApkAssets(@NonNull final ApkKey key) throws IOException {
    ApkAssets apkAssets;
    ...
    if (key.overlay) {
        apkAssets = ApkAssets.loadOverlayFromPath(overlayPathToIdmapPath(key.path), flags);
    } else {
        apkAssets = ApkAssets.loadFromPath(key.path, flags);
    }

    synchronized (mLock) {
        mCachedApkAssets.put(key, new WeakReference&amp;lt;&amp;gt;(apkAssets));
    }

    return apkAssets;
}

// ApkAssets.java
public static @NonNull ApkAssets loadFromPath(@NonNull String path, @PropertyFlags int flags)
        throws IOException {
    return new ApkAssets(FORMAT_APK, path, flags, null /* assets */);
}

private ApkAssets(@FormatType int format, @NonNull String path, @PropertyFlags int flags,
        @Nullable AssetsProvider assets) throws IOException {
    Objects.requireNonNull(path, &quot;path&quot;);
    mFlags = flags;
    mNativePtr = nativeLoad(format, path, flags, assets);
    mStringBlock = new StringBlock(nativeGetStringBlock(mNativePtr), true /*useSparse*/);
    mAssets = assets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kResourcesArsc是常量”resources.arsc”，加载资源文件，创建native侧ApkAssets。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// android_content_res_ApkAssets.cpp
static jlong NativeLoad(JNIEnv* env, jclass /*clazz*/, const format_type_t format,
                        jstring java_path, const jint property_flags, jobject assets_provider) {
  ScopedUtfChars path(env, java_path);

  auto loader_assets = LoaderAssetsProvider::Create(env, assets_provider);
  std::unique_ptr&amp;lt;ApkAssets&amp;gt; apk_assets;
  switch (format) {
    case FORMAT_APK: {
        auto assets = MultiAssetsProvider::Create(std::move(loader_assets),
                                                  ZipAssetsProvider::Create(path.c_str(),
                                                                            property_flags));
        apk_assets = ApkAssets::Load(std::move(assets), property_flags);
        break;
    }
    ...
  }

  return CreateGuardedApkAssets(std::move(apk_assets));
}

// Asset.cpp
std::unique_ptr&amp;lt;ApkAssets&amp;gt; ApkAssets::Load(std::unique_ptr&amp;lt;AssetsProvider&amp;gt; assets,
                                           package_property_t flags) {
  return LoadImpl(std::move(assets), flags, nullptr /* idmap_asset */, nullptr /* loaded_idmap */);
}

std::unique_ptr&amp;lt;ApkAssets&amp;gt; ApkAssets::LoadImpl(std::unique_ptr&amp;lt;AssetsProvider&amp;gt; assets,
                                               package_property_t property_flags,
                                               std::unique_ptr&amp;lt;Asset&amp;gt; idmap_asset,
                                               std::unique_ptr&amp;lt;LoadedIdmap&amp;gt; loaded_idmap) {
  // Open the resource table via mmap unless it is compressed. This logic is taken care of by Open.
  bool resources_asset_exists = false;
  auto resources_asset = assets-&amp;gt;Open(kResourcesArsc, Asset::AccessMode::ACCESS_BUFFER,
                                      &amp;amp;resources_asset_exists);
  return LoadImpl(std::move(resources_asset), std::move(assets), property_flags,
                  std::move(idmap_asset), std::move(loaded_idmap));
}

std::unique_ptr&amp;lt;ApkAssets&amp;gt; ApkAssets::LoadImpl(std::unique_ptr&amp;lt;Asset&amp;gt; resources_asset,
                                               std::unique_ptr&amp;lt;AssetsProvider&amp;gt; assets,
                                               package_property_t property_flags,
                                               std::unique_ptr&amp;lt;Asset&amp;gt; idmap_asset,
                                               std::unique_ptr&amp;lt;LoadedIdmap&amp;gt; loaded_idmap) {
  std::unique_ptr&amp;lt;LoadedArsc&amp;gt; loaded_arsc;
  if (resources_asset != nullptr) {
    const auto data = resources_asset-&amp;gt;getIncFsBuffer(true /* aligned */);
    const size_t length = resources_asset-&amp;gt;getLength();
    if (!data || length == 0) {
      return {};
    }
    loaded_arsc = LoadedArsc::Load(data, length, loaded_idmap.get(), property_flags);
  } else {
    loaded_arsc = LoadedArsc::CreateEmpty();
  }
  return std::unique_ptr&amp;lt;ApkAssets&amp;gt;(new ApkAssets(std::move(resources_asset),
                                                  std::move(loaded_arsc), std::move(assets),
                                                  property_flags, std::move(idmap_asset),
                                                  std::move(loaded_idmap)));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个过程主要是创建了AssetManager，ResourcesImpl，Resources这三个类的实例，三者之间的关系为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ResourceLoader/resource2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在ResourcesManager中会缓存创建的ResourcesImpl和Resources。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;/**
 * A mapping of ResourceImpls and their configurations. These are heavy weight objects
 * which should be reused as much as possible.
 */
@UnsupportedAppUsage
private final ArrayMap&amp;lt;ResourcesKey, WeakReference&amp;lt;ResourcesImpl&amp;gt;&amp;gt; mResourceImpls =
        new ArrayMap&amp;lt;&amp;gt;();

/**
 * A list of Resource references that can be reused.
 */
@UnsupportedAppUsage
private final ArrayList&amp;lt;WeakReference&amp;lt;Resources&amp;gt;&amp;gt; mResourceReferences = new ArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用想要动态添加资源，可以基于资源路径构造ApkAssets，调用AssetManager的setApkAssets接口添加。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// AssetManager.java
public void setApkAssets(@NonNull ApkAssets[] apkAssets, boolean invalidateCaches) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3资源文件加载&quot;&gt;3.资源文件加载&lt;/h1&gt;

&lt;p&gt;Android资源文件在打包时，非assets资源会编译到resources.arsc文件，使用Resources根据资源ID加载；非assets文件会直接打包到apk，使用AssetManager根据文件名加载。事实上，Resources加载资源也是由AssetManager实现的，接下来以加载Activity布局文件为例，介绍下资源加载流程。&lt;/p&gt;

&lt;h2 id=&quot;31-加载res资源文件&quot;&gt;3.1 加载res资源文件&lt;/h2&gt;

&lt;p&gt;LayoutInflater类主要功能是从xml实例化View视图，Resources通过资源ID加载布局xml文件，然后解析xml文件实例化View视图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// LayoutInflater.java
public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
    XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}

// 解析xml文件实例化View视图
public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;

        try {
            advanceToRootNode(parser);
            final String name = parser.getName();
            if (TAG_MERGE.equals(name)) { // &quot;merge&quot;
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        temp.setLayoutParams(params);
                    }
                }

                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);

                if (root != null &amp;amp;&amp;amp; attachToRoot) {
                    root.addView(temp, params);
                }

                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
        } catch (Exception e) {
        } finally {
        }

        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Resources通过ResourcesImpl查找对应的布局文件，如果没有找到会抛出NotFoundException：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Resources.java
public XmlResourceParser getLayout(@LayoutRes int id) throws NotFoundException {
    return loadXmlResourceParser(id, &quot;layout&quot;);
}

XmlResourceParser loadXmlResourceParser(@AnyRes int id, @NonNull String type)
        throws NotFoundException {
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValue(id, value, true);
        if (value.type == TypedValue.TYPE_STRING) {
            return loadXmlResourceParser(value.string.toString(), id,
                    value.assetCookie, type);
        }
        throw new NotFoundException(&quot;Resource ID #0x&quot; + Integer.toHexString(id)
                + &quot; type #0x&quot; + Integer.toHexString(value.type) + &quot; is not valid&quot;);
    } finally {
        releaseTempTypedValue(value);
    }
}

XmlResourceParser loadXmlResourceParser(String file, int id, int assetCookie,
                                        String type) throws NotFoundException {
    return mResourcesImpl.loadXmlResourceParser(file, id, assetCookie, type);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResourcesImpl通过AssetManager的native方法查找资源：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesImpl.java
void getValue(@AnyRes int id, TypedValue outValue, boolean resolveRefs)
        throws NotFoundException {
    boolean found = mAssets.getResourceValue(id, 0, outValue, resolveRefs);
    if (found) {
        return;
    }
    throw new NotFoundException(&quot;Resource ID #0x&quot; + Integer.toHexString(id));
}

boolean getResourceValue(@AnyRes int resId, int densityDpi, @NonNull TypedValue outValue,
        boolean resolveRefs) {
    Objects.requireNonNull(outValue, &quot;outValue&quot;);
    synchronized (this) {
        ensureValidLocked();
        final int cookie = nativeGetResourceValue(
                mObject, resId, (short) densityDpi, outValue, resolveRefs);
        if (cookie &amp;lt;= 0) {
            return false;
        }
        ...
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建AssetManager2实例，调用其GetResource方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// android_util_AssetManager.cpp
static jint NativeGetResourceValue(JNIEnv* env, jclass /*clazz*/, jlong ptr, jint resid,
                                   jshort density, jobject typed_value,
                                   jboolean resolve_references) {
  ScopedLock&amp;lt;AssetManager2&amp;gt; assetmanager(AssetManagerFromLong(ptr));
  auto value = assetmanager-&amp;gt;GetResource(static_cast&amp;lt;uint32_t&amp;gt;(resid), false /*may_be_bag*/,
                                         static_cast&amp;lt;uint16_t&amp;gt;(density));
  if (!value.has_value()) {
    return ApkAssetsCookieToJavaCookie(kInvalidCookie);
  }

  if (resolve_references) {
    auto result = assetmanager-&amp;gt;ResolveReference(value.value());
    if (!result.has_value()) {
      return ApkAssetsCookieToJavaCookie(kInvalidCookie);
    }
  }
  return CopyValue(env, *value, typed_value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AssetManager2查找资源的核心逻辑，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// AssetManager2.cpp 
base::expected&amp;lt;AssetManager2::SelectedValue, NullOrIOError&amp;gt; AssetManager2::GetResource(
      uint32_t resid, bool may_be_bag, uint16_t density_override) const {
  auto result = FindEntry(resid, density_override, false /* stop_at_first_match */,
                          false /* ignore_configuration */);
  auto result_map_entry = std::get_if&amp;lt;incfs::verified_map_ptr&amp;lt;ResTable_map_entry&amp;gt;&amp;gt;(&amp;amp;result-&amp;gt;entry);
  if (result_map_entry != nullptr) {
      if (!may_be_bag) {
        LOG(ERROR) &amp;lt;&amp;lt; base::StringPrintf(&quot;Resource %08x is a complex map type.&quot;, resid);
        return base::unexpected(std::nullopt);
      }

      // Create a reference since we can&apos;t represent this complex type as a Res_value.
      return SelectedValue(Res_value::TYPE_REFERENCE, resid, result-&amp;gt;cookie, result-&amp;gt;type_flags,
                           resid, result-&amp;gt;config);
  }

  // Convert the package ID to the runtime assigned package ID.
  Res_value value = std::get&amp;lt;Res_value&amp;gt;(result-&amp;gt;entry);
  result-&amp;gt;dynamic_ref_table-&amp;gt;lookupResourceValue(&amp;amp;value);

  return SelectedValue(value.dataType, value.data, result-&amp;gt;cookie, result-&amp;gt;type_flags,
                       resid, result-&amp;gt;config);
}

base::expected&amp;lt;FindEntryResult, NullOrIOError&amp;gt; AssetManager2::FindEntry(
    uint32_t resid, uint16_t density_override, bool stop_at_first_match,
    bool ignore_configuration) const {
  // Might use this if density_override != 0.
  ResTable_config density_override_config;

  // Select our configuration or generate a density override configuration.
  const ResTable_config* desired_config = &amp;amp;configuration_;
  if (density_override != 0 &amp;amp;&amp;amp; density_override != configuration_.density) {
    density_override_config = configuration_;
    density_override_config.density = density_override;
    desired_config = &amp;amp;density_override_config;
  }

  // 这里对应上文资源ID生成规则
  const uint32_t package_id = get_package_id(resid);
  const uint8_t type_idx = get_type_id(resid) - 1;
  const uint16_t entry_idx = get_entry_id(resid);
  uint8_t package_idx = package_ids_[package_id];
  if (UNLIKELY(package_idx == 0xff)) {
    ANDROID_LOG(ERROR) &amp;lt;&amp;lt; base::StringPrintf(&quot;No package ID %02x found for ID 0x%08x.&quot;,
                                             package_id, resid);
    return base::unexpected(std::nullopt);
  }

  // 主要用来处理Runtime Resources Overlay
  const PackageGroup&amp;amp; package_group = package_groups_[package_idx];
  auto result = FindEntryInternal(package_group, type_idx, entry_idx, *desired_config,
                                  stop_at_first_match, ignore_configuration);
  if (UNLIKELY(!result.has_value())) {
    return base::unexpected(result.error());
  }

  bool overlaid = false;
  if (!stop_at_first_match &amp;amp;&amp;amp; !ignore_configuration &amp;amp;&amp;amp; !apk_assets_[result-&amp;gt;cookie]-&amp;gt;IsLoader()) {
    // 查找资源覆盖的逻辑
  }

  return result;
}

// 核心逻辑是根据资源id，找到package_group，遍历package_group根据资源类型找到最佳匹配
base::expected&amp;lt;FindEntryResult, NullOrIOError&amp;gt; AssetManager2::FindEntryInternal(
    const PackageGroup&amp;amp; package_group, uint8_t type_idx, uint16_t entry_idx,
    const ResTable_config&amp;amp; desired_config, bool stop_at_first_match,
    bool ignore_configuration) const {
  ApkAssetsCookie best_cookie = kInvalidCookie;
  const LoadedPackage* best_package = nullptr;
  incfs::verified_map_ptr&amp;lt;ResTable_type&amp;gt; best_type;
  const ResTable_config* best_config = nullptr;
  uint32_t best_offset = 0U;
  uint32_t type_flags = 0U;

  const bool use_filtered = !ignore_configuration &amp;amp;&amp;amp; &amp;amp;desired_config == &amp;amp;configuration_;

  // RRO机制可能存在多个package
  const size_t package_count = package_group.packages_.size();
  for (size_t pi = 0; pi &amp;lt; package_count; pi++) {
    const ConfiguredPackage&amp;amp; loaded_package_impl = package_group.packages_[pi];
    const LoadedPackage* loaded_package = loaded_package_impl.loaded_package_;
    const ApkAssetsCookie cookie = package_group.cookies_[pi];

    const TypeSpec* type_spec = loaded_package-&amp;gt;GetTypeSpecByTypeIndex(type_idx);
    const bool package_is_loader = loaded_package-&amp;gt;IsCustomLoader();

    auto entry_flags = type_spec-&amp;gt;GetFlagsForEntryIndex(entry_idx);
    type_flags |= entry_flags.value();

    // 根据设备的当前配置信息，去选择最合适的资源项
    const FilteredConfigGroup&amp;amp; filtered_group = loaded_package_impl.filtered_configs_[type_idx];
    const size_t type_entry_count = (use_filtered) ? filtered_group.type_entries.size()
                                                   : type_spec-&amp;gt;type_entries.size();
    // 遍历资源类型查找最佳匹配
    for (size_t i = 0; i &amp;lt; type_entry_count; i++) {
      const TypeSpec::TypeEntry* type_entry = (use_filtered) ? filtered_group.type_entries[i]
                                                             : &amp;amp;type_spec-&amp;gt;type_entries[i];

      const ResTable_config&amp;amp; this_config = type_entry-&amp;gt;config;
      if (!(use_filtered || ignore_configuration || this_config.match(desired_config))) {
        continue;
      }
      
      // 查找最佳匹配
      Resolution::Step::Type resolution_type;
      if (best_config == nullptr) {
        resolution_type = Resolution::Step::Type::INITIAL;
      } else if (this_config.isBetterThan(*best_config, &amp;amp;desired_config)) {
        resolution_type = Resolution::Step::Type::BETTER_MATCH;
      } else if (package_is_loader &amp;amp;&amp;amp; this_config.compare(*best_config) == 0) {
        resolution_type = Resolution::Step::Type::OVERLAID;
      } else {
        continue;
      }

      const auto&amp;amp; type = type_entry-&amp;gt;type;
      const auto offset = LoadedPackage::GetEntryOffset(type, entry_idx);
      if (!offset.has_value()) {
        continue;
      }

      best_cookie = cookie;
      best_package = loaded_package;
      best_type = type;
      best_config = &amp;amp;this_config;
      best_offset = offset.value();

      if (stop_at_first_match) {
        break;
      }
    }
  }

  auto best_entry_result = LoadedPackage::GetEntryFromOffset(best_type, best_offset);
  const incfs::map_ptr&amp;lt;ResTable_entry&amp;gt; best_entry = *best_entry_result;
  const auto entry = GetEntryValue(best_entry.verified());

  return FindEntryResult{
    .cookie = best_cookie,
    .entry = *entry,
    .config = *best_config,
    .type_flags = type_flags,
    .package_name = &amp;amp;best_package-&amp;gt;GetPackageName(),
    .type_string_ref = StringPoolRef(best_package-&amp;gt;GetTypeStringPool(), best_type-&amp;gt;id - 1),
    .entry_string_ref = StringPoolRef(best_package-&amp;gt;GetKeyStringPool(),
                                      best_entry-&amp;gt;key.index),
    .dynamic_ref_table = package_group.dynamic_ref_table.get(),
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;32-加载assets资源&quot;&gt;3.2 加载assets资源&lt;/h2&gt;

&lt;p&gt;通过Context获取到AssetManager实例，调用其open方法传入文件名：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// AssetManager.java
public @NonNull InputStream open(@NonNull String fileName) throws IOException {
    return open(fileName, ACCESS_STREAMING);
}

public @NonNull InputStream open(@NonNull String fileName, int accessMode) throws IOException {
    Objects.requireNonNull(fileName, &quot;fileName&quot;);
    synchronized (this) {
        ensureOpenLocked();
        final long asset = nativeOpenAsset(mObject, fileName, accessMode);
        if (asset == 0) {
            throw new FileNotFoundException(&quot;Asset file: &quot; + fileName);
        }
        final AssetInputStream assetInputStream = new AssetInputStream(asset);
        incRefsLocked(assetInputStream.hashCode());
        return assetInputStream;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在native侧同样创建AssetManager2，调用其Open方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// android_util_AssetManager.cpp
static jlong NativeOpenAsset(JNIEnv* env, jclass /*clazz*/, jlong ptr, jstring asset_path,
                             jint access_mode) {
  ScopedUtfChars asset_path_utf8(env, asset_path);
  ...
  ScopedLock&amp;lt;AssetManager2&amp;gt; assetmanager(AssetManagerFromLong(ptr));
  std::unique_ptr&amp;lt;Asset&amp;gt; asset =
      assetmanager-&amp;gt;Open(asset_path_utf8.c_str(), static_cast&amp;lt;Asset::AccessMode&amp;gt;(access_mode));
  if (!asset) {
    jniThrowException(env, &quot;java/io/FileNotFoundException&quot;, asset_path_utf8.c_str());
    return 0;
  }
  return reinterpret_cast&amp;lt;jlong&amp;gt;(asset.release());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;apk_assets_存储的是已经加载的所有apk包，遍历apk_assets_通过AssetsProvider查找文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// AssetManager2.cpp 
std::unique_ptr&amp;lt;Asset&amp;gt; AssetManager2::Open(const std::string&amp;amp; filename,
                                           Asset::AccessMode mode) const {
  const std::string new_path = &quot;assets/&quot; + filename;
  return OpenNonAsset(new_path, mode);
}

std::unique_ptr&amp;lt;Asset&amp;gt; AssetManager2::OpenNonAsset(const std::string&amp;amp; filename,
                                                   Asset::AccessMode mode,
                                                   ApkAssetsCookie* out_cookie) const {
  for (int32_t i = apk_assets_.size() - 1; i &amp;gt;= 0; i--) {
    // 通过文件名加载文件时忽略RRO
    if (apk_assets_[i]-&amp;gt;IsOverlay()) {
      continue;
    }

    std::unique_ptr&amp;lt;Asset&amp;gt; asset = apk_assets_[i]-&amp;gt;GetAssetsProvider()-&amp;gt;Open(filename, mode);
    if (asset) {
      if (out_cookie != nullptr) {
        *out_cookie = i;
      }
      return asset;
    }
  }

  if (out_cookie != nullptr) {
    *out_cookie = kInvalidCookie;
  }
  return {};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AssetsProvider是在上文创建ApkAssets时创建的，读取文件分为文件压缩/文件未压缩两种：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// AssetsProvider.cpp
std::unique_ptr&amp;lt;Asset&amp;gt; AssetsProvider::Open(const std::string&amp;amp; path, Asset::AccessMode mode,
                                            bool* file_exists) const {
  return OpenInternal(path, mode, file_exists);
}

std::unique_ptr&amp;lt;Asset&amp;gt; ZipAssetsProvider::OpenInternal(const std::string&amp;amp; path,
                                                       Asset::AccessMode mode,
                                                       bool* file_exists) const {
    if (file_exists != nullptr) {
      *file_exists = false; // 初始化为false
    }

    ZipEntry entry;
    // zip_archive.cc 
    if (FindEntry(zip_handle_.get(), path, &amp;amp;entry) != 0) {
      return {};
    }

    if (file_exists != nullptr) {
      *file_exists = true; // 找到文件，设置为true
    }

    const int fd = GetFileDescriptor(zip_handle_.get());
    const off64_t fd_offset = GetFileDescriptorOffset(zip_handle_.get());
    const bool incremental_hardening = (flags_ &amp;amp; PROPERTY_DISABLE_INCREMENTAL_HARDENING) == 0U;
    incfs::IncFsFileMap asset_map;
    if (entry.method == kCompressDeflated) { // 是否是压缩文件
      if (!asset_map.Create(fd, entry.offset + fd_offset, entry.compressed_length,
                            name_.GetDebugName().c_str(), incremental_hardening)) {
        LOG(ERROR) &amp;lt;&amp;lt; &quot;Failed to mmap file &apos;&quot; &amp;lt;&amp;lt; path &amp;lt;&amp;lt; &quot;&apos; in APK &apos;&quot; &amp;lt;&amp;lt; name_.GetDebugName()
                   &amp;lt;&amp;lt; &quot;&apos;&quot;;
        return {};
      }

      std::unique_ptr&amp;lt;Asset&amp;gt; asset =
          Asset::createFromCompressedMap(std::move(asset_map), entry.uncompressed_length, mode);
      return asset;
    }

    if (!asset_map.Create(fd, entry.offset + fd_offset, entry.uncompressed_length,
                          name_.GetDebugName().c_str(), incremental_hardening)) {
      LOG(ERROR) &amp;lt;&amp;lt; &quot;Failed to mmap file &apos;&quot; &amp;lt;&amp;lt; path &amp;lt;&amp;lt; &quot;&apos; in APK &apos;&quot; &amp;lt;&amp;lt; name_.GetDebugName() &amp;lt;&amp;lt; &quot;&apos;&quot;;
      return {};
    }
    ...
    auto asset = Asset::createFromUncompressedMap(std::move(asset_map), mode, std::move(ufd));
    return asset;
}

std::unique_ptr&amp;lt;Asset&amp;gt; Asset::createFromUncompressedMap(incfs::IncFsFileMap&amp;amp;&amp;amp; dataMap,
                                                                   AccessMode mode,
                                                                   base::unique_fd fd)
{
    auto pAsset = util::make_unique&amp;lt;_FileAsset&amp;gt;();
    status_t result = pAsset-&amp;gt;openChunk(std::move(dataMap), std::move(fd));
    pAsset-&amp;gt;mAccessMode = mode;
    return std::move(pAsset);
}

status_t _FileAsset::openChunk(incfs::IncFsFileMap&amp;amp;&amp;amp; dataMap, base::unique_fd fd)
{
    assert(mFp == NULL);    // no reopen
    assert(!mMap.has_value());
    assert(dataMap != NULL);

    mMap = std::move(dataMap);
    mStart = -1;            // not used
    mLength = mMap-&amp;gt;length();
    mFd = std::move(fd);
    assert(mOffset == 0);

    return NO_ERROR;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;参考文档&quot;&gt;参考文档：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/8738877&quot;&gt;Android资源管理框架（Asset Manager）简要介绍和学习计划&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/8744683&quot;&gt;Android应用程序资源的编译和打包过程分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/8791064&quot;&gt;Android应用程序资源管理器（Asset Manager）的创建过程分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/8806798&quot;&gt;Android应用程序资源的查找过程分析&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 17 Apr 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/04/17/Android%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/04/17/Android%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>ResourceLoader</category>
        
        
      </item>
    
      <item>
        <title>Android类加载流程</title>
        <description>&lt;h1 id=&quot;1基本概念&quot;&gt;1.基本概念&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;1.1 类加载器的作用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;类的加载需要类加载器完成，在JVM中，一个类的唯一性是需要这个类本身和类加载器一起才能确定的，每个类加载器都有一个独立的命名空间。&lt;/p&gt;

&lt;p&gt;不同的类加载器，即使是同一个类字节码文件，最后再JVM里的类对象也不是同一个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 双亲委派模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，&lt;/p&gt;

&lt;p&gt;因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    // 交给父类加载器尝试加载
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                // 父类加载器无法加载时自身尝试加载
                c = findClass(name);

                // this is the defining class loader; record the stats
                PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。&lt;/p&gt;

&lt;p&gt;例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，&lt;/p&gt;

&lt;p&gt;因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，&lt;/p&gt;

&lt;p&gt;并放在程序的Class Path中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3 Java与Android类加载器比较&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JVM加载的是class文件，ART加载的是dex文件。&lt;/p&gt;

&lt;p&gt;Java中四种类加载器：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ClassLoader/java.png&quot; alt=&quot;java&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Android中类加载器：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ClassLoader/android.png&quot; alt=&quot;android&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2android类加载器&quot;&gt;2.Android类加载器&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;ClassLoader：&lt;/strong&gt;对Java的ClassLoader代码做了精简，其中loadClass()核心逻辑不变，仍采用双亲委派模型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BootClassLoader&lt;/strong&gt;：继承于ClassLoader，是ClassLoader的内部类。是SystemClassLoader的父加载器，同时也是Android中所有ClassLoader的最终parent。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ClassLoader.java 
private static ClassLoader createSystemClassLoader() {
    String classPath = System.getProperty(&quot;java.class.path&quot;, &quot;.&quot;);
    String librarySearchPath = System.getProperty(&quot;java.library.path&quot;, &quot;&quot;);
    return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());
}

public ClassLoader getClassLoader() {
    return (classLoader == null) ? BootClassLoader.getInstance() : classLoader;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;BaseDexClassLoader&lt;/strong&gt;：继承于ClassLoader，是PathClassLoader和DexClassLoader的父类。&lt;/p&gt;

&lt;p&gt;BaseDexClassLoader重写了ClassLoader的findClass()方法，核心在于维护了DexPathList这个类对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// BaseDexClassLoader.java 
private final DexPathList pathList;

public BaseDexClassLoader(String dexPath,
        String librarySearchPath, ClassLoader parent, ClassLoader[] sharedLibraryLoaders,
        ClassLoader[] sharedLibraryLoadersAfter,
        boolean isTrusted) {
    super(parent);
    ...
    this.pathList = new DexPathList(this, dexPath, librarySearchPath, null, isTrusted);
    ...
}
 
@Override
protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
    ...
    Class c = pathList.findClass(name, suppressedExceptions);
    if (c != null) {
        return c;
    }
    ...
    return c;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;PathClassLoader&lt;/strong&gt;：继承于BaseDexClassLoader，用来加载系统类和apk中的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DexClassLoader&lt;/strong&gt;：继承于BaseDexClassLoader，可以用来加载外置的dex文件或者apk，jar等。&lt;/p&gt;

&lt;p&gt;在Android8.1之后，optimizedDirectory参数已废弃，默认传入null。也就是说Android8.1版本及以后，PathClassLoader和DexClassLoader没有区别。&lt;/p&gt;

&lt;h1 id=&quot;3dexpathlist&quot;&gt;3.DexPathList&lt;/h1&gt;

&lt;p&gt;DexPathList核心功能是维护dexElements数组，用来记录dex文件集合。在BaseDexClassLoader构造函数中将dexPath传入，在DexPathList的splitDexPath()方法解析文件路径，在makeDexElements()方法添加到dexElements数组中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DexPathList.java
private Element[] dexElements;
 
DexPathList(ClassLoader definingContext, String dexPath,
        String librarySearchPath, File optimizedDirectory, boolean isTrusted) {
    ...
    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,
                                       suppressedExceptions, definingContext, isTrusted);
    ...
}

// 生成dexElements数组
private static Element[] makeDexElements(List&amp;lt;File&amp;gt; files, File optimizedDirectory,
        List&amp;lt;IOException&amp;gt; suppressedExceptions, ClassLoader loader, boolean isTrusted) {
  Element[] elements = new Element[files.size()];
  int elementsPos = 0;
  for (File file : files) {
      if (file.isDirectory()) {
              ...
      } else if (file.isFile()) {
          String name = file.getName();

          DexFile dex = null;
          if (name.endsWith(DEX_SUFFIX)) {
              // Raw dex file (not inside a zip/jar).
              try {
                  dex = loadDexFile(file, optimizedDirectory, loader, elements);
                  if (dex != null) {
                      elements[elementsPos++] = new Element(dex, null);
                  }
              } catch (IOException suppressed) {
                  ...
              }
          } else {
              ...
          }
          if (dex != null &amp;amp;&amp;amp; isTrusted) {
            dex.setTrusted();
          }
      } else {
          System.logW(&quot;ClassLoader referenced unknown path: &quot; + file);
      }
  }
  if (elementsPos != elements.length) {
      elements = Arrays.copyOf(elements, elementsPos);
  }
  return elements;
}

// 加载dex文件，创建DexFile对象
private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader,
                                   Element[] elements)
        throws IOException {
    if (optimizedDirectory == null) {
        return new DexFile(file, loader, elements);
    } else {
        String optimizedPath = optimizedPathFor(file, optimizedDirectory);
        return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);
    }
}

static class Element {
    private final File path;
    private final Boolean pathIsDirectory;
    private final DexFile dexFile;
 
    public Class&amp;lt;?&amp;gt; findClass(String name, ClassLoader definingContext,List&amp;lt;Throwable&amp;gt; suppressed) {
        return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed) : null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上文提到BaseDexClassLoader重写了ClassLoader的findClass()方法，其实现是直接调用DexPathList的findClass()方法，其核心逻辑是遍历所有dex文件，调用DexFile的loadClassBinaryName()方法加载类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DexPathList.java
public Class&amp;lt;?&amp;gt; findClass(String name, List&amp;lt;Throwable&amp;gt; suppressed) {
    for (Element element : dexElements) {
        Class&amp;lt;?&amp;gt; clazz = element.findClass(name, definingContext, suppressed);
        if (clazz != null) {
            return clazz;
        }
    }
    ...
    return null;
}

// DexFile.java 
public Class loadClassBinaryName(String name, ClassLoader loader, List&amp;lt;Throwable&amp;gt; suppressed) {
    return defineClass(name, loader, mCookie, this, suppressed);
}

private static Class defineClass(String name, ClassLoader loader, Object cookie,
                                 DexFile dexFile, List&amp;lt;Throwable&amp;gt; suppressed) {
    Class result = null;
    try {
        result = defineClassNative(name, loader, cookie, dexFile);
    } catch (NoClassDefFoundError e) {
        ...
    } catch (ClassNotFoundException e) {
        ...
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从DexPathList的findClass()方法我们可以看到，在尝试加载一个类的时候，会遍历所有dex文件，只要找到就会直接返回，不会再继续遍历dexElements。&lt;/p&gt;

&lt;p&gt;也就是说当两个类不同的dex中出现，会优先处理排在前面的dex文件，这便是热修复的核心精髓，将需要修复的类所打包的dex文件插入到dexElements前面。&lt;/p&gt;

&lt;h1 id=&quot;4类加载流程&quot;&gt;4.类加载流程&lt;/h1&gt;

&lt;p&gt;在启动应用创建进程后，会调用ActivityThread.main()方法，在main()方法中ActivityThread与AMS建立交互，&lt;/p&gt;

&lt;p&gt;然后AMS调用ApplicationThread.bindApplication()方法，在bindApplication()方法中发送BIND_APPLICATION消息，执行handleBindApplication()方法，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
public static void main(String[] args) {
    ...
    ActivityThread thread = new ActivityThread();
    thread.attach(false, startSeq);
    ...
}
 
private void attach(boolean system, long startSeq) {
    ...
    final IActivityManager mgr = ActivityManager.getService();
    try {
        mgr.attachApplication(mAppThread, startSeq);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
    ...
}
 
private class ApplicationThread extends IApplicationThread.Stub {
    public final void bindApplication(String processName, ApplicationInfo appInfo,
        ...
        sendMessage(H.BIND_APPLICATION, data);
    }
}
 
private void handleBindApplication(AppBindData data) {
    ...
    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo, isSdkSandbox);
    ...
    Application app = data.info.makeApplication(data.restrictedBackupMode, null);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在handleBindApplication()方法中会调用getPackageInfoNoCheck()方法，其过程中会创建LoadedApk对象，这里需要注意的是构建LoadedApk传入的baseLoader为null，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,
        CompatibilityInfo compatInfo) {
    return getPackageInfo(ai, compatInfo, null, false, true, false, isSdkSandbox);
}
 
private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,
        ClassLoader baseLoader, boolean securityViolation, boolean includeCode,
        boolean registerPackage, boolean isSdkSandbox) {
        ...
        packageInfo =
                new LoadedApk(this, aInfo, compatInfo, baseLoader,
                        securityViolation, includeCode
                        &amp;amp;&amp;amp; (aInfo.flags &amp;amp; ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);
        ...
        return packageInfo;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，LoadedApk对象已经创建，其mBaseClassLoader为null。接下来继续makeApplication()的逻辑，&lt;/p&gt;

&lt;p&gt;这里会调用getClassLoader()方法，此时mClassLoader为null，调用createOrUpdateClassLoaderLocked()方法，&lt;/p&gt;

&lt;p&gt;此时mDefaultClassLoader也为null，调用ApplicationLoaders创建DefaultClassLoader，&lt;/p&gt;

&lt;p&gt;最后初始化mClassLoader，这里mDefaultClassLoader==mClassLoader，两者是相同的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// LoadedApk.java
public Application makeApplication(boolean forceDefaultAppClass,
        Instrumentation instrumentation) {
    return makeApplicationInner(forceDefaultAppClass, instrumentation,
            /* allowDuplicateInstances= */ true);
}

private Application makeApplicationInner(boolean forceDefaultAppClass,
        Instrumentation instrumentation, boolean allowDuplicateInstances) {
    ...
    final String myProcessName = Process.myProcessName();
    String appClass = mApplicationInfo.getCustomApplicationClassNameForProcess(
            myProcessName);
    if (forceDefaultAppClass || (appClass == null)) {
        appClass = &quot;android.app.Application&quot;;
    }

    try {
        final java.lang.ClassLoader cl = getClassLoader();
        ...
        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
        ...
        app = mActivityThread.mInstrumentation.newApplication(
                cl, appClass, appContext);
        appContext.setOuterContext(app);
    } catch (Exception e) {
        ...
    } 
    ...
    return app;
}
 
public ClassLoader getClassLoader() {
    synchronized (this) {
        if (mClassLoader == null) {
            createOrUpdateClassLoaderLocked(null /*addedPaths*/);
        }
        return mClassLoader;
    }
}
 
private void createOrUpdateClassLoaderLocked(List&amp;lt;String&amp;gt; addedPaths) {
    ...
    final List&amp;lt;String&amp;gt; zipPaths = new ArrayList&amp;lt;&amp;gt;(10);
    final List&amp;lt;String&amp;gt; libPaths = new ArrayList&amp;lt;&amp;gt;(10);
    ...
    makePaths(mActivityThread, isBundledApp, mApplicationInfo, zipPaths, libPaths);
    ...
    final String zip = (zipPaths.size() == 1) ? zipPaths.get(0) :
        TextUtils.join(File.pathSeparator, zipPaths);
    if (mDefaultClassLoader == null) {
        ...
        mDefaultClassLoader = ApplicationLoaders.getDefault().getClassLoaderWithSharedLibraries(
                zip, mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath,
                libraryPermittedPath, mBaseClassLoader,
                mApplicationInfo.classLoaderName, sharedLibraries.first, nativeSharedLibraries,
                sharedLibraries.second);
        mAppComponentFactory = createAppFactory(mApplicationInfo, mDefaultClassLoader);
        ...
    }
    if (!libPaths.isEmpty()) {
        ...
        try {
            ApplicationLoaders.getDefault().addNative(mDefaultClassLoader, libPaths);
        } finally {
            ...
        }
    }
    if (addedPaths != null &amp;amp;&amp;amp; addedPaths.size() &amp;gt; 0) {
        final String add = TextUtils.join(File.pathSeparator, addedPaths);
        ApplicationLoaders.getDefault().addPath(mDefaultClassLoader, add);
        ...
    }
    ...
    if (mClassLoader == null) {
        mClassLoader = mAppComponentFactory.instantiateClassLoader(mDefaultClassLoader,
                new ApplicationInfo(mApplicationInfo));
    }
}

public static void makePaths(ActivityThread activityThread,
                             boolean isBundledApp,
                             ApplicationInfo aInfo,
                             List&amp;lt;String&amp;gt; outZipPaths,
                             List&amp;lt;String&amp;gt; outLibPaths) {
    final String appDir = aInfo.sourceDir; // Full path to the base APK for this application.
    final String libDir = aInfo.nativeLibraryDir; // Full path to the directory where native JNI libraries are stored.

    outZipPaths.clear();
    outZipPaths.add(appDir); // data/app/**/base.apk
    ...
    if (outLibPaths != null) {
        if (outLibPaths.isEmpty()) {
            outLibPaths.add(libDir); 
        }

        if (aInfo.primaryCpuAbi != null) {
            ...
            for (String apk : outZipPaths) {
                outLibPaths.add(apk + &quot;!/lib/&quot; + aInfo.primaryCpuAbi);
            }
        }
        ...
    }
    ...
    appendSharedLibrariesLibPathsIfNeeded(
            aInfo.sharedLibraryInfos, aInfo, outSeenPaths, outLibPaths);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来看ApplicationLoaders里的逻辑，在getClassLoaderWithSharedLibraries()方法中会调用getClassLoader()方法，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ApplicationLoaders.java
ClassLoader getClassLoaderWithSharedLibraries(
        String zip, int targetSdkVersion, boolean isBundled,
        String librarySearchPath, String libraryPermittedPath,
        ClassLoader parent, String classLoaderName,
        List&amp;lt;ClassLoader&amp;gt; sharedLibraries, List&amp;lt;String&amp;gt; nativeSharedLibraries,
        List&amp;lt;ClassLoader&amp;gt; sharedLibrariesLoadedAfterApp) {
    // For normal usage the cache key used is the same as the zip path.
    return getClassLoader(zip, targetSdkVersion, isBundled, librarySearchPath,
                          libraryPermittedPath, parent, zip, classLoaderName, sharedLibraries,
                          nativeSharedLibraries, sharedLibrariesLoadedAfterApp);
}

// 这里传入的parent==null
private ClassLoader getClassLoader(String zip, int targetSdkVersion, boolean isBundled,
                                  String librarySearchPath, String libraryPermittedPath,
                                  ClassLoader parent, String cacheKey,
                                  String classLoaderName, List&amp;lt;ClassLoader&amp;gt; sharedLibraries,
                                  List&amp;lt;String&amp;gt; nativeSharedLibraries,
                                  List&amp;lt;ClassLoader&amp;gt; sharedLibrariesLoadedAfterApp) {
    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent(); // java.lang.BootClassLoader

    synchronized (mLoaders) {
        if (parent == null) {
            parent = baseParent;
        }

        if (parent == baseParent) {
            ...
            ClassLoader classloader = ClassLoaderFactory.createClassLoader(
                    zip,  librarySearchPath, libraryPermittedPath, parent,
                    targetSdkVersion, isBundled, classLoaderName, sharedLibraries,
                    nativeSharedLibraries, sharedLibrariesLoadedAfterApp);
            ...
            return classloader;
        }

        ClassLoader loader = ClassLoaderFactory.createClassLoader(
                zip, null, parent, classLoaderName, sharedLibraries,
                null /*sharedLibrariesLoadedAfterApp*/);

        return loader;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着看ClassLoaderFactory的逻辑，这里classloaderName为null，因此创建的是PathClassLoader。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ClassLoaderFactory.java
public static ClassLoader createClassLoader(String dexPath,
       String librarySearchPath, ClassLoader parent, String classloaderName,
       List&amp;lt;ClassLoader&amp;gt; sharedLibraries, List&amp;lt;ClassLoader&amp;gt; sharedLibrariesLoadedAfter) {
   ...
   if (isPathClassLoaderName(classloaderName)) {
       return new PathClassLoader(dexPath, librarySearchPath, parent, arrayOfSharedLibraries,
               arrayOfSharedLibrariesLoadedAfterApp);
   } else if (isDelegateLastClassLoaderName(classloaderName)) {
       return new DelegateLastClassLoader(dexPath, librarySearchPath, parent,
               arrayOfSharedLibraries, arrayOfSharedLibrariesLoadedAfterApp);
   }

    throw new AssertionError(&quot;Invalid classLoaderName: &quot; + classloaderName);
}
 
public static boolean isPathClassLoaderName(String name) {
    return name == null || PATH_CLASS_LOADER_NAME.equals(name) ||
            DEX_CLASS_LOADER_NAME.equals(name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回到LoadedApk.makeApplication()的逻辑，接下来会创建Application，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Instrumentation.java 
public Application newApplication(ClassLoader cl, String className, Context context)
        throws InstantiationException, IllegalAccessException,
        ClassNotFoundException {
    Application app = getFactory(context.getPackageName())
            .instantiateApplication(cl, className);
    app.attach(context);
    return app;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的className默认是android.app.Application，cl是之前创建的PathClassLoader。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// AppComponentFactory.java
public @NonNull Application instantiateApplication(@NonNull ClassLoader cl,
        @NonNull String className)
        throws InstantiationException, IllegalAccessException, ClassNotFoundException {
    return (Application) cl.loadClass(className).newInstance();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是应用PathClassLoader的创建流程以及应用代码是如何被加载的。需要注意的是基于双亲委派模型，最终加载android.app.Application类的classloader是BootClassLoader。&lt;/p&gt;

&lt;h1 id=&quot;5delegatelastclassloader&quot;&gt;5.DelegateLastClassLoader&lt;/h1&gt;

&lt;p&gt;在上文分析创建PathClassLoader代码中，还有一种类加载器DelegateLastClassLoader，继承于PathClassLoader，其加载class核心逻辑如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;@Override
protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // First, check whether the class has already been loaded. Return it if that&apos;s the
    // case.
    Class&amp;lt;?&amp;gt; cl = findLoadedClass(name);
    if (cl != null) {
        return cl;
    }
 
    // Next, check whether the class in question is present in the boot classpath.
    try {
        return Object.class.getClassLoader().loadClass(name);
    } catch (ClassNotFoundException ignored) {
    }
 
    // Next, check whether the class in question is present in the dexPath that this classloader
    // operates on, or its shared libraries.
    ClassNotFoundException fromSuper = null;
    try {
        return findClass(name);
    } catch (ClassNotFoundException ex) {
        fromSuper = ex;
    }
 
    // Finally, check whether the class in question is present in the parent classloader.
    try {
        return getParent().loadClass(name);
    } catch (ClassNotFoundException cnfe) {
        // The exception we&apos;re catching here is the CNFE thrown by the parent of this
        // classloader. However, we would like to throw a CNFE that provides details about
        // the class path / list of dex files associated with *this* classloader, so we choose
        // to throw the exception thrown from that lookup.
        throw fromSuper;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，判断该类是否已经被加载，如果已加载直接返回。&lt;/p&gt;

&lt;p&gt;然后，尝试由BootClassLoader加载。&lt;/p&gt;

&lt;p&gt;接着，尝试由DelegateLastClassLoader自身加载。&lt;/p&gt;

&lt;p&gt;最后，尝试由DelegateLastClassLoader的父加载器加载。&lt;/p&gt;

&lt;p&gt;可以看到DelegateLastClassLoader打破了双亲委派模型，先尝试自身加载，在交由parent加载。&lt;/p&gt;

&lt;h1 id=&quot;6replugin&quot;&gt;6.RePlugin&lt;/h1&gt;

&lt;p&gt;项目地址：https://github.com/Qihoo360/RePlugin&lt;/p&gt;

&lt;p&gt;其核心是在应用Application创建的时候，通过hook替换掉应用Context中的mPackageInfo中的mClassLoader，在自定义的DexClassLoader中优先加载插件类。&lt;/p&gt;

&lt;p&gt;RePluginClassLoader：用于替换Context中的mPackageInfo中的mClassLoader。&lt;/p&gt;

&lt;p&gt;PluginDexClassLoader：处理类加载逻辑，优先加载插件类。&lt;/p&gt;

&lt;p&gt;PatchClassLoaderUtils：通过hook实现替换Context中的mPackageInfo中的mClassLoader的功能。&lt;/p&gt;

&lt;h1 id=&quot;参考文档&quot;&gt;参考文档：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1517603&quot;&gt;彻底搞懂JVM类加载器：基本概念&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.tencent.com/developer/article/1520709&quot;&gt;类加载器中的双亲委派模型详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gityuan.com/2017/03/19/android-classloader/&quot;&gt;Android类加载器ClassLoader&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 24 Mar 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/03/24/Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/03/24/Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>ClassLoader</category>
        
        
      </item>
    
      <item>
        <title>Activity显示流程</title>
        <description>&lt;p&gt;在 &lt;a href=&quot;https://dreamsunny.github.io/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/&quot;&gt;Activity启动流程&lt;/a&gt; 中，我们知道了系统侧响应 Activity 启动请求会创建 Task ；&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&quot;https://dreamsunny.github.io/2022/12/24/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/&quot;&gt;DisplayArea树层级结构&lt;/a&gt;中，我们了解了 Task 最终会添加到 DefaultTaskDisplayArea ；&lt;/p&gt;

&lt;p&gt;本文主要梳理下Activity显示流程。&lt;/p&gt;

&lt;h1 id=&quot;1task添加到defaulttaskdisplayarea&quot;&gt;1.Task添加到DefaultTaskDisplayArea&lt;/h1&gt;

&lt;p&gt;调用堆栈如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/trace1.png&quot; alt=&quot;trace1&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// TaskDisplayArea.java
Task getOrCreateRootTask(..) {
    ...
    return new Task.Builder(mAtmService)
            ...
            .setParent(this)
            ...
            .build();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 setParent(this) 传入的是 TaskDisplayArea 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Task.java
Task build() {
    ...
    final Task task = buildInner();
    ...
    if (mParent != null) {
        if (mParent instanceof Task) {
            final Task parentTask = (Task) mParent;
            parentTask.addChild(task, mOnTop ? POSITION_TOP : POSITION_BOTTOM,
                    (mActivityInfo.flags &amp;amp; FLAG_SHOW_FOR_ALL_USERS) != 0);
        } else {
            mParent.addChild(task, mOnTop ? POSITION_TOP : POSITION_BOTTOM);
        }
    }
    ...
    return task;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Task.Builder的build() 方法中，将创建的task添加到 TaskDisplayArea。&lt;/p&gt;

&lt;h1 id=&quot;2activityrecord添加到task&quot;&gt;2.ActivityRecord添加到Task&lt;/h1&gt;

&lt;p&gt;调用堆栈如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/trace2.png&quot; alt=&quot;trace2&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建ActivityRecord：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityStarter.java
private int executeRequest(Request request) {
    ...
    final ActivityRecord r = new ActivityRecord.Builder(mService)
            ...
            .build();
    ...
}
// ActivityRecord.java
private ActivityRecord(..) {
    super(_service.mWindowManager, new Token(), TYPE_APPLICATION, true,
            null /* displayContent */, false /* ownerCanManageAppTokens */);
    ((Token) token).mActivityRef = new WeakReference&amp;lt;&amp;gt;(this);
}

private static class Token extends Binder {
    @NonNull WeakReference&amp;lt;ActivityRecord&amp;gt; mActivityRef;

    @Override
    public String toString() {
        return &quot;Token{&quot; + Integer.toHexString(System.identityHashCode(this)) + &quot; &quot;
                + mActivityRef.get() + &quot;}&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;添加到 Task 中：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityStarter.java
private void addOrReparentStartingActivity(@NonNull Task task, String reason) {
    ..
    TaskFragment newParent = task;
    ...
    if (mStartActivity.getTaskFragment() == null
            || mStartActivity.getTaskFragment() == newParent) {
        newParent.addChild(mStartActivity, POSITION_TOP);
    } else {
        mStartActivity.reparent(newParent, newParent.getChildCount() /* top */, reason);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;添加到 DisplayContent 的 mTokenMap 中：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowToken.java
void onDisplayChanged(DisplayContent dc) {
    dc.reParentWindowToken(this);
    super.onDisplayChanged(dc);
}
// DisplayContent.java
void reParentWindowToken(WindowToken token) {
    ...
    addWindowToken(token.token, token);
    ...
}

void addWindowToken(IBinder binder, WindowToken token) {
    ...
    mTokenMap.put(binder, token);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3activity窗口添加到wms&quot;&gt;3.Activity窗口添加到WMS&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_show.png&quot; alt=&quot;act_show&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;31-activitysetcontentview&quot;&gt;3.1 Activity.setContentView(..)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Activity.java
public void setContentView(@LayoutRes int layoutResID) {
    getWindow().setContentView(layoutResID);
    initWindowDecorActionBar();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activity.setContentView(..) 中直接调用 PhoneWindow.setContentView(..) 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// PhoneWindow.java
public void setContentView(int layoutResID) {
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        ...
    }

    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        ...
    } else {
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
    ...
}

private void installDecor() {
    mForceDecorInstall = false;
    if (mDecor == null) {
        mDecor = generateDecor(-1);
        ...
    } else {
        mDecor.setWindow(this);
    }
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor);
        ...
    }
}

protected DecorView generateDecor(int featureId) {
    ...
    return new DecorView(context, featureId, this, getAttributes());
}

protected ViewGroup generateLayout(DecorView decor) {
    ...
    int layoutResource;
    int features = getLocalFeatures();
    if ((features &amp;amp; ((1 &amp;lt;&amp;lt; FEATURE_LEFT_ICON) | (1 &amp;lt;&amp;lt; FEATURE_RIGHT_ICON))) != 0) {
        ..
    } else if ((features &amp;amp; ((1 &amp;lt;&amp;lt; FEATURE_PROGRESS) | (1 &amp;lt;&amp;lt; FEATURE_INDETERMINATE_PROGRESS))) != 0
        &amp;amp;&amp;amp; (features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_ACTION_BAR)) == 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_CUSTOM_TITLE)) != 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_NO_TITLE)) == 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) {
        ..
    } else {
        layoutResource = R.layout.screen_simple;
    }
    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);
    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
    ...
    return contentParent;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PhoneWindow.setContentView(..) 方法主要做3件事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建DecorView。&lt;/li&gt;
  &lt;li&gt;inflate Activity 根布局。&lt;/li&gt;
  &lt;li&gt;inflate Activity 视图布局（setContentView()传入的layoutResID）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中系统预置 Activity 根布局有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;feature&lt;/th&gt;
      &lt;th&gt;布局&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_LEFT_ICON&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_RIGHT_ICON&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_title_icons.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_PROGRESS&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_INDETERMINATE_PROGRESS&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_ACTION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_progress.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_CUSTOM_TITLE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_custom_title.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_NO_TITLE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_title.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_ACTION_MODE_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_simple_overlay_action_mode.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;else&lt;/td&gt;
      &lt;td&gt;screen_simple.xml&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以 screen_simple.xml 为例查看其布局：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// screen_simple.xml
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;
    android:orientation=&quot;vertical&quot;&amp;gt;
    &amp;lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot;
              android:inflatedId=&quot;@+id/action_mode_bar&quot;
              android:layout=&quot;@layout/action_mode_bar&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;wrap_content&quot;
              android:theme=&quot;?attr/actionBarTheme&quot; /&amp;gt;
    &amp;lt;FrameLayout
         android:id=&quot;@android:id/content&quot;
         android:layout_width=&quot;match_parent&quot;
         android:layout_height=&quot;match_parent&quot;
         android:foregroundInsidePadding=&quot;false&quot;
         android:foregroundGravity=&quot;fill_horizontal|top&quot;
         android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&amp;gt;
&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应整个 Activity 视图为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/decor.png&quot; alt=&quot;decor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终，Activity.setContentView(..) 传入的布局会添加到 FrameLayout(id=ID_ANDROID_CONTENT) 。&lt;/p&gt;

&lt;h2 id=&quot;32-viewrootimplsetview&quot;&gt;3.2 ViewRootImpl.setView(..)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ViewRootImpl.java
public ViewRootImpl(Context context, Display display) {
    this(context, display, WindowManagerGlobal.getWindowSession(),
            false /* useSfChoreographer */);
}

public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session) {
    this(context, display, session, false /* useSfChoreographer */);
}

public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session,
        boolean useSfChoreographer) {
    mWindowSession = session;
    mWindow = new W(this);
    ...
}

public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,
        int userId, Bundle bundle) {
    synchronized (this) {
        if (mView == null) {
            ...
            try {
                res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,
                        getHostVisibility(), mDisplay.getDisplayId(), userId,
                        mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,
                        mTempControls);
            } catch (RemoteException e) {
            } finally {
            }
            ...
        }
    }
}
// WindowManagerGlobal.java
public static IWindowSession getWindowSession() {
    synchronized (WindowManagerGlobal.class) {
        if (sWindowSession == null) {
            try {
                IWindowManager windowManager = getWindowManagerService();
                sWindowSession = windowManager.openSession(
                        new IWindowSessionCallback.Stub() {
                            @Override
                            public void onAnimatorScaleChanged(float scale) {
                                ValueAnimator.setDurationScale(scale);
                            }
                        });
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        return sWindowSession;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ViewRootImpl 是 View视图 与 WindowManager 的纽带，mIWindowSession、mWindow 为 Binder 对象，用于 APP 端与 WMS 之间的相互通信。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/win_binder.png&quot; alt=&quot;win_binder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里通过 IWindowSession.addToDisplayAsUser(..) 接口，请求WMS添加新窗口。&lt;/p&gt;

&lt;p&gt;此外，ViewRootImpl 管理整个 View 视图的绘制和 Input 事件分发。&lt;/p&gt;

&lt;h1 id=&quot;4wms添加窗口&quot;&gt;4.WMS添加窗口&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(Session session, IWindow client, LayoutParams attrs, ..) {
    WindowState parentWindow = null;
    final int type = attrs.type;
    synchronized (mGlobalLock) {
        final DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token);
        
        if (type &amp;gt;= FIRST_SUB_WINDOW &amp;amp;&amp;amp; type &amp;lt;= LAST_SUB_WINDOW) {
            parentWindow = windowForClientLocked(null, attrs.token, false);
            ...
        }

        ActivityRecord activity = null;
        final boolean hasParent = parentWindow != null;
        WindowToken token = displayContent.getWindowToken(
                hasParent ? parentWindow.mAttrs.token : attrs.token);
        final int rootType = hasParent ? parentWindow.mAttrs.type : type;

        if (token == null) {
            ...
        } else if (rootType &amp;gt;= FIRST_APPLICATION_WINDOW
                &amp;amp;&amp;amp; rootType &amp;lt;= LAST_APPLICATION_WINDOW) {
            activity = token.asActivityRecord();
            ...
        } else if (rootType == TYPE_INPUT_METHOD) {
            ...
        } else if (rootType == TYPE_VOICE_INTERACTION) {
            ...
        } else if (rootType == TYPE_WALLPAPER) {
            ...
        } else if (rootType == TYPE_ACCESSIBILITY_OVERLAY) {
            ...
        } else if (type == TYPE_TOAST) {
            ...
        } else if (type == TYPE_QS_DIALOG) {
            ...
        } else if (token.asActivityRecord() != null) {
            ...
        }

        final WindowState win = new WindowState(this, session, client, token, parentWindow,
                appOp[0], attrs, viewVisibility, session.mUid, userId,
                session.mCanAddInternalSystemWindow);
        win.attach();
        mWindowMap.put(client.asBinder(), win);
        win.mToken.addWindow(win);

        if (type == TYPE_APPLICATION_STARTING &amp;amp;&amp;amp; activity != null) {
            activity.attachStartingWindow(win);
        } else if (type == TYPE_INPUT_METHOD
            ...
        } else if (type == TYPE_INPUT_METHOD_DIALOG) {
            ...
        } else {
            ...
        }
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;41-创建windowstate&quot;&gt;4.1 创建WindowState&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    WindowToken token = displayContent.getWindowToken(
            hasParent ? parentWindow.mAttrs.token : attrs.token);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里传入的 token 是在创建 ActivityRecord 时创建的 Binder 对象（见上文2），获取到的 WindowToken 为 ActivityRecord 对象。&lt;/p&gt;

&lt;p&gt;WMS每一个新窗口都会对应创建一个 WindowState 对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    final WindowState win = new WindowState(this, session, client, token, parentWindow,
            appOp[0], attrs, viewVisibility, session.mUid, userId,
            session.mCanAddInternalSystemWindow);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以 Activity 页面弹出一个Dialog对话框为例，WindowToken 与 WindowState 的关系为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/win_token.png&quot; alt=&quot;win_token&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;42-创建surfacesession&quot;&gt;4.2 创建SurfaceSession&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    synchronized (mGlobalLock) {
        ...
        final WindowState win = new WindowState(...);
        win.attach();
        ...
    }
    return res;
}

// WindowState.java
void attach() {
    mSession.windowAddedLocked();
}

// Session.java
void windowAddedLocked() {
    ...
    if (mSurfaceSession == null) {
        mSurfaceSession = new SurfaceSession();
        ...
    }
}

// SurfaceSession.java
/** Create a new connection with the surface flinger. */
@UnsupportedAppUsage
public SurfaceSession() {
    mNativeClient = nativeCreate();
}

// android_view_SurfaceSession.cpp
static jlong nativeCreate(JNIEnv* env, jclass clazz) {
    SurfaceComposerClient* client = new SurfaceComposerClient();
    client-&amp;gt;incStrong((void*)nativeCreate);
    return reinterpret_cast&amp;lt;jlong&amp;gt;(client);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SurfaceSession 构造方法中通过 nativeCreate() 方法返回了一个 SurfaceComposerClient 指针，它表示一个跟 SurfaceFlinger 的连接，当其第一次被使用时会调用 onFirstRef() 方法，创建一个实现 ISurfaceComposerClient 接口的 Client 对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// SurfaceComposerClient.cpp
void SurfaceComposerClient::onFirstRef() {
    sp&amp;lt;ISurfaceComposer&amp;gt; sf(ComposerService::getComposerService());
    if (sf != nullptr &amp;amp;&amp;amp; mStatus == NO_INIT) {
        sp&amp;lt;ISurfaceComposerClient&amp;gt; conn;
        conn = sf-&amp;gt;createConnection();
        if (conn != nullptr) {
            mClient = conn;
            mStatus = NO_ERROR;
        }
    }
}

// SurfaceFlinger.cpp
sp&amp;lt;ISurfaceComposerClient&amp;gt; SurfaceFlinger::createConnection() {
    const sp&amp;lt;Client&amp;gt; client = new Client(this);
    return client-&amp;gt;initCheck() == NO_ERROR ? client : nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WMS 创建了一个 WindowState 对象表示客户端的一个 Window，接着调用 WindowState.attach() 方法创建了一个 SurfaceSession 对象，SurfaceSession 表示一个跟 SurfaceFlinger 的连接，它创建了一个 SurfaceComposerClient 对象，然后 SurfaceFlinger 又创建了一个 Client 对象。&lt;/p&gt;

&lt;h2 id=&quot;43-windowstate添加到activityrecord&quot;&gt;4.3 WindowState添加到ActivityRecord&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    final WindowState win = new WindowState(.., token, ..);
    ...
    win.mToken.addWindow(win);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;5应用绘制&quot;&gt;5.应用绘制&lt;/h1&gt;

&lt;h2 id=&quot;51-创建surface&quot;&gt;5.1 创建Surface&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ViewRootImpl.java
public final Surface mSurface = new Surface();
private final SurfaceControl mSurfaceControl = new SurfaceControl();
private BLASTBufferQueue mBlastBufferQueue;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建 ViewRootImp 实例时，会创建一个空的 Surface 和 SurfaceControl 对象，其初始化流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ViewRootImpl$TraversalRunnable.run(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.doTraversal(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.performTraversals(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.relayoutWindow(..)&lt;/li&gt;
  &lt;li&gt;Session.relayout(.., mSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowManagerService.relayoutWindow(.., outSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowManagerService.createSurfaceControl(outSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowStateAnimator.createSurfaceLocked()&lt;/li&gt;
  &lt;li&gt;new WindowSurfaceController(..)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.Builder.build()&lt;/li&gt;
  &lt;li&gt;new SurfaceControl(..)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.nativeCreate(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// android_view_SurfaceControl.cpp
static jlong nativeCreate(..) {
    sp&amp;lt;SurfaceComposerClient&amp;gt; client;
    if (sessionObj != NULL) {
        client = android_view_SurfaceSession_getClient(env, sessionObj);
    } else {
        client = SurfaceComposerClient::getDefault();
    }

    sp&amp;lt;SurfaceControl&amp;gt; surface;
    status_t err = client-&amp;gt;createSurfaceChecked(String8(name.c_str()), w, h, format, &amp;amp;surface,
                                                flags, parentHandle, std::move(metadata));
    surface-&amp;gt;incStrong((void *)nativeCreate);
    return reinterpret_cast&amp;lt;jlong&amp;gt;(surface.get());
}

// SurfaceComposerClient.cpp 
status_t SurfaceComposerClient::createSurfaceChecked(..) {
    status_t err = mStatus;

    if (mStatus == NO_ERROR) {
        sp&amp;lt;IBinder&amp;gt; handle;
        sp&amp;lt;IGraphicBufferProducer&amp;gt; gbp;

        err = mClient-&amp;gt;createSurface(name, w, h, format, flags, parentHandle, std::move(metadata),
                                     &amp;amp;handle, &amp;amp;gbp, &amp;amp;id, &amp;amp;transformHint);

        if (err == NO_ERROR) {
            *outSurface =
                    new SurfaceControl(this, handle, gbp, id, w, h, format, transformHint, flags);
        }
    }
    return err;
}

// surfaceflinger/Client.cpp
status_t Client::createSurface(..) {
    LayerCreationArgs args(mFlinger.get(), this, name.c_str(), flags, std::move(metadata));
    return mFlinger-&amp;gt;createLayer(args, outHandle, parentHandle, outLayerId, nullptr,
                                 outTransformHint);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;WindowSurfaceController.getSurfaceControl(outSurfaceControl)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.copyFrom(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;outSurfaceControl.copyFrom(mSurfaceControl, &quot;WindowSurfaceController.getSurfaceControl&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;SurfaceControl.nativeCopyFromSurfaceControl(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.updateBlastSurfaceIfNeeded()&lt;/li&gt;
  &lt;li&gt;new BLASTBufferQueue(mTag, mSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;BLASTBufferQueue.createSurface()&lt;/li&gt;
  &lt;li&gt;BLASTBufferQueue.nativeGetSurface(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// android_graphics_BLASTBufferQueue.cpp
static jobject nativeGetSurface(JNIEnv* env, jclass clazz, jlong ptr,
                                jboolean includeSurfaceControlHandle) {
    sp&amp;lt;BLASTBufferQueue&amp;gt; queue = reinterpret_cast&amp;lt;BLASTBufferQueue*&amp;gt;(ptr);
    return android_view_Surface_createFromSurface(env,
                                                  queue-&amp;gt;getSurface(includeSurfaceControlHandle));
}

// BLASTBufferQueue.cpp
sp&amp;lt;Surface&amp;gt; BLASTBufferQueue::getSurface(bool includeSurfaceControlHandle) {
    std::unique_lock _lock{mMutex};
    sp&amp;lt;IBinder&amp;gt; scHandle = nullptr;
    if (includeSurfaceControlHandle &amp;amp;&amp;amp; mSurfaceControl) {
        scHandle = mSurfaceControl-&amp;gt;getHandle();
    }
    return new BBQSurface(mProducer, true, scHandle, this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;Surface.transferFrom(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;mSurface.transferFrom(blastSurface);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;Surface.setNativeObjectLocked(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 Java 层中 ViewRootImpl 实例中持有一个 Surface 对象，该 Surface 对象中的 mNativeObject 属性指向 native 层中创建的 Surface 对象，native 层的 Surface 对应 SurfaceFlinger 中的 Layer 对象，它持有 Layer 中的 BufferQueueProducer 生产者指针，在 Surface 上绘制的内容最终会交由 SurfaceFlinger 来合成渲染送到显示器显示。&lt;/p&gt;

&lt;h2 id=&quot;52-view绘制构建阶段&quot;&gt;5.2 View绘制：构建阶段&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw1.png&quot; alt=&quot;view_draw1&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Choreographer.java

private final class FrameDisplayEventReceiver extends DisplayEventReceiver
        implements Runnable {

    @Override
    public void onVsync(..) {
        try {
            ...
            Message msg = Message.obtain(mHandler, this);
            msg.setAsynchronous(true);
            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
        } finally {
        }
    }

    @Override
    public void run() {
        doFrame(mTimestampNanos, mFrame, mLastVsyncEventData);
    }
}

void doFrame(..) {
    try {
        ...
        doCallbacks(Choreographer.CALLBACK_INPUT, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameData, frameIntervalNanos);
    } finally {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Choreographer中收到Vsync信号后，向主线程MessageQueue发送一条异步Message，当异步Message执行后会调用其doFrame(..)方法，依次执行 INPUT、ANIMATION、INSETS_ANIMATION、TRAVERSAL、COMMIT 回调。&lt;/p&gt;

&lt;p&gt;在 TRAVERSAL 回调中会执行 mTraversalRunnable ，其 run() 方法中调用 doTraversal() 方法，执行 performTraversals() 方法，接着依次执行 View 的 measure、layout、draw 流程的代码。&lt;/p&gt;

&lt;h2 id=&quot;53-view绘制渲染阶段&quot;&gt;5.3 View绘制：渲染阶段&lt;/h2&gt;

&lt;p&gt;RenderThread线程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw2.png&quot; alt=&quot;view_draw2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;渲染方式：软件绘制（CPU） VS 硬件绘制（GPU）&lt;/p&gt;

&lt;p&gt;渲染引擎：OpenGL VS Vulkan&lt;/p&gt;

&lt;h2 id=&quot;54-surfaceflinger合成显示&quot;&gt;5.4 SurfaceFlinger：合成显示&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw3.png&quot; alt=&quot;view_draw3&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;6小结&quot;&gt;6.小结&lt;/h1&gt;

&lt;p&gt;应用侧 Window 是一个抽象概念，用来描述顶层视图的外观和行为，唯一的实现类是 PhoneWindow。&lt;/p&gt;

&lt;p&gt;在创建 Activity / Dialog 时，会创建 PhoneWindow ，同时会创建 DecorView 。&lt;/p&gt;

&lt;p&gt;应用侧向WMS请求添加视图时，会创建ViewRootImpl，同时会创建 Surface，视图绘制的数据会写入  Surface，由 SurfaceFlinger 合成显示。&lt;/p&gt;

&lt;p&gt;WMS添加应用侧视图时会创建 WindowState 用来对应一个 Window，同时维护 Window 的 Z-Order 。&lt;/p&gt;

&lt;h1 id=&quot;7参考文档&quot;&gt;7.参考文档&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.simowce.com/all-about-blastbbq/&quot;&gt;BLASTBufferQueue 详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/50a30fa6952e&quot;&gt;BBQ 机制介绍&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/cdc60627df90&quot;&gt;BBQ 原理解读&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/384a5cd2e304&quot;&gt;BBQ 运用场景&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/19/Activity%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/19/Activity%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>Activity</category>
        
        
      </item>
    
      <item>
        <title>Activity启动流程</title>
        <description>&lt;h1 id=&quot;1activity官方文档&quot;&gt;1.Activity官方文档&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/components/activities/intro-activities?hl=zh-cn&quot;&gt;Activity 简介&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle?hl=zh-cn&quot;&gt;Activity 生命周期&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/topics/manifest/activity-element?hl=zh-cn&quot;&gt;应用清单&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;2activity启动流程&quot;&gt;2.Activity启动流程&lt;/h1&gt;

&lt;p&gt;在桌面点击时钟图标打开闹钟应用，使用系统跟踪抓取 trace 文件，在 &lt;a href=&quot;https://ui.perfetto.dev/&quot;&gt;perfetto&lt;/a&gt; 打开查看：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/startActivity.perfetto-trace&quot;&gt;startActivity.perfetto-trace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_start.png&quot; alt=&quot;act_start&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了让整个过程可视化，对系统侧相关类做了代码插桩，在进入/退出方法处加上Trace日志：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/startActivityinjected.perfetto-trace&quot;&gt;startActivityinjected.perfetto-trace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在此基础上需要掌握调试安卓Framework源码 ，再结合trace来学习源码。&lt;/p&gt;

&lt;h2 id=&quot;21-点击应用图标&quot;&gt;2.1 点击应用图标&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;InputReader 负责从 EventHub 里面把 Input 事件读取出来，然后交给 InputDispatcher 进行事件分发。&lt;/li&gt;
  &lt;li&gt;InputDispatcher 在拿到 InputReader 获取的事件后对 Input 事件进行包装，然后寻找并分发到目标窗口。&lt;/li&gt;
  &lt;li&gt;InboundQueue（iq）队列中放着 InputDispatcher 从 InputReader 中拿到的 Input 事件。&lt;/li&gt;
  &lt;li&gt;OutboundQueue（oq）队列里面放的是即将要被派发给各个目标窗口的 Input 事件。&lt;/li&gt;
  &lt;li&gt;WaitQueue（wq）队列里面记录的是已经派发给目标窗口等待其处理完的 Input 事件。&lt;/li&gt;
  &lt;li&gt;PendingInputEventQueue（aq）队列中记录的是应用需要处理的 Input 事件。&lt;/li&gt;
  &lt;li&gt;deliverInputEvent 标识 App UI Thread 被 Input 事件唤醒。&lt;/li&gt;
  &lt;li&gt;App 响应处理 Input 事件，内部会在其界面 View 树中传递处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;22-启动闹钟应用&quot;&gt;2.2 启动闹钟应用&lt;/h2&gt;

&lt;h3 id=&quot;221-桌面请求启动闹钟应用&quot;&gt;2.2.1 桌面请求启动闹钟应用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Activity.startActivityForResult(..)&lt;/li&gt;
  &lt;li&gt;Instrumentation.execStartActivity(..)&lt;/li&gt;
  &lt;li&gt;ActivityTaskManager.&lt;em&gt;getService&lt;/em&gt;().startActivity(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private static final Singleton&amp;lt;IActivityTaskManager&amp;gt; IActivityTaskManagerSingleton =
        new Singleton&amp;lt;IActivityTaskManager&amp;gt;() {
            @Override
            protected IActivityTaskManager create() {
                final IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);
                return IActivityTaskManager.Stub.asInterface(b);
            }
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;222-系统侧处理请求&quot;&gt;2.2.2 系统侧处理请求&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/atms_start_act.png&quot; alt=&quot;atms_start_act&quot; /&gt;&lt;/p&gt;

&lt;p&gt;核心逻辑从ActivityStarter.execute()方法开始：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. ActivityStarter$Request.resolveActivity(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;解析 ResolveInfo 和 ActivityInfo，最终调用到 ComputerEngine.queryIntentActivitiesInternal(..)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/resolve_act.png&quot; alt=&quot;resolve_act&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有个细节是处理 显式启动 与 隐式启动 的区别：&lt;a href=&quot;https://developer.android.com/guide/components/intents-filters?hl=zh-cn&quot;&gt;Intent 和 Intent 过滤器&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;queryIntentActivitiesInternal(..) {
    ComponentName comp = intent.getComponent();
    if (comp != null) {
        getActivityInfo(..)
    } else {
        queryIntentActivitiesInternalBody(..)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. ActivityStarter.executeRequest()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.1 权限检查&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.1 启动权限检查：ActivityTaskSupervisor.checkStartAnyActivityPermission(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;应用AndroidManifest.xml配置项：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;android:exported&lt;/th&gt;
      &lt;th&gt;activity 是否可由其他应用的组件启动。&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;android:permission&lt;/td&gt;
      &lt;td&gt;启动 activity 或以其他方式使 activity 响应 intent 时，客户端必须具备的权限的名称。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;2.1.2 允许后台启动检查：ActivityStarter.shouldAbortBackgroundActivityStart(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;详见 &lt;a href=&quot;https://developer.android.com/guide/components/activities/background-starts?hl=zh-cn&quot;&gt;从后台启动 Activity 的限制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.2 创建ActivityRecord&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Activity 的实例是在应用侧创建的，系统侧会创建 ActivityRecord 与之对应，用来存储 Activity 的相关信息。&lt;/p&gt;

&lt;p&gt;相关文档：&lt;a href=&quot;http://gityuan.com/2017/06/11/activity_record/&quot;&gt;四大组件之ActivityRecord&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.3 ActivityStarter#startActivityUnchecked&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.1 ActivityTaskManagerService.deferWindowLayout(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;延迟当前进行的布局，因为页面即将要刷新，继续进行布局没有意义，与 continueWindowLayout() 成对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.2 ActivityStarter.startActivityInner(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这部分的核心逻辑围绕 &lt;a href=&quot;https://developer.android.com/guide/components/activities/tasks-and-back-stack?hl=zh-cn&quot;&gt;任务和返回堆栈 &lt;/a&gt;内容展开：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Task（任务）是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Task（任务）是一个整体单元，当用户开始一个新任务或通过主屏幕按钮进入主屏幕时，任务可移至“后台”。“后台”任务可重新返回到“前台”，以便用户可以从他们离开的地方继续操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了更直观地理解这部分内容，写了一个示例应用：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/activityLaunchMode.apk&quot;&gt;activityLaunchMode.apk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.ActivityStarter#setInitialState&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act1.png&quot; alt=&quot;act1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.ActivityStarter#computeLaunchingTaskFlags&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act2.png&quot; alt=&quot;act2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要判断是否添加 &lt;a href=&quot;https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_NEW_TASK&quot;&gt;FLAG_ACTIVITY_NEW_TASK&lt;/a&gt; 属性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.计算4个task&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Get top task at beginning because the order may be changed when reusing existing task.
final Task prevTopRootTask = mPreferredTaskDisplayArea.getFocusedRootTask();
final Task prevTopTask = prevTopRootTask != null ? prevTopRootTask.getTopLeafTask() : null;
final Task reusedTask = getReusableTask();
final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act3.png&quot; alt=&quot;act3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要逻辑是查找是否存在Activity可复用的Task。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.ActivityStarter#isAllowedToStart&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act4.png&quot; alt=&quot;act4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于 targetTask 再次判断 Activity 是否允许启动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.ActivityStarter#recycleTask&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final boolean newTask = targetTask == null;
final ActivityRecord targetTaskTop = newTask
        ? null : targetTask.getTopNonFinishingActivity();
if (targetTaskTop != null) {
    recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);
} else {
    mAddingToTask = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复用targetTask，从桌面点击应用图标启动应用，targetTask 为 null，不会走 recycleTask() 逻辑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.ActivityStarter#getOrCreateRootTask&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act5.png&quot; alt=&quot;act5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里会创建 RootTask（截图中选中位置）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.ActivityStarter#setNewTask&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (newTask) {
    final Task taskToAffiliate = (mLaunchTaskBehind &amp;amp;&amp;amp; mSourceRecord != null)
            ? mSourceRecord.getTask() : null;
    setNewTask(taskToAffiliate);
} else if (mAddingToTask) {
    addOrReparentStartingActivity(targetTask, &quot;adding to task&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act6.png&quot; alt=&quot;act6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;调用 Task.reuseOrCreateTask(..) 复用或者创建 Task（截图中选中位置），这里会复用刚才创建的 RootTask。&lt;/p&gt;

&lt;p&gt;这里还有一个逻辑是 ActivityStarter#addOrReparentStartingActivity ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (mStartActivity.getTaskFragment() == null
        || mStartActivity.getTaskFragment() == newParent) {
    newParent.addChild(mStartActivity, POSITION_TOP);
} else {
    mStartActivity.reparent(newParent, newParent.getChildCount() /* top */, reason);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mStartActivity 是 ActivityRecord，newParent 是 Task，将ActivityRecord添加到Task中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.Task#moveToFront&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act7.png&quot; alt=&quot;act7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里是将 mTargetRootTask 移至“前台”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.Task#startActivityLocked&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act8.png&quot; alt=&quot;act8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有个应用启动优化项：StartingWindow。&lt;/p&gt;

&lt;p&gt;相关介绍文档：&lt;a href=&quot;https://androidperformance.com/2018/05/20/zhihu-startingwindow/#/StartingWindow-对用户体验的影响&quot;&gt;知乎 救救你的 StartingWindow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10.RootWindowContainer#resumeFocusedTasksTopActivities&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act9.png&quot; alt=&quot;act9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前面已经把 mTargetRootTask 移至“前台”，这里是把 mStartActivity 移至“前台”，主要逻辑在TaskFragment#resumeTopActivity。&lt;/p&gt;

&lt;p&gt;在目标 Activity 显示出来之前，需要把 RootTask 中其他 Activities 暂停：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act10.png&quot; alt=&quot;act10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终会调用到 TaskFragment#schedulePauseActivity （截图中选中位置）通知桌面暂停Launcher，详见 2.2.3。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;void schedulePauseActivity(..) {
    mAtmService.getLifecycleManager().scheduleTransaction(prev.app.getThread(),
            prev.token, PauseActivityItem.obtain(..));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来会判断应用进程是否存在，如果不存在先创建应用进程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;boolean pausing = !deferPause &amp;amp;&amp;amp; taskDisplayArea.pauseBackTasks(next);
if (pausing) {
    if (next.attachedToProcess()) {
        //应用进程存在
        next.app.updateProcessInfo(..);
    } else if (!next.isProcessRunning()) {
        //应用进程不存在，创建进程
        mAtmService.startProcessAsync(..);
    }
} else if (mResumedActivity == next &amp;amp;&amp;amp; next.isState(RESUMED)
        &amp;amp;&amp;amp; taskDisplayArea.allResumedActivitiesComplete()) {
    //执行过渡动画
    executeAppTransition(options);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里闹钟进程不存在，会请求 Zygote 创建闹钟进程，详见 2.3。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.3 ActivityTaskManagerService.continueWindowLayout(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与上文 deferWindowLayout(..) 成对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.4 ActivityStarter.postStartActivityProcessing(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ActivityStartInterceptor 回调监听者 onActivityLaunched(..)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (ActivityManager.isStartResultSuccessful(result)) {
    mInterceptor.onActivityLaunched(targetTask.getTaskInfo(), r);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;223-桌面activitypause&quot;&gt;2.2.3 桌面activityPause&lt;/h3&gt;

&lt;p&gt;桌面收到系统侧 activityPause 通知，处理完后再通知系统侧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_pause1.png&quot; alt=&quot;act_pause1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统侧收到桌面 activityPause 通知：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_pause2.png&quot; alt=&quot;act_pause2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;startSpecificActivity(..) 有多个入口，当应用进程创建完执行 attachApplication 后，才会执行 realStartActivityLocked(..)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final WindowProcessController wpc = mService.getProcessController(..);
if (wpc != null &amp;amp;&amp;amp; wpc.hasThread()) {
    realStartActivityLocked(r, wpc, andResume, checkConfig);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 realStartActivityLocked(..) 中会通知应用侧执行 Activity 生命周期回调，详见 2.5：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final ClientTransaction clientTransaction = ClientTransaction.obtain(..);
clientTransaction.addCallback(LaunchActivityItem.obtain(..));
clientTransaction.setLifecycleStateRequest(ResumeActivityItem.obtain(..));
mService.getLifecycleManager().scheduleTransaction(clientTransaction);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;224-桌面activitystop&quot;&gt;2.2.4 桌面activityStop&lt;/h3&gt;

&lt;p&gt;上接 2.2.3，在显示出 Activity 前会执行 AppTransition 过渡动画：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_stop1.png&quot; alt=&quot;act_stop1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过渡动画执行完后，会通知桌面执行activityStop：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_stop2.png&quot; alt=&quot;act_stop2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结下两个应用 Activity 生命周期：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;桌面 Launcher 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onPause()&lt;/code&gt; 方法执行。&lt;/li&gt;
  &lt;li&gt;闹钟 DeskClockTabActivity 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStart()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onResume()&lt;/code&gt; 方法依次执行（闹钟 DeskClockTabActivity 现在具有用户焦点）。&lt;/li&gt;
  &lt;li&gt;桌面 Launcher 在屏幕上不再显示，其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStop()&lt;/code&gt; 方法执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;23-创建闹钟进程&quot;&gt;2.3 创建闹钟进程&lt;/h2&gt;

&lt;h3 id=&quot;231-系统侧请求创建闹钟进程&quot;&gt;2.3.1 系统侧请求创建闹钟进程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityManagerService.startProcess(..)&lt;/li&gt;
  &lt;li&gt;ActivityManagerService.startProcessLocked(..)&lt;/li&gt;
  &lt;li&gt;ProcessList.startProcessLocked(..)&lt;/li&gt;
  &lt;li&gt;ProcessList.startProcess(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (hostingRecord.usesWebviewZygote()) {
    WebViewZygote.getProcess().start(..)
} else if (hostingRecord.usesAppZygote()) {
    // see FLAG_USE_APP_ZYGOTE
    appZygote.getProcess().start(..)
} else {
    Process.start(..);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;ZYGOTE_PROCESS.start(..)&lt;/li&gt;
  &lt;li&gt;ZYGOTE_PROCESS.startViaZygote(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;static ZygoteState connect(@NonNull LocalSocketAddress zygoteSocketAddress,
        @Nullable LocalSocketAddress usapSocketAddress)
        throws IOException {

    final LocalSocket zygoteSessionSocket = new LocalSocket();

    try {
        zygoteSessionSocket.connect(zygoteSocketAddress);
    } catch (IOException ex) {
    }
    
    return new ZygoteState(..)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;ZYGOTE_PROCESS.zygoteSendArgsAndGetResult(..)&lt;/li&gt;
  &lt;li&gt;ZYGOTE_PROCESS.attemptZygoteSendArgsAndGetResult(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private Process.ProcessStartResult attemptZygoteSendArgsAndGetResult(
        ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx {
    try {
        final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;
        final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;

        zygoteWriter.write(msgStr);
        zygoteWriter.flush();

        // Always read the entire result from the input stream to avoid leaving
        // bytes in the stream for future process starts to accidentally stumble
        // upon.
        Process.ProcessStartResult result = new Process.ProcessStartResult();
        result.pid = zygoteInputStream.readInt();
        result.usingWrapper = zygoteInputStream.readBoolean();

        if (result.pid &amp;lt; 0) {
            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);
        }

        return result;
    } catch (IOException ex) {
        zygoteState.close();
        throw new ZygoteStartFailedEx(ex);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Q：这里为什么不采用Binder进行通信？&lt;/p&gt;

&lt;p&gt;A：fork机制限制，仅支持单线程，而binder会创建多线程。&lt;/p&gt;

&lt;h3 id=&quot;232-zygote创建闹钟进程&quot;&gt;2.3.2 Zygote创建闹钟进程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ZygoteServer.runSelectLoop(..)&lt;/li&gt;
  &lt;li&gt;ZygoteConnection.processCommand(..)&lt;/li&gt;
  &lt;li&gt;Zygote.forkAndSpecialize(..)&lt;/li&gt;
  &lt;li&gt;Zygote.nativeForkAndSpecialize(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;int pid = Zygote.forkAndSpecialize(..);
if (pid == 0) {
    // in child
    handleChildProc(..);
} else {
    // In the parent
    handleParentProc(..);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;24-闹钟主线程初始化&quot;&gt;2.4 闹钟主线程初始化&lt;/h2&gt;

&lt;h3 id=&quot;241-闹钟向系统侧请求attachapplication&quot;&gt;2.4.1 闹钟向系统侧请求attachApplication&lt;/h3&gt;

&lt;p&gt;闹钟进程创建完成后初始化，上接 2.3.2：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Zygote.handleChildProc(..)&lt;/li&gt;
  &lt;li&gt;ZygoteInit.zygoteInit(..)&lt;/li&gt;
  &lt;li&gt;RuntimeInit.applicationInit(..)&lt;/li&gt;
  &lt;li&gt;RuntimeInit.findStaticMain(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.main(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.attach(..)&lt;/li&gt;
  &lt;li&gt;ActivityManagerService.attachApplication(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/application1.png&quot; alt=&quot;application1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统侧收到闹钟 attachApplication 通知，上接 2.2.3，在此之后才会真正启动Activity：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/application2.png&quot; alt=&quot;application2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外，Looper 也是在 ActivityThread.main(..) 中初始化的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;Looper.prepareMainLooper();
Looper.loop();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;242-闹钟处理系统侧bindapplication请求&quot;&gt;2.4.2 闹钟处理系统侧bindApplication请求&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityThread$ApplicationThread.bindApplication(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.sendMessage(H.BIND_APPLICATION, data) // 第一条消息&lt;/li&gt;
  &lt;li&gt;ActivityThread.handleBindApplication(data)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
private void handleBindApplication(AppBindData data) {
    ...
    // JVMTI
    if (agent != null) {
        handleAttachAgent(agent, data.info);
    }

    // 1.创建ContextImpl
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);

    // 2.创建Instrumentation
    if (ii != null) {
        initInstrumentation(ii, data, appContext);
    } else {
        mInstrumentation = new Instrumentation();
        mInstrumentation.basicInit(this);
    }

    try {
        // 3.创建 Application
        app = data.info.makeApplicationInner(data.restrictedBackupMode, null);
        ...
        if (!data.restrictedBackupMode) {
            if (!ArrayUtils.isEmpty(data.providers)) {
                // 初始化ContentProvider
                installContentProviders(app, data.providers);
            }
        }
        ...
        try {
            // call Instrumentation.onCreate()
            mInstrumentation.onCreate(data.instrumentationArgs);
        }
        catch (Exception e) {
        }
        ...
        try {
            // call Application.onCreate()
            mInstrumentation.callApplicationOnCreate(app);
        } catch (Exception e) {
        }
    } finally {
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;25-闹钟activity生命周期&quot;&gt;2.5 闹钟Activity生命周期&lt;/h2&gt;

&lt;p&gt;上接 2.2.3，实例化Activity：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityThread$ApplicationThread.scheduleTransaction(..)&lt;/li&gt;
  &lt;li&gt;ClientTransactionHandler.scheduleTransaction(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread$H.handleMessage(..)&lt;/li&gt;
  &lt;li&gt;TransactionExecutor.execute(..)&lt;/li&gt;
  &lt;li&gt;LaunchActivityItem.execute(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.handleLaunchActivity(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.performLaunchActivity(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;try {
    java.lang.ClassLoader cl = appContext.getClassLoader();
    activity = mInstrumentation.newActivity(
            cl, component.getClassName(), r.intent);
} catch (Exception e) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activity创建后依次执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStart()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onResume()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_lifecycle.png&quot; alt=&quot;act_lifecycle&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;26-activity绘制及显示到屏幕&quot;&gt;2.6 Activity绘制及显示到屏幕&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_draw1.png&quot; alt=&quot;act_draw1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在VSYNC-app周期内：SurfaceFlinger的app线程唤醒home主线程，接下来执行Choreographer的doFrame流程，包括input，animation，traversal阶段，在traversal中执行draw绘制并将绘制的内容同步给RenderThread线程。RenderThread线程先从buffer队列中dequeueBuffer申请一个buffer，填充内容，然后queueBuffer将buffer加入队列，并通知SurfaceFlinger。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_draw2.png&quot; alt=&quot;act_draw2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在VSYNC-sf周期内：处理MessageQueue::INVALIDATE消息，从各Layer的BufferQueue拿到最新的缓冲数据，并根据内容更新脏区域；处理MessageQueue::REFRESH消息，通过HWC合成各Layer的buffer，发送至显示设备进行显示。&lt;/p&gt;

&lt;h1 id=&quot;3-小结&quot;&gt;3. 小结&lt;/h1&gt;

&lt;p&gt;本文以在桌面点击图标启动闹钟应用为例，结合trace简单介绍了Activity启动流程中的关键细节，主要包括：Framework侧处理Activity启动请求、任务和返回栈、Activity生命周期、应用进程创建及初始化及绘制流程等。&lt;/p&gt;

&lt;p&gt;可延伸的知识点包括：Context、Window、View事件分发、View绘制流程、Handler机制、Binder机制、类加载机制、fork机制、ServiceManager、SurfaceFlinger、代码插桩、插件化等。&lt;/p&gt;

&lt;h1 id=&quot;4-参考文档&quot;&gt;4. 参考文档：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/37370c1d17fc&quot;&gt;Android应用启动全流程分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/cf531a3af828&quot;&gt;Android卡顿掉帧问题分析之工具篇&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>Activity</category>
        
        
      </item>
    
      <item>
        <title>DisplayArea树层级结构</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/class_hierarchy.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;RootWindowContainer：最顶层的管理者，直接管理 DisplayContent 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DisplayContent：对应一个真实或者虚拟的显示设备。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TaskDisplayArea：是系统中所有应用任务的父节点，用于管理 Task 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Task：代表一个任务，可以包含多个 Activity 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ActivityRecord：对应一个 Activity 节点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;WindowState：对应一个窗口。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1window相关概念&quot;&gt;1.Window相关概念&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Window Type主要分为三大类：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Application windows（应用窗口）: 1~99&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sub-windows（子窗口）: 1000~1999&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;System windows（系统窗口）: 2000~2999&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Window Layer分为36层：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;default int getMaxWindowLayer() {
    return 36;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Z-Order计算：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;mBaseLayer = WindowLayer * 10000 + 1000;
mSubLayer = SubWindowLayer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Window Type与Window Layer对应关系如下：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Window Type&lt;/th&gt;
      &lt;th&gt;VALUE&lt;/th&gt;
      &lt;th&gt;Window Layer&lt;/th&gt;
      &lt;th&gt;Leaf Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BASE_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;APPLICATION_LAYER = 2&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;LEAF_TYPE_TASK_CONTAINERS = 1&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_STARTING&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DRAWN_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;LAST_APPLICATION_WINDOW&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;99&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1000&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_MEDIA&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1001&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;-2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_SUB_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1002&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_ATTACHED_DIALOG&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1003&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_MEDIA_OVERLAY&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1004&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_ABOVE_SUB_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1005&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SEARCH_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PHONE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_ALERT&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2003&lt;/td&gt;
      &lt;td&gt;12|9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_KEYGUARD&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2004&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_TOAST&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2005&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2006&lt;/td&gt;
      &lt;td&gt;23|20&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRIORITY_PHONE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2007&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2008&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_KEYGUARD_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2009&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_ERROR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2010&lt;/td&gt;
      &lt;td&gt;27|9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_METHOD&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2011&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;LEAF_TYPE_IME_CONTAINERS = 2&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_METHOD_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2012&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_WALLPAPER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2013&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2014&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SECURE_SYSTEM_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2015&lt;/td&gt;
      &lt;td&gt;33&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DRAG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2016&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_SUB_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2017&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_POINTER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2018&lt;/td&gt;
      &lt;td&gt;35&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NAVIGATION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2019&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOLUME_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2020&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BOOT_PROGRESS&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2021&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_CONSUMER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2022&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NAVIGATION_BAR_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2024&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DISPLAY_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2026&lt;/td&gt;
      &lt;td&gt;29&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_MAGNIFICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2027&lt;/td&gt;
      &lt;td&gt;28&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRIVATE_PRESENTATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2030&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOICE_INTERACTION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2031&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_ACCESSIBILITY_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2032&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOICE_INTERACTION_STARTING&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2033&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DOCK_DIVIDER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2034&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_QS_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2035&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SCREENSHOT&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2036&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRESENTATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2037&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2038&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2039&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NOTIFICATION_SHADE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2040&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_ADDITIONAL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2041&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_CARWITH_NAVIGATION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2998&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;常见Window及Window Type：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Window&lt;/th&gt;
      &lt;th&gt;Window Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Activity&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BASE_APPLICATION&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TaskSnapshotWindow&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_STARTING&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dialog&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PopupWindow&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_PANEL&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Toast&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_TOAST&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;2为什么要构建displayarea树&quot;&gt;2.为什么要构建DisplayArea树？&lt;/h1&gt;

&lt;h2 id=&quot;21-需求分析&quot;&gt;2.1 需求分析&lt;/h2&gt;

&lt;p&gt;手机系统有N个类型的Window，需要划分Layer维护Window显示Z-order；&lt;/p&gt;

&lt;p&gt;有N个Feature（功能），每个Feature能够影响N个Layer层；&lt;/p&gt;

&lt;p&gt;窗口类型是可增加的，Feature是可增删的；&lt;/p&gt;

&lt;h2 id=&quot;22-方案设计&quot;&gt;2.2 方案设计&lt;/h2&gt;

&lt;p&gt;构建DisplayArea树，创建Feature节点，支持动态增删Feature，叶子节点维护Layer层级。&lt;/p&gt;

&lt;p&gt;以 DefaultTaskDisplayArea 节点为例：&lt;/p&gt;

&lt;p&gt;其父节点为 5|0|12 -&amp;gt; 3|0|14 -&amp;gt; 6|0|14 -&amp;gt; 4|0|31 -&amp;gt; DisplayContent，其含义为该节点的所有子节点均支持 FullscreenMagnification|5、OneHanded|3、HideDisplayCutout|6、WindowedMagnification|4 功能（Feature）。&lt;/p&gt;

&lt;p&gt;同时 DefaultTaskDisplayArea 节点的子节点的层级范围为 2|2，即所有子节点均为应用窗口，其Layer值是固定的。&lt;/p&gt;

&lt;h1 id=&quot;3构建displayarea树流程&quot;&gt;3.构建DisplayArea树流程&lt;/h1&gt;

&lt;h2 id=&quot;31-创建rootwindowcontainer&quot;&gt;3.1 创建RootWindowContainer&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;SystemServer.main(..)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SystemServer.run()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SystemServer.startOtherServices(..)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;vm = WindowManagerService.main(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
private WindowManagerService(..) {
    mRoot = new RootWindowContainer(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;32-创建displaycontent&quot;&gt;3.2 创建DisplayContent&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityManagerService.setWindowManager(wm)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ActivityTaskManagerService.setWindowManager(wm)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;RootWindowContainer.setWindowManager(wm)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// RootWindowContainer.java
private final ImeContainer mImeWindowsContainer = new ImeContainer(mWmService);
void setWindowManager(WindowManagerService wm) {
    ..
    final Display[] displays = mDisplayManager.getDisplays();
    for (int displayNdx = 0; displayNdx &amp;lt; displays.length; ++displayNdx) {
        final Display display = displays[displayNdx];
        final DisplayContent displayContent = new DisplayContent(display, this);
        addChild(displayContent, POSITION_BOTTOM);
        if (displayContent.mDisplayId == DEFAULT_DISPLAY) {
            mDefaultDisplay = displayContent;
        }
    }
    ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;33-创建defaulttaskdisplayarea&quot;&gt;3.3 创建DefaultTaskDisplayArea&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DisplayContent.java
DisplayContent(Display display, RootWindowContainer root) {
    ..
    final Transaction pendingTransaction = getPendingTransaction();
    configureSurfaces(pendingTransaction);
    pendingTransaction.apply();
    ..
}

private void configureSurfaces(Transaction transaction) {
    ..
    if (mDisplayAreaPolicy == null) {
        // Setup the policy and build the display area hierarchy.
        // Build the hierarchy only after creating the surface so it is reparented correctly
        mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(
                mWmService, this /* content */, this /* root */,
                mImeWindowsContainer);
    }
    ..
}

//DisplayAreaPolicy.java
static final class DefaultProvider implements DisplayAreaPolicy.Provider {
    @Override
    public DisplayAreaPolicy instantiate(WindowManagerService wmService,
            DisplayContent content, RootDisplayArea root,
            DisplayArea.Tokens imeContainer) {
        final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,
                &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);
        final List&amp;lt;TaskDisplayArea&amp;gt; tdaList = new ArrayList&amp;lt;&amp;gt;();
        tdaList.add(defaultTaskDisplayArea);

        // Define the features that will be supported under the root of the whole logical
        // display. The policy will build the DisplayArea hierarchy based on this.
        final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root);
        // Set the essential containers (even if the display doesn&apos;t support IME).
        rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);
        if (content.isTrusted()) {
            // Only trusted display can have system decorations.
            configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);
        }

        // Instantiate the policy with the hierarchy defined above. This will create and attach
        // all the necessary DisplayAreas to the root.
        return new DisplayAreaPolicyBuilder().setRootHierarchy(rootHierarchy).build(wmService);
    }
    
    private void configureTrustedHierarchyBuilder(HierarchyBuilder rootHierarchy,
            WindowManagerService wmService, DisplayContent content) {
        rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;WindowedMagnification&quot;,
                FEATURE_WINDOWED_MAGNIFICATION)
                .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                .setNewDisplayAreaSupplier(DisplayArea.Dimmable::new)
                .build());
        if (content.isDefaultDisplay) {
            rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;HideDisplayCutout&quot;,
                    FEATURE_HIDE_DISPLAY_CUTOUT)
                    .all()
                    .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL, TYPE_STATUS_BAR,
                            TYPE_NOTIFICATION_SHADE)
                    .build())
                    .addFeature(new Feature.Builder(wmService.mPolicy, &quot;OneHanded&quot;,
                            FEATURE_ONE_HANDED)
                            .all()
                            .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL,
                                    TYPE_SECURE_SYSTEM_OVERLAY)
                            .build());
        }
        rootHierarchy
                .addFeature(new Feature.Builder(wmService.mPolicy, &quot;FullscreenMagnification&quot;,
                        FEATURE_FULLSCREEN_MAGNIFICATION)
                        .all()
                        .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY, TYPE_INPUT_METHOD,
                                TYPE_INPUT_METHOD_DIALOG, TYPE_MAGNIFICATION_OVERLAY,
                                TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL)
                        .build())
                .addFeature(new Feature.Builder(wmService.mPolicy, &quot;ImePlaceholder&quot;,
                        FEATURE_IME_PLACEHOLDER)
                        .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG)
                        .build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 configureTrustedHierarchyBuilder(..) 方法中配置Feature及其能够影响到的Layer层：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Feature名&lt;/th&gt;
      &lt;th&gt;Feature ID&lt;/th&gt;
      &lt;th&gt;对应功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;WindowedMagnification&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;窗口放大镜功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HideDisplayCutout&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;隐藏刘海功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OneHanded&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;单手模式。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FullscreenMagnification&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;屏幕放大镜功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ImePlaceholder&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;特殊情况下用来放置输入法的节点。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在Feature类中使用一个长度为 getMaxWindowLayer() + 1 的boolean数组，用来标识该Feature能够影响到的Layer层：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;34-displayareapolicy构建过程&quot;&gt;3.4 DisplayAreaPolicy构建过程&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DisplayAreaPolicyBuilder.java
private void build(@Nullable List&amp;lt;HierarchyBuilder&amp;gt; displayAreaGroupHierarchyBuilders) {
    final WindowManagerPolicy policy = mRoot.mWmService.mPolicy;
    final int maxWindowLayerCount = policy.getMaxWindowLayer() + 1;
    final DisplayArea.Tokens[] displayAreaForLayer =
            new DisplayArea.Tokens[maxWindowLayerCount];
    final Map&amp;lt;Feature, List&amp;lt;DisplayArea&amp;lt;WindowContainer&amp;gt;&amp;gt;&amp;gt; featureAreas =
            new ArrayMap&amp;lt;&amp;gt;(mFeatures.size());
    for (int i = 0; i &amp;lt; mFeatures.size(); i++) {
        featureAreas.put(mFeatures.get(i), new ArrayList&amp;lt;&amp;gt;());
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;341-构建root节点&quot;&gt;3.4.1 构建root节点：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;PendingArea[] areaForLayer = new PendingArea[maxWindowLayerCount];
final PendingArea root = new PendingArea(null, 0, null);
Arrays.fill(areaForLayer, root);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;342-构建featurearea&quot;&gt;3.4.2 构建featureArea：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Create DisplayAreas to cover all defined features.
final int size = mFeatures.size();
for (int i = 0; i &amp;lt; size; i++) {
    final Feature feature = mFeatures.get(i);
    PendingArea featureArea = null;
    for (int layer = 0; layer &amp;lt; maxWindowLayerCount; layer++) {
        if (feature.mWindowLayers[layer]) {
            if (featureArea == null || featureArea.mParent != areaForLayer[layer]) {
                featureArea = new PendingArea(feature, layer, areaForLayer[layer]);
                areaForLayer[layer].mChildren.add(featureArea);
            }
            areaForLayer[layer] = featureArea;
        } else {
            featureArea = null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;黄色部分与上图是相对应的，创建的PendingArea显示格式为：Feature ID|minLayer&lt;/p&gt;

&lt;p&gt;构建出如下一棵树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/tree1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;343-构建-leafarea&quot;&gt;3.4.3 构建 leafArea：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Create Tokens as leaf for every layer.
PendingArea leafArea = null;
int leafType = LEAF_TYPE_TOKENS;
for (int layer = 0; layer &amp;lt; maxWindowLayerCount; layer++) {
    int type = typeOfLayer(policy, layer);
    if (leafArea == null || leafArea.mParent != areaForLayer[layer]
            || type != leafType) {
        leafArea = new PendingArea(null /* feature */, layer, areaForLayer[layer]);
        areaForLayer[layer].mChildren.add(leafArea);
        leafType = type;
        if (leafType == LEAF_TYPE_TASK_CONTAINERS) {
            addTaskDisplayAreasToApplicationLayer(areaForLayer[layer]);
            addDisplayAreaGroupsToApplicationLayer(areaForLayer[layer],
                    displayAreaGroupHierarchyBuilders);
            leafArea.mSkipTokens = true;
        } else if (leafType == LEAF_TYPE_IME_CONTAINERS) {
            leafArea.mExisting = mImeContainer;
            leafArea.mSkipTokens = true;
        }
    }
    leafArea.mMaxLayer = layer;
}

private static int typeOfLayer(WindowManagerPolicy policy, int layer) {
    if (layer == APPLICATION_LAYER) {
        return LEAF_TYPE_TASK_CONTAINERS; // 容纳App窗口的TaskDisplayArea
    } else if (layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD)
            || layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD_DIALOG)) {
        return LEAF_TYPE_IME_CONTAINERS; // 容纳输入法窗口的ImeContainer
    } else {
        return LEAF_TYPE_TOKENS; // 容纳其他非App类型窗口的DisplayArea.Tokens
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;黄色部分表示复用同一个leafArea，更新其mMaxLayer值，这里创建的PendingArea显示格式为：minLayer|maxLayer&lt;/p&gt;

&lt;h3 id=&quot;344-更新整棵树所有节点的maxlayer&quot;&gt;3.4.4 更新整棵树所有节点的maxLayer&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;int computeMaxLayer() {
    for (int i = 0; i &amp;lt; mChildren.size(); i++) {
        mMaxLayer = Math.max(mMaxLayer, mChildren.get(i).computeMaxLayer());
    }
    return mMaxLayer;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;345-构建整棵树&quot;&gt;3.4.5 构建整棵树&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;void instantiateChildren(DisplayArea&amp;lt;DisplayArea&amp;gt; parent, DisplayArea.Tokens[] areaForLayer,
        int level, Map&amp;lt;Feature, List&amp;lt;DisplayArea&amp;lt;WindowContainer&amp;gt;&amp;gt;&amp;gt; areas) {
    mChildren.sort(Comparator.comparingInt(pendingArea -&amp;gt; pendingArea.mMinLayer));
    for (int i = 0; i &amp;lt; mChildren.size(); i++) {
        final PendingArea child = mChildren.get(i);
        final DisplayArea area = child.createArea(parent, areaForLayer);
        if (area == null) {
            // TaskDisplayArea and ImeContainer can be set at different hierarchy, so it can
            // be null.
            continue;
        }
        parent.addChild(area, WindowContainer.POSITION_TOP);
        if (child.mFeature != null) {
            areas.get(child.mFeature).add(area);
        }
        child.instantiateChildren(area, areaForLayer, level + 1, areas);
    }
}

private DisplayArea createArea(DisplayArea&amp;lt;DisplayArea&amp;gt; parent,
        DisplayArea.Tokens[] areaForLayer) {
    if (mExisting != null) {
        // LEAF_TYPE_TASK_CONTAINERS
        // LEAF_TYPE_IME_CONTAINERS
        if (mExisting.asTokens() != null) {
            // Store the WindowToken container for layers
            fillAreaForLayers(mExisting.asTokens(), areaForLayer);
        }
        return mExisting;
    }
    if (mSkipTokens) {
        // LEAF_TYPE_TASK_CONTAINERS
        // LEAF_TYPE_IME_CONTAINERS
        return null;
    }
    DisplayArea.Type type;
    if (mMinLayer &amp;gt; APPLICATION_LAYER) {
        type = DisplayArea.Type.ABOVE_TASKS; // 位于App窗口之下的非App窗口
    } else if (mMaxLayer &amp;lt; APPLICATION_LAYER) {
        type = DisplayArea.Type.BELOW_TASKS; // 位于App窗口之上的非App窗口
    } else {
        type = DisplayArea.Type.ANY; // App窗口
    }
    if (mFeature == null) {
        final DisplayArea.Tokens leaf = new DisplayArea.Tokens(parent.mWmService, type,
                &quot;Leaf:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer);
        fillAreaForLayers(leaf, areaForLayer);
        return leaf;
    } else {
        return mFeature.mNewDisplayAreaSupplier.create(parent.mWmService, type,
                mFeature.mName + &quot;:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer, mFeature.mId);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整棵树的根节点是 DisplayContent，这里创建的DisplayArea显示格式为：Feature ID|minLayer|maxLayer；叶子节点的显示格式为：minLayer|maxLayer&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/tree2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;执行命令：adb shell dumpsys activity containers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;ACTIVITY MANAGER CONTAINERS (dumpsys activity containers)
ROOT 
  #0 Display 0 name=&quot;内置屏幕&quot;
   #2 Leaf:36:36 
    #1 WindowToken{7fb09c2 type=2024 android.os.BinderProxy@da9960d} 
     #0 e873d3 RoundCornerBottom 
    #0 WindowToken{2c592ae type=2024 android.os.BinderProxy@5ce3f29} 
     #0 164a84f RoundCornerTop 
   #1 HideDisplayCutout:32:35 
    #2 OneHanded:34:35 
     #0 FullscreenMagnification:34:35 
      #0 Leaf:34:35 
    #1 FullscreenMagnification:33:33 
     #0 Leaf:33:33 
    #0 OneHanded:32:32 
     #0 Leaf:32:32 
   #0 WindowedMagnification:0:31 
    #6 HideDisplayCutout:26:31 
     #0 OneHanded:26:31 
      #2 FullscreenMagnification:29:31 
       #0 Leaf:29:31 
      #1 Leaf:28:28 
       #1 WindowToken{6cffb72 type=2027 android.os.BinderProxy@9b9807d} 
        #0 e90cc40 GestureStubRight 
       #0 WindowToken{288fa0d type=2027 android.os.BinderProxy@3713ca4} 
        #0 1d77f10 GestureStubLeft 
      #0 FullscreenMagnification:26:27 
       #0 Leaf:26:27 
    #5 Leaf:24:25 
     #3 WindowToken{2cfd75e type=2024 android.os.BinderProxy@a18e899} 
      #0 6d1873f GestureStubHome 
     #2 WindowToken{4a05ae3 type=2024 android.os.BinderProxy@b34e312} 
      #0 28a0ce0 SecondaryHomeHandle0 
     #1 WindowToken{6986f7 type=2024 android.os.BinderProxy@f7da2f6} 
      #0 e17e964 pip-dismiss-overlay 
     #0 WindowToken{dfc6ab6 type=2019 android.os.BinderProxy@e0bfb78} 
      #0 bc113b7 NavigationBar0 
    #4 HideDisplayCutout:18:23 
     #0 OneHanded:18:23 
      #0 FullscreenMagnification:18:23 
       #0 Leaf:18:23 
        #1 WindowToken{2ecacd2 type=2017 android.os.BinderProxy@63e9b5d} 
         #0 7d9c1a3 control_center 
        #0 WindowToken{7960200 type=2017 android.os.BinderProxy@7c7083} 
         #0 b7b0a39 NotificationModalWindowManager 
    #3 OneHanded:17:17 
     #0 FullscreenMagnification:17:17 
      #0 Leaf:17:17 
       #0 WindowToken{37bf169 type=2040 android.os.BinderProxy@80f5833} 
        #0 f89f7ee NotificationShade 
    #2 HideDisplayCutout:16:16 
     #0 OneHanded:16:16 
      #0 FullscreenMagnification:16:16 
       #0 Leaf:16:16 
    #1 OneHanded:15:15 
     #0 FullscreenMagnification:15:15 
      #0 Leaf:15:15 
       #0 WindowToken{ac189b4 type=2000 android.os.BinderProxy@75516c6} 
        #0 194a9dd StatusBar 
    #0 HideDisplayCutout:0:14 
     #0 OneHanded:0:14 
      #1 ImePlaceholder:13:14 
       #0 ImeContainer 
        #0 WindowToken{720aa04 type=2011 android.os.Binder@d506617} 
         #0 f966473 InputMethod 
      #0 FullscreenMagnification:0:12 
       #2 Leaf:3:12 
        #0 WindowToken{ec3f545 type=2038 android.os.BinderProxy@fd8013a} 
         #0 329a9af ShellDropTarget 
       #1 DefaultTaskDisplayArea 
        #2 Task=18 
         #0 Task=19 
          #0 ActivityRecord{296e207 u0 com.miui.home/.launcher.Launcher} t19} 
           #0 9eb98f2 com.miui.home/com.miui.home.launcher.Launcher 
        #1 Task=4 
        #0 Task=5 
         #1 Task=7 
         #0 Task=6 
       #0 Leaf:0:1 
        #1 WallpaperWindowToken{d4d41d3 token=android.os.BinderProxy@2da4fc2} 
         #0 d44d722 com.miui.miwallpaper.wallpaperservice.MiuiKeyguardPictorialWallpaper 
        #0 WallpaperWindowToken{22dbaad token=android.os.Binder@fe41bc4} 
         #0 8db5a66 com.miui.miwallpaper.wallpaperservice.ImageWallpaper 
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到Activity是在DefaultTaskDisplayArea节点下，其他新创建的Window会根据Layer值插入到对应Leaf节点上。&lt;/p&gt;

&lt;h1 id=&quot;4参考资料&quot;&gt;4.参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7140289958085935141&quot;&gt;DisplayArea层级结构（一） —— DisplayArea层级结构的生成&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/7140289685879783432&quot;&gt;DisplayArea层级结构（二） —— 向DisplayArea层级结构添加窗口&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/7140289813516648456&quot;&gt;DisplayArea层级结构（三） —— 总结&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/shensky711/article/details/121530510&quot;&gt;WMS 层级结构 &amp;amp;&amp;amp; DisplayAreaGroup 引入&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/jieliaoyuan8279/article/details/123157937&quot;&gt;窗口层次: DisplayArea树&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/04/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/04/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>ANR治理-主线程耗时消息统计</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6942665216781975582&quot;&gt;今日头条 ANR 优化实践系列 - 监控工具与分析思路&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/6997227972973461512&quot;&gt;西瓜卡顿 &amp;amp; ANR 优化治理及监控体系建设&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从这两篇文章中可以大致猜出这三者之间的关系：&lt;/p&gt;

&lt;p&gt;Npth用来监控ANR，Sliver用来抓取线程堆栈，Raster用来做消息聚合。&lt;/p&gt;

&lt;p&gt;监控ANR的主流方案是微信的 监听signal+判断主线程卡顿，Sliver抓取堆栈是Native层实现，&lt;/p&gt;

&lt;p&gt;接下来主要分析消息聚合的实现。&lt;/p&gt;

&lt;h1 id=&quot;消息类型&quot;&gt;消息类型&lt;/h1&gt;

&lt;p&gt;定义在 ScheduleMsgItem.java 类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-undefined&quot;&gt;public static final int SCHEDULE_TYPE_IDLE = 0;
public static final int SCHEDULE_TYPE_LAST_LONG_MSG = 4;
public static final int SCHEDULE_TYPE_LONG_IDLE = 1;
public static final int SCHEDULE_TYPE_LONG_MSG = 8;
public static final int SCHEDULE_TYPE_MSG = 2;
public static final int SCHEDULE_TYPE_MSGS = 9;
public static final int SCHEDULE_TYPE_MSGS_IDLE = 7;
public static final int SCHEDULE_TYPE_MSGS_LONG_IDLE = 5;
public static final int SCHEDULE_TYPE_MSG_IDLE = 3;
public static final int SCHEDULE_TYPE_MSG_LONG_IDLE = 6;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looper 中打印 Message 日志，可以将消息分为两个阶段：Dispatching 和 Finished。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private static boolean loopOnce(final Looper me,
        final long ident, final int thresholdOverride) {
    ...

    final Printer logging = me.mLogging;
    if (logging != null) {
        logging.println(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Dispatching to &quot; + msg.target + &quot; &quot;
                + msg.callback + &quot;: &quot; + msg.what);
    }
    ...

    if (logging != null) {
        logging.println(&quot;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建 ScheduleMsgItem 实例的逻辑在 LooperMonitor.java 类，对应上述两个阶段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public static void setMessageLogging() {
    if (!ApmConfig.disableLooperMonitor() &amp;amp;&amp;amp; g.a() == null) {
        LooperMessageManager.getInstance().start();
        LooperMessageManager.getInstance().registerSyncStartPrinter(new Printer() { // from class: com.bytedance.crash.anr.LooperMonitor.2
            @Override // android.util.Printer
            public void println(String str) {
                if (LooperMonitor.sMainLooperMonitor) {
                    LooperMonitor.sCurrentStartMessage = str;
                    if (!LooperMonitor.sStartAsyncAutoTick) {
                        LooperMonitor.sStartAsyncAutoTick = true;
                        LooperMonitor.sMainThreadId = Process.myTid();
                        LooperMonitor.startAsyncAutoTick();
                    }
                    if (LooperMonitor.sLastUpdateTicks == -1) {
                        LooperMonitor.sLastUpdateTicks = 0;
                        LooperMonitor.sTempCurrentMessageStartTick = 0;
                        return;
                    }
                    long j = LooperMonitor.sAsyncAutoTick;
                    LooperMonitor.sTempCurrentMessageStartTick = j;
                    long j2 = j - LooperMonitor.sLastUpdateTicks;
                    if (j2 &amp;lt;= 0) {
                        LooperMonitor.sCurMsgIndex++;
                        return;
                    }
                    int i = j2 == 1 ? LooperMonitor.sCurMsgIndex &amp;gt; 1 ? 7 : LooperMonitor.sCurMsgIndex == 1 ? 3 : 0 : LooperMonitor.sCurMsgIndex &amp;gt; 1 ? 5 : LooperMonitor.sCurMsgIndex == 1 ? 6 : 1;
                    long mainThreadTimeMills = LooperMonitor.mainThreadTimeMills();
                    long uptimeMillis = SystemClock.uptimeMillis();
                    if (!LooperMonitor.sDumpingMessage) {
                        LooperMonitor.saveDataToItem(LooperMonitor.obtainItem(), mainThreadTimeMills - LooperMonitor.sCurThreadTime, uptimeMillis - LooperMonitor.sLastUpdateTime, j2, i, LooperMonitor.sCurMsgIndex, null);
                    }
                    LooperMonitor.sCurThreadTime = mainThreadTimeMills;
                    LooperMonitor.sLastUpdateTime = uptimeMillis;
                    LooperMonitor.sCurMsgIndex = 1;
                    LooperMonitor.sLastUpdateTicks = j;
                }
            }
        });
        LooperMessageManager.getInstance().registerSyncEndPrinter(new Printer() { // from class: com.bytedance.crash.anr.LooperMonitor.3
            @Override // android.util.Printer
            public void println(String str) {
                if (LooperMonitor.sMainLooperMonitor &amp;amp;&amp;amp; LooperMonitor.sLastUpdateTicks &amp;gt;= 0) {
                    long j = LooperMonitor.sAsyncAutoTick;
                    LooperMonitor.sCurrentStartMessage = &quot;no message running&quot;;
                    long j2 = j - LooperMonitor.sLastUpdateTicks;
                    if (j2 &amp;gt; 0) {
                        long mainThreadTimeMills = LooperMonitor.mainThreadTimeMills();
                        long uptimeMillis = SystemClock.uptimeMillis();
                        int i = (j2 != 1 || LooperMonitor.sCurMsgIndex &amp;lt;= 1) ? (j2 == 1 &amp;amp;&amp;amp; LooperMonitor.sCurMsgIndex == 1) ? 2 : (j2 &amp;lt;= 1 || LooperMonitor.sCurMsgIndex &amp;lt;= 1) ? (j2 &amp;lt;= 1 || LooperMonitor.sCurMsgIndex != 1) ? 0 : 8 : 4 : 9;
                        if (!LooperMonitor.sDumpingMessage) {
                            LooperMonitor.saveDataToItem(LooperMonitor.obtainItem(), mainThreadTimeMills - LooperMonitor.sCurThreadTime, uptimeMillis - LooperMonitor.sLastUpdateTime, j2, i, LooperMonitor.sCurMsgIndex, str);
                        }
                        LooperMonitor.sCurThreadTime = mainThreadTimeMills;
                        LooperMonitor.sLastUpdateTime = uptimeMillis;
                        LooperMonitor.sCurMsgIndex = 0;
                        LooperMonitor.sLastUpdateTicks = j;
                    }
                }
            }
        });
        sCurThreadTime = mainThreadTimeMills();
        sLastUpdateTime = SystemClock.uptimeMillis();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式化第一处红色背景代码，在 Dispatching 阶段创建如下类型的 ScheduleMsgItem ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;long j2 = LooperMonitor.sAsyncAutoTick - LooperMonitor.sLastUpdateTicks
if (j2 &amp;lt;= 0) return;
if (j2 == 1) {
    if (LooperMonitor.sCurMsgIndex &amp;gt; 1) {
        SCHEDULE_TYPE_MSGS_IDLE
    } else {
        if (LooperMonitor.sCurMsgIndex == 1) {
            SCHEDULE_TYPE_MSG_IDLE
        } else {
            SCHEDULE_TYPE_IDLE
        }
    }
} else {
    if (LooperMonitor.sCurMsgIndex &amp;gt; 1) {
        SCHEDULE_TYPE_MSGS_LONG_IDLE
    } else {
        if (LooperMonitor.sCurMsgIndex == 1) {
            SCHEDULE_TYPE_MSG_LONG_IDLE
        } else {
            SCHEDULE_TYPE_LONG_IDLE
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式化第二处红色背景代码，在 Finished 阶段创建如下类型的 ScheduleMsgItem ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;long j2 = LooperMonitor.sAsyncAutoTick - LooperMonitor.sLastUpdateTicks
if (j2 &amp;lt;= 0) return;
if (j2 != 1 || LooperMonitor.sCurMsgIndex &amp;lt;= 1) {
    if (j2 == 1 &amp;amp;&amp;amp; LooperMonitor.sCurMsgIndex == 1) {
        SCHEDULE_TYPE_MSG
    } else {
        if (j2 &amp;lt;= 1 || LooperMonitor.sCurMsgIndex &amp;lt;= 1) {
            if (j2 &amp;lt;= 1 || LooperMonitor.sCurMsgIndex != 1) {
                SCHEDULE_TYPE_IDLE
            } else {
                SCHEDULE_TYPE_LONG_MSG
            }
        } else {
            SCHEDULE_TYPE_LAST_LONG_MSG
        }
    }
} else {
    SCHEDULE_TYPE_MSGS
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新整理下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;long j2 = LooperMonitor.sAsyncAutoTick - LooperMonitor.sLastUpdateTicks
if (j2 &amp;lt;= 0) return;
if (j2 == 1) {
    if (LooperMonitor.sCurMsgIndex &amp;gt; 1) {
        SCHEDULE_TYPE_MSGS
    } else {
        if (LooperMonitor.sCurMsgIndex == 1) {
            SCHEDULE_TYPE_MSG
        } else {
            SCHEDULE_TYPE_IDLE
        }
    }
} else {
    if (LooperMonitor.sCurMsgIndex &amp;gt; 1) {
        SCHEDULE_TYPE_LAST_LONG_MSG
    } else {
        if (LooperMonitor.sCurMsgIndex == 1) {
            SCHEDULE_TYPE_LONG_MSG
        } else {
            SCHEDULE_TYPE_IDLE
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单整理下 sCurMsgIndex 的逻辑：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通常情况下在 Dispatching 阶段置为1，在 Finished 阶段置为0。&lt;/li&gt;
  &lt;li&gt;在 Dispatching 阶段有个特殊的逻辑，如果在同一个 tick 周期内，sCurMsgIndex将会+1，即为消息聚合。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;autotick&quot;&gt;AutoTick&lt;/h1&gt;

&lt;p&gt;sTickTimeOut 的默认值是100，可以在 startMainLooperMonitor(int, int) 方法中进行设置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;static void startAsyncAutoTick() {
    HandlerThread defaultHandlerThread = NpthHandlerThread.getDefaultHandlerThread();
    sBaseElapsedTime = SystemClock.uptimeMillis();
    new Handler(defaultHandlerThread.getLooper()).postDelayed(new Runnable() { // from class: com.bytedance.crash.anr.LooperMonitor.4
        @Override // java.lang.Runnable
        public void run() {
            new Thread(&quot;npth-tick&quot;) { // from class: com.bytedance.crash.anr.LooperMonitor.4.1
                @Override // java.lang.Thread, java.lang.Runnable
                public void run() {
                    long j;
                    while (LooperMonitor.sMainLooperMonitor) {
                        try {
                            long uptimeMillis = SystemClock.uptimeMillis();
                            if (!ANRStatus.noRun()) {
                                LooperMonitor.sMainThreadCpuTime = LooperMonitor.mainThreadTimeMillsInner();
                            }
                            LooperMonitor.sAsyncAutoTick = (uptimeMillis - LooperMonitor.sBaseElapsedTime) / LooperMonitor.sTickTimeOut;
                            long j2 = (uptimeMillis - LooperMonitor.sBaseElapsedTime) % LooperMonitor.sTickTimeOut;
                            if (j2 &amp;gt;= 95) {
                                LooperMonitor.sAsyncAutoTick--;
                                j = LooperMonitor.sTickTimeOut &amp;lt;&amp;lt; 1;
                            } else {
                                j = LooperMonitor.sTickTimeOut;
                            }
                            SystemClock.sleep(j - j2);
                        } catch (Throwable unused) {
                        }
                    }
                    LooperMonitor.sStartAsyncAutoTick = false;
                }
            }.start();
        }
    }, sTickTimeOut);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sAsyncAutoTick 可以理解成在第 N 个 Tick 周期内，周期间隔为 sTickTimeOut 。&lt;/p&gt;

&lt;p&gt;简单整理下 sAsyncAutoTick 的逻辑：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;结合消息类型中的分析，其优点在于不需要计算每一条 Message 的耗时，即可找出耗时消息。&lt;/li&gt;
  &lt;li&gt;SystemClock.uptimeMillis() 返回的是不包含手机深度睡眠的启动时间，tick线程的主要逻辑就是规避手机深度睡眠的场景。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 30 Aug 2022 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/08/30/ANR%E6%B2%BB%E7%90%86-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%80%97%E6%97%B6%E6%B6%88%E6%81%AF%E7%BB%9F%E8%AE%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/08/30/ANR%E6%B2%BB%E7%90%86-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%80%97%E6%97%B6%E6%B6%88%E6%81%AF%E7%BB%9F%E8%AE%A1/</guid>
        
        <category>Android</category>
        
        <category>ANR</category>
        
        
      </item>
    
      <item>
        <title>ANR治理-Binder调用统计</title>
        <description>&lt;h1 id=&quot;1基于adb命令统计binder请求&quot;&gt;1.基于adb命令统计binder请求&lt;/h1&gt;

&lt;p&gt;可以通过adb shell am trace-ipc可以检测binder的调用次数。&lt;/p&gt;

&lt;p&gt;比如想知道下拉通知栏有哪些binder调用，先运行adb shell am trace-ipc start，下拉通知栏，在执行&lt;/p&gt;

&lt;p&gt;adb shell am trace-ipc stop –dump-file /data/local/tmp/systemui.trace，查看dump出来的文件：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Traces for process: com.android.systemui Count: 1 Trace: java.lang.Throwable at android.os.BinderProxy.transact(BinderProxy.java:486) at android.view.IWindowManager$Stub$Proxy.statusBarVisibilityChanged(IWindowManager.java:3795) at android.view.IWindowManagerCompat.statusBarVisibilityChanged(IWindowManagerCompat.java:50) at com.android.systemui.statusbar.phone.StatusBar.notifyUiVisibilityChanged(StatusBar.java:4867) at com.android.systemui.statusbar.phone.StatusBar.setSystemUiVisibility(StatusBar.java:4661) at com.android.systemui.statusbar.CommandQueue$H.handleMessage(CommandQueue.java:729) at android.os.Handler.dispatchMessage(Handler.java:107) at android.os.Looper.loop(Looper.java:221) at android.app.ActivityThread.main(ActivityThread.java:7520) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:539) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:950)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以看到统计的所有进程的binder调用堆栈和次数，接下来从源码中看下是如何统计的。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;处理”trace-ipc”命令&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityManagerShellCommand.java
int runTraceIpc(PrintWriter pw) throws RemoteException {
    String op = getNextArgRequired();
    if (op.equals(&quot;start&quot;)) {
        return runTraceIpcStart(pw);
    } else if (op.equals(&quot;stop&quot;)) {
        return runTraceIpcStop(pw);
    } else {
        getErrPrintWriter().println(&quot;Error: unknown trace ipc command &apos;&quot; + op + &quot;&apos;&quot;);
        return -1;
    }
}

int runTraceIpcStart(PrintWriter pw) throws RemoteException {
    pw.println(&quot;Starting IPC tracing.&quot;);
    pw.flush();
    mInterface.startBinderTracking();
    return 0;
}

int runTraceIpcStop(PrintWriter pw) throws RemoteException {
    final PrintWriter err = getErrPrintWriter();
    String opt;
    String filename = null;
    while ((opt=getNextOption()) != null) {
        if (opt.equals(&quot;--dump-file&quot;)) {
            filename = getNextArgRequired();
        } else {
            err.println(&quot;Error: Unknown option: &quot; + opt);
            return -1;
        }
    }
    if (filename == null) {
        err.println(&quot;Error: Specify filename to dump logs to.&quot;);
        return -1;
    }

    // Writes an error message to stderr on failure
    ParcelFileDescriptor fd = openFileForSystem(filename, &quot;w&quot;);
    if (fd == null) {
        return -1;
    }

    if (!mInterface.stopBinderTrackingAndDump(fd)) {
        err.println(&quot;STOP TRACE FAILED.&quot;);
        return -1;
    }

    pw.println(&quot;Stopped IPC tracing. Dumping logs to: &quot; + filename);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码可以看出”trace-ipc”命令有两个参数，分别为”start”和”stop”，分别对应开始统计和结束统计写入到文件，这里的mInterface是ActivityManagerService。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;AMS处理Binder统计&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityManagerService.java
public boolean startBinderTracking() throws RemoteException {
    ...
    synchronized (mProcLock) {
        mBinderTransactionTrackingEnabled = true;
        mProcessList.forEachLruProcessesLOSP(true, process -&amp;gt; {
            final IApplicationThread thread = process.getThread();
            if (!processSanityChecksLPr(process, thread)) {
                return;
            }
            try {
                thread.startBinderTracking();
            } catch (RemoteException e) {
                Log.v(TAG, &quot;Process disappared&quot;);
            }
        });
    }
    return true;
}

public boolean stopBinderTrackingAndDump(final ParcelFileDescriptor fd) throws RemoteException {
    ...
    boolean closeFd = true;
    try {
        synchronized (mProcLock) {
            if (fd == null) {
                throw new IllegalArgumentException(&quot;null fd&quot;);
            }
            mBinderTransactionTrackingEnabled = false;

            PrintWriter pw = new FastPrintWriter(new FileOutputStream(fd.getFileDescriptor()));
            pw.println(&quot;Binder transaction traces for all processes.\n&quot;);
            mProcessList.forEachLruProcessesLOSP(true, process -&amp;gt; {
                final IApplicationThread thread = process.getThread();
                if (!processSanityChecksLPr(process, thread)) {
                    return;
                }

                pw.println(&quot;Traces for process: &quot; + process.processName);
                pw.flush();
                try {
                    TransferPipe tp = new TransferPipe();
                    try {
                        thread.stopBinderTrackingAndDump(tp.getWriteFd());
                        tp.go(fd.getFileDescriptor());
                    } finally {
                        tp.kill();
                    }
                } catch (IOException e) {
                    pw.println(&quot;Failure while dumping IPC traces from &quot; + process +
                            &quot;.  Exception: &quot; + e);
                    pw.flush();
                } catch (RemoteException e) {
                    pw.println(&quot;Got a RemoteException while dumping IPC traces from &quot; +
                            process + &quot;.  Exception: &quot; + e);
                    pw.flush();
                }
            });
            closeFd = false;
            return true;
        }
    } finally {
        ...
    }
}

private boolean processSanityChecksLPr(ProcessRecord process, IApplicationThread thread) {
    if (process == null || thread == null) {
        return false;
    }

    return Build.IS_DEBUGGABLE || process.isDebuggable();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AMS中会遍历存活的进程，通过IApplicationThread通知应用执行startBinderTracking/stopBinderTrackingAndDump。此外，这个功能只在root版本或者应用是Debug版本上生效。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;应用处理binder统计&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
private void handleStartBinderTracking() {
    Binder.enableStackTracking();
}

private void handleStopBinderTrackingAndDump(ParcelFileDescriptor fd) {
    try {
        Binder.disableStackTracking();
        Binder.getTransactionTracker().writeTracesToFile(fd);
    } finally {
        IoUtils.closeQuietly(fd);
        Binder.getTransactionTracker().clearTraces();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用收到请求后会直接调用对应的Binder静态方法。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Binder类中的逻辑&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Binder.java
public static void enableStackTracking() {
    sStackTrackingEnabled = true;
}

public static void disableStackTracking() {
    sStackTrackingEnabled = false;
}

public synchronized static TransactionTracker getTransactionTracker() {
    if (sTransactionTracker == null)
        sTransactionTracker = new TransactionTracker();
    return sTransactionTracker;
}

public static boolean isStackTrackingEnabled() {
    return sStackTrackingEnabled;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当应用向服务端发起binder通信时，会执行到BinderProxy的transact方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// BinderProxy.java
public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
    Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);
    ...
    final boolean tracingEnabled = Binder.isStackTrackingEnabled();
    if (tracingEnabled) {
        final Throwable tr = new Throwable();
        Binder.getTransactionTracker().addTrace(tr);
        StackTraceElement stackTraceElement = tr.getStackTrace()[1];
        Trace.traceBegin(Trace.TRACE_TAG_ALWAYS,
                stackTraceElement.getClassName() + &quot;.&quot; + stackTraceElement.getMethodName());
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当tracingEnabled为true时，会抓取堆栈并记录到TransactionTracker中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// TransactionTracker.java
private Map&amp;lt;String, Long&amp;gt; mTraces;

private void resetTraces() {
    synchronized (this) {
        mTraces = new HashMap&amp;lt;String, Long&amp;gt;();
    }
}

public void addTrace(Throwable tr) {
    String trace = Log.getStackTraceString(tr);
    synchronized (this) {
        if (mTraces.containsKey(trace)) {
            mTraces.put(trace, mTraces.get(trace) + 1);
        } else {
            mTraces.put(trace, Long.valueOf(1));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;写入到文件&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt; // TransactionTracker.java
 public void writeTracesToFile(ParcelFileDescriptor fd) {
    if (mTraces.isEmpty()) {
        return;
    }

    PrintWriter pw = new FastPrintWriter(new FileOutputStream(fd.getFileDescriptor()));
    synchronized (this) {
        for (String trace : mTraces.keySet()) {
            pw.println(&quot;Count: &quot; + mTraces.get(trace));
            pw.println(&quot;Trace: &quot; + trace);
            pw.println();
        }
    }
    pw.flush();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;2基于binder接口统计binder请求&quot;&gt;2.基于Binder接口统计binder请求&lt;/h1&gt;

&lt;p&gt;在查看BinderProxy源码时，发现Binder提供了Binder.ProxyTransactListener接口，可以供应用侧统计binder调用信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
    Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);
    ...
    // Make sure the listener won&apos;t change while processing a transaction.
    final Binder.ProxyTransactListener transactListener = sTransactListener;
    Object session = null;

    if (transactListener != null) {
        final int origWorkSourceUid = Binder.getCallingWorkSourceUid();
        session = transactListener.onTransactStarted(this, code, flags);

        // Allow the listener to update the work source uid. We need to update the request
        // header if the uid is updated.
        final int updatedWorkSourceUid = Binder.getCallingWorkSourceUid();
        if (origWorkSourceUid != updatedWorkSourceUid) {
            data.replaceCallingWorkSourceUid(updatedWorkSourceUid);
        }
    }

    final AppOpsManager.PausedNotedAppOpsCollection prevCollection =
            AppOpsManager.pauseNotedAppOpsCollection();

    if ((flags &amp;amp; FLAG_ONEWAY) == 0 &amp;amp;&amp;amp; AppOpsManager.isListeningForOpNoted()) {
        flags |= FLAG_COLLECT_NOTED_APP_OPS;
    }

    try {
        final boolean result = transactNative(code, data, reply, flags);

        if (reply != null &amp;amp;&amp;amp; !warnOnBlocking) {
            reply.addFlags(Parcel.FLAG_IS_REPLY_FROM_BLOCKING_ALLOWED_OBJECT);
        }

        return result;
    } finally {
        AppOpsManager.resumeNotedAppOpsCollection(prevCollection);

        if (transactListener != null) {
            transactListener.onTransactEnded(session);
        }

        if (tracingEnabled) {
            Trace.traceEnd(Trace.TRACE_TAG_ALWAYS);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ProxyTransactListener接口提供了binder请求开始和结束的回调：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public interface ProxyTransactListener {
    /**
     * Called before onTransact.
     *
     * @return an object that will be passed back to {@link #onTransactEnded} (or null).,
     *
     * @hide
     */
    @Nullable
    default Object onTransactStarted(@NonNull IBinder binder, int transactionCode, int flags) {
        return onTransactStarted(binder, transactionCode);
    }

    /**
     * Called before onTransact.
     *
     * @return an object that will be passed back to {@link #onTransactEnded} (or null).
     */
    @Nullable
    Object onTransactStarted(@NonNull IBinder binder, int transactionCode);

    /**
     * Called after onTransact (even when an exception is thrown).
     *
     * @param session The object return by {@link #onTransactStarted}.
     */
    void onTransactEnded(@Nullable Object session);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用可以直接通过Binder的setProxyTransactListener方法来添加回调：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Binder.java
public static void setProxyTransactListener(@Nullable ProxyTransactListener listener) {
    BinderProxy.setTransactListener(listener);
}

// BinderProxy.java
public static void setTransactListener(@Nullable Binder.ProxyTransactListener listener) {
    sTransactListener = listener;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3基于binder接口统计binder应答&quot;&gt;3.基于Binder接口统计binder应答&lt;/h1&gt;

&lt;p&gt;以上两种方式统计的应用作为客户端向服务端发起的binder调用请求，如何统计应用作为服务端应答请求信息呢？&lt;/p&gt;

&lt;p&gt;在Binder类中提供了一个接口：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Binder.java
public static void setObserver(@Nullable BinderInternal.Observer observer) {
    sObserver = observer;
}

// BinderInternal.java
public interface Observer {
    /**
     * Called when a binder call starts.
     *
     * @return a CallSession to pass to the callEnded method.
     */
    CallSession callStarted(Binder binder, int code, int workSourceUid);

    /**
     * Called when a binder call stops.
     *
     * &amp;lt;li&amp;gt;This method will be called even when an exception is thrown by the binder stub
     * implementation.
     */
    void callEnded(CallSession s, int parcelRequestSize, int parcelReplySize,
            int workSourceUid);

    /**
     * Called if an exception is thrown while executing the binder transaction.
     *
     * &amp;lt;li&amp;gt;BinderCallsStats#callEnded will be called afterwards.
     * &amp;lt;li&amp;gt;Do not throw an exception in this method, it will swallow the original exception
     * thrown by the binder transaction.
     */
    public void callThrewException(CallSession s, Exception exception);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当服务端处理Binder请求时会调用到Binder类的execTransact方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private boolean execTransact(int code, long dataObj, long replyObj,
        int flags) {
    final int callingUid = Binder.getCallingUid();
    final long origWorkSource = ThreadLocalWorkSource.setUid(callingUid);
    try {
        return execTransactInternal(code, dataObj, replyObj, flags, callingUid);
    } finally {
        ThreadLocalWorkSource.restore(origWorkSource);
    }
}

private boolean execTransactInternal(int code, long dataObj, long replyObj, int flags,
        int callingUid) {
    // Make sure the observer won&apos;t change while processing a transaction.
    final BinderInternal.Observer observer = sObserver;
    final CallSession callSession =
            observer != null ? observer.callStarted(this, code, UNSET_WORKSOURCE) : null;
    Parcel data = Parcel.obtain(dataObj);
    Parcel reply = Parcel.obtain(replyObj);

    boolean res;
    final boolean tracingEnabled = Trace.isTagEnabled(Trace.TRACE_TAG_AIDL) &amp;amp;&amp;amp;
            (Binder.isStackTrackingEnabled() || Binder.isTracingEnabled(callingUid));
    try {
        final BinderCallHeavyHitterWatcher heavyHitterWatcher = sHeavyHitterWatcher;
        if (heavyHitterWatcher != null) {
            // Notify the heavy hitter watcher, if it&apos;s enabled.
            heavyHitterWatcher.onTransaction(callingUid, getClass(), code);
        }
        if (tracingEnabled) {
            Trace.traceBegin(Trace.TRACE_TAG_AIDL, getTransactionTraceName(code));
        }

        if ((flags &amp;amp; FLAG_COLLECT_NOTED_APP_OPS) != 0) {
            AppOpsManager.startNotedAppOpsCollection(callingUid);
            try {
                res = onTransact(code, data, reply, flags);
            } finally {
                AppOpsManager.finishNotedAppOpsCollection();
            }
        } else {
            res = onTransact(code, data, reply, flags);
        }
    } catch (RemoteException|RuntimeException e) {
        if (observer != null) {
            observer.callThrewException(callSession, e);
        }
        if (LOG_RUNTIME_EXCEPTION) {
            Log.w(TAG, &quot;Caught a RuntimeException from the binder stub implementation.&quot;, e);
        }
        if ((flags &amp;amp; FLAG_ONEWAY) != 0) {
            if (e instanceof RemoteException) {
                Log.w(TAG, &quot;Binder call failed.&quot;, e);
            } else {
                Log.w(TAG, &quot;Caught a RuntimeException from the binder stub implementation.&quot;, e);
            }
        } else {
            // Clear the parcel before writing the exception.
            reply.setDataSize(0);
            reply.setDataPosition(0);
            reply.writeException(e);
        }
        res = true;
    } finally {
        if (tracingEnabled) {
            Trace.traceEnd(Trace.TRACE_TAG_AIDL);
        }
        if (observer != null) {
            // The parcel RPC headers have been called during onTransact so we can now access
            // the worksource UID from the parcel.
            final int workSourceUid = sWorkSourceProvider.resolveWorkSourceUid(
                    data.readCallingWorkSourceUid());
            observer.callEnded(callSession, data.dataSize(), reply.dataSize(), workSourceUid);
        }

        checkParcel(this, code, reply, &quot;Unreasonably large binder reply buffer&quot;);
        reply.recycle();
        data.recycle();
    }

    StrictMode.clearGatheredViolations();
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Sat, 20 Aug 2022 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/08/20/ANR%E6%B2%BB%E7%90%86-Binder%E8%B0%83%E7%94%A8%E7%BB%9F%E8%AE%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/08/20/ANR%E6%B2%BB%E7%90%86-Binder%E8%B0%83%E7%94%A8%E7%BB%9F%E8%AE%A1/</guid>
        
        <category>Android</category>
        
        <category>ANR</category>
        
        <category>Binder</category>
        
        
      </item>
    
      <item>
        <title>Recovery机制介绍</title>
        <description>&lt;p&gt;2020年三星手机发生了一场严重事故，中国三星手机用户在5月23日这一天凌晨突然无限重启，事故原因是因SystemUI发生异常重复Crash导致手机进入Recovery界面，用户只能选择恢复出厂设置导致用户数据永久丢失。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/396666758/answer/1245994988&quot;&gt;怎么看待三星大量手机在今天（5.23）凌晨系统崩溃并数据丢失？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;知乎上已经有大佬详细分析了事故原因，本文重点介绍下为什么SystemUI频繁Crash会进入Recovery界面。&lt;/p&gt;

&lt;h1 id=&quot;1-resureparty功能初始化&quot;&gt;&lt;strong&gt;1. ResureParty功能初始化&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;ResureParty是一套系统自救机制，当监控到系统核心程序出现循环崩溃时，通过尝试一系列措施达到恢复设备正常运行的目的，直到所有措施都无济于事，则会进入Recovery界面让用户通过擦除数据的方式进行设备恢复。&lt;/p&gt;

&lt;p&gt;其初始化流程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Recovery/r1.png&quot; alt=&quot;r1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在SystemServer启动时，会初始化ResureParty机制。核心逻辑在PackageWatchDog，当应用发生异常退出时，PackageWatchDog会记录相关异常信息。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h1 id=&quot;2-systemui发生crash被系统重新拉起&quot;&gt;&lt;strong&gt;2. SystemUI发生Crash被系统重新拉起&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;SystemUI是常驻进程，当其发生异常退出时，系统会尝试重新启动，其流程图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Recovery/r2.png&quot; alt=&quot;r2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ActivityManagerService中收到应用死亡的回调后，会判断应用是否为系统常驻进程。如果应用是系统常驻进程，则会重新启动该进程。&lt;/p&gt;

&lt;h1 id=&quot;3-systemui频繁重启触发resureparty机制&quot;&gt;&lt;strong&gt;3. SystemUI频繁重启触发ResureParty机制&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;当SystemUI发生异常退出时，系统会重新启动SystemUI。但如果SystemUI的异常状态没有恢复，即重启后依然发生异常退出，则会陷入到异常退出-重启-异常退出-重启…这种循环崩溃的状态，此时就会触发ResureParty机制。&lt;/p&gt;

&lt;p&gt;触发ResureParty机制的流程图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Recovery/r3.png&quot; alt=&quot;r3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当应用异常退出后，会上报到PackageWatchDog，其onPackageFailureLocked方法中会判断当前应用是否为系统常驻进程，如果应用是系统常驻进程，则会更新mitigationCount，其对应的严重等级如下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;mitigationCount&lt;/th&gt;
      &lt;th&gt;严重等级&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;LEVEL_RESET_SETTINGS_UNTRUSTED_DEFAULTS&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;LEVEL_RESET_SETTINGS_UNTRUSTED_CHANGES&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;LEVEL_RESET_SETTINGS_TRUSTED_DEFAULTS&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;LEVEL_WARM_REBOOT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;LEVEL_FACTORY_RESET&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当达到严重等级达到LEVEL_FACTORY_RESET级别后，系统就会进入Recovery界面2&lt;/p&gt;
</description>
        <pubDate>Sun, 29 May 2022 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/05/29/Recovery%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/05/29/Recovery%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/</guid>
        
        <category>Android</category>
        
        <category>SystemUI</category>
        
        <category>Recovery</category>
        
        
      </item>
    
      <item>
        <title>Android源码编译mk转bp</title>
        <description>&lt;h3 id=&quot;1-基本概念介绍&quot;&gt;1. 基本概念介绍&lt;/h3&gt;

&lt;p&gt;自Android N开始，Google开始用Ninja来替代Makefile编译系统。编译时，会先把Android.mk通过kati转换成.ninja文件，然后使用ninja命令进行编译。&lt;/p&gt;

&lt;p&gt;Android.bp是替代Android.mk的配置文件，在Android O默认开启相关支持。编译时，由Soong解析转换成.ninja文件。&lt;/p&gt;

&lt;p&gt;Soong是为Android编译设计的工具，Blueprint和Soong都是由Golang写的项目，Blueprint解析文件的格式，而Soong解释内容的含义，bp即Blueprint的缩写。&lt;/p&gt;

&lt;p&gt;与Android.mk不同的是，Android.bp是纯粹的配置文件，不包含分支、循环等流程控制，也不能做算数、逻辑运算，需使用Golang编写控制逻辑。&lt;/p&gt;

&lt;p&gt;注意：Android.mk文件中的模块可以依赖Android.bp文件中的模块，但不能相反。&lt;/p&gt;

&lt;h3 id=&quot;2-androidbp文件格式&quot;&gt;2. Android.bp文件格式&lt;/h3&gt;

&lt;p&gt;Android.bp文件的语法和语义与Bazel BUILD文件类似，参考：&lt;a href=&quot;https://docs.bazel.build/versions/master/be/overview.html&quot;&gt;bazel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;模块：Android.bp文件中的模块以一个模块类型开始，后面跟着一组属性，以名值对(name: value)表示。每个模块必须有一个name属性，并且在所有的Android.bp文件中必须是唯一的。&lt;/p&gt;

&lt;p&gt;Globs：用于获取文件列表，可以包含普通的Unix通配符*，如”*.java”，还可以包含单个**通配符作为路径元素，它将匹配零个或多个路径元素。&lt;/p&gt;

&lt;p&gt;变量：Android.bp文件可以包含顶级变量并赋值。变量的范围被限定为它们声明的文件的剩余部分，以及任何子 blueprint 文件。一个例外是变量不可变，能够被 += 进行附加赋值，而且只能在被引用之前。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;gzip_srcs = [&quot;src/test/minigzip.c&quot;],
 
cc_binary {
    name: &quot;gzip&quot;,
    srcs: gzip_srcs,
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注释：Android.bp文件能包含C风格的多行/* */注释和C++风格的单行注释//。&lt;/p&gt;

&lt;p&gt;类型：变量和属性是强类型的，基于第一个赋值动态变量，以及模块类型静态属性。他们支持的类型有：布尔型（bool) 整型（int）字符串（string）字符串列表（”string1”, “string2”）Maps ({key1: “value1”, key2: [“value2”]})。&lt;/p&gt;

&lt;p&gt;Map 可以包含任意类型的值，包括嵌套的maps。列表和 maps 允许在最后一个值之后有逗号。&lt;/p&gt;

&lt;p&gt;操作符：字符串、字符串列表、和maps能使用+操作符进行附加。整型可以用+操作符来总结。附加的maps将生成两个map中键的并集，并附加的两个map中存在任何键的值。&lt;/p&gt;

&lt;p&gt;缺省模块：缺省模块可用于在多个模块中重复相同的属性。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;cc_defaults {
    name: &quot;gzip_defaults&quot;,
}
 
cc_binary {
    name: &quot;gzip&quot;,
    defaults: [&quot;gzip_defaults&quot;],
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;名称解析：Soong为不同目录中的模块提供了指定相同名称的能力。只要每个模块在一个单独的名称空间中声明。 命名空间可以这样声明：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;soong_namespace {
    imports: [&quot;path/to/otherNamespace1&quot;, &quot;path/to/otherNamespace2&quot;],
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每个Soong模块都会根据其在树中的位置分配一个名称空间，除非找不到soong_namespace模块，否则每个Soong模块都被认为位于当前目录或最接近的父目录中的Android.bp中的soong_namespace所定义的名称空间中。在这种情况下，该模块被认为处于隐式根目录命名空间。&lt;/p&gt;

&lt;p&gt;格式化：Soong 包含了一个 blueprint 文件的格式化器，类似于 gofmt。使用以下命令来递归格式化当前目录中的所有 Android.bp 文件：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;bpfmt -w .
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;标准格式包括 4 个空格的缩进，包含多个元素的列表中，每个元素之后的换行符，并且始终包括列表和 maps中的逗号。&lt;/p&gt;

&lt;h3 id=&quot;3-mk与bp对照&quot;&gt;3. mk与bp对照&lt;/h3&gt;

&lt;p&gt;参考：&lt;a href=&quot;https://android.googlesource.com/platform/build/soong/+/a930003/androidmk/cmd/androidmk/android.go&quot;&gt;android.go&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-go语言&quot;&gt;4. go语言&lt;/h3&gt;

&lt;p&gt;声明变量：var identifier type ，简短形式使用 := 赋值操作符&lt;/p&gt;

&lt;p&gt;声明常量：const identifier [type] = value&lt;/p&gt;

&lt;p&gt;声明数组：var variable_name [SIZE] variable_type&lt;/p&gt;

&lt;p&gt;指针：var var_name *var-type&lt;/p&gt;

&lt;p&gt;type关键字：定义结构体，定义接口，类型定义，类型别名，类型查询&lt;/p&gt;

&lt;p&gt;结构体：结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。也可以不包含任何字段，称为空结构体。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;type struct_variable_type struct {
   member definition;
   member definition;
   ...
   member definition;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接口：把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。也可以不带任何方法，成为空接口。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;type interface_name interface {
   method_name1 [return_type]
   method_name2 [return_type]
   method_name3 [return_type]
   ...
   method_namen [return_type]
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;切片(Slice)：是对数组的抽象，实现“动态数组”。append()用来将元素添加到切片末尾并返回结果。&lt;/p&gt;

&lt;p&gt;范围(Range)：用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对的 key 值。&lt;/p&gt;

&lt;p&gt;Map(集合)：可以使用内建函数 make 也可以使用 map 关键字来定义 Map&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;/* 声明变量，默认 map 是 nil */
var map_variable map[key_data_type]value_data_type
 
/* 使用 make 函数 */
map_variable := make(map[key_data_type]value_data_type)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;函数定义：不属于任何结构体、类型的方法。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;func function_name([parameter list]) [return_types] {
   函数体
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;方法定义：与函数区别的是，方法在定义的时候，会在func和方法名之间增加一个参数，这个参数就是接收者，这样我们定义的这个方法就和接收者绑定在了一起，称之为这个接收者的方法。&lt;/p&gt;

&lt;p&gt;init()函数：没有输入参数和返回值，用于包(package)的初始化，先于main()函数执行，不被其他函数调用，主要用于程序运行前的注册。&lt;/p&gt;

&lt;h3 id=&quot;5-添加逻辑控制&quot;&gt;5. 添加逻辑控制&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在bp中添加bluetoothext_defaults模块并指定go文件：&lt;/p&gt;

    &lt;p&gt;bootstrap_go_package {
    name: “soong-xxx”,
    pkgPath: “android/soong/xxx”,
    deps: [
    ],
    srcs: [
        “bluetoothext.go”,
    ],
    pluginFor: [“soong_build”],
}&lt;/p&gt;

    &lt;p&gt;// 定义模块
bluetoothext_defaults {
    name: “bluetoothext_defaults”,
}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里需要注意的是，bluetoothext_defaults是自定义的模块，bluetoothext.go配置这个模块包含了哪些内容，编译时需要在Android.bp中引用这个模块。&lt;/p&gt;

&lt;p&gt;2.编写go文件，定制bluetoothext_defaults模块的编译内容：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;package bluetoothext
 
import (
    &quot;android/soong/android&quot;
    &quot;android/soong/cc&quot;
)
 
func init() {
    // bluetoothext_defaults在Android.bp中定义
    android.RegisterModuleType(&quot;bluetoothext_defaults&quot;, bluetoothextDefaultsFactory)
}
 
...
 
func bluetoothextDefaultsFactory() android.Module {
    module := cc.DefaultsFactory()
    android.AddLoadHook(module, bluetoothextDefaults)
 
    return module
}
 
func bluetoothextDefaults(ctx android.LoadHookContext) {
    type props struct {
    //参考mk与bp对照
    }
 
    p := &amp;amp;props{}
    //定制模块内容
 
    ctx.AppendProperties(p)
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.引用自定义的bluetoothext_defaults模块：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// 编译模块中添加定义的模块
cc_library_shared {
    name: &quot;libbluetooth_jni&quot;,
    defaults: [&quot;bluetoothext_defaults&quot;]
    ...
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6-config常用方法&quot;&gt;6. config常用方法&lt;/h3&gt;

&lt;p&gt;参考：&lt;a href=&quot;https://android.googlesource.com/platform/build/soong/+/master/android/config.go&quot;&gt;config.go&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// 获取编译常量
func (c *config) Getenv(key string) string {}
func (c *config) GetenvWithDefault(key string, defaultValue string) string {}
 
// 判断常量值是否为true
func (c *config) IsEnvTrue(key string) bool {}
 
// 判断常量值是否为false
func (c *config) IsEnvFalse(key string) bool {}
 
// 获取机器名
func (c *config) DeviceName() string {}
 
// 获取Android版本名
func (c *config) PlatformVersionName() string {}
 
// 获取Android版本int值
func (c *config) PlatformSdkVersionInt() int {}
 
// 获取Android版本String值
func (c *config) PlatformSdkVersion() string {}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://android.googlesource.com/platform/build/soong&quot;&gt;soong&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/699cfa0f8a74&quot;&gt;Android soong 代码分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://note.qidong.name/2017/08/android-ninja/&quot;&gt;Android中的Ninja简介&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://note.qidong.name/2017/08/android-blueprint/&quot;&gt;Android编译系统中的Android.bp、Blueprint与Soong&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 08 May 2022 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/05/08/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91mk%E8%BD%ACbp/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/05/08/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91mk%E8%BD%ACbp/</guid>
        
        <category>Android</category>
        
        
      </item>
    
  </channel>
</rss>
