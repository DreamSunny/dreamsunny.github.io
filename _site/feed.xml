<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android学习笔记</title>
    <description>Android学习笔记</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 17 Aug 2023 12:52:39 +0800</pubDate>
    <lastBuildDate>Thu, 17 Aug 2023 12:52:39 +0800</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>Activity显示流程</title>
        <description>&lt;p&gt;在 &lt;a href=&quot;https://dreamsunny.github.io/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/&quot;&gt;Activity启动流程&lt;/a&gt; 中，我们知道了系统侧响应 Activity 启动请求会创建 Task ；&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&quot;https://dreamsunny.github.io/2022/12/24/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/&quot;&gt;DisplayArea树层级结构&lt;/a&gt;中，我们了解了 Task 最终会添加到 DefaultTaskDisplayArea ；&lt;/p&gt;

&lt;p&gt;本文主要梳理下Activity显示流程。&lt;/p&gt;

&lt;h1 id=&quot;1task添加到defaulttaskdisplayarea&quot;&gt;1.Task添加到DefaultTaskDisplayArea&lt;/h1&gt;

&lt;p&gt;调用堆栈如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/trace1.png&quot; alt=&quot;trace1&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// TaskDisplayArea.java
Task getOrCreateRootTask(..) {
    ...
    return new Task.Builder(mAtmService)
            ...
            .setParent(this)
            ...
            .build();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 setParent(this) 传入的是 TaskDisplayArea 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Task.java
Task build() {
    ...
    final Task task = buildInner();
    ...
    if (mParent != null) {
        if (mParent instanceof Task) {
            final Task parentTask = (Task) mParent;
            parentTask.addChild(task, mOnTop ? POSITION_TOP : POSITION_BOTTOM,
                    (mActivityInfo.flags &amp;amp; FLAG_SHOW_FOR_ALL_USERS) != 0);
        } else {
            mParent.addChild(task, mOnTop ? POSITION_TOP : POSITION_BOTTOM);
        }
    }
    ...
    return task;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Task.Builder的build() 方法中，将创建的task添加到 TaskDisplayArea。&lt;/p&gt;

&lt;h1 id=&quot;2activityrecord添加到task&quot;&gt;2.ActivityRecord添加到Task&lt;/h1&gt;

&lt;p&gt;调用堆栈如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/trace2.png&quot; alt=&quot;trace2&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建ActivityRecord：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityStarter.java
private int executeRequest(Request request) {
    ...
    final ActivityRecord r = new ActivityRecord.Builder(mService)
            ...
            .build();
    ...
}
// ActivityRecord.java
private ActivityRecord(..) {
    super(_service.mWindowManager, new Token(), TYPE_APPLICATION, true,
            null /* displayContent */, false /* ownerCanManageAppTokens */);
    ((Token) token).mActivityRef = new WeakReference&amp;lt;&amp;gt;(this);
}

private static class Token extends Binder {
    @NonNull WeakReference&amp;lt;ActivityRecord&amp;gt; mActivityRef;

    @Override
    public String toString() {
        return &quot;Token{&quot; + Integer.toHexString(System.identityHashCode(this)) + &quot; &quot;
                + mActivityRef.get() + &quot;}&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;添加到 Task 中：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityStarter.java
private void addOrReparentStartingActivity(@NonNull Task task, String reason) {
    ..
    TaskFragment newParent = task;
    ...
    if (mStartActivity.getTaskFragment() == null
            || mStartActivity.getTaskFragment() == newParent) {
        newParent.addChild(mStartActivity, POSITION_TOP);
    } else {
        mStartActivity.reparent(newParent, newParent.getChildCount() /* top */, reason);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;添加到 DisplayContent 的 mTokenMap 中：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowToken.java
void onDisplayChanged(DisplayContent dc) {
    dc.reParentWindowToken(this);
    super.onDisplayChanged(dc);
}
// DisplayContent.java
void reParentWindowToken(WindowToken token) {
    ...
    addWindowToken(token.token, token);
    ...
}

void addWindowToken(IBinder binder, WindowToken token) {
    ...
    mTokenMap.put(binder, token);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3activity窗口添加到wms&quot;&gt;3.Activity窗口添加到WMS&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_show.png&quot; alt=&quot;act_show&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;31-activitysetcontentview&quot;&gt;3.1 Activity.setContentView(..)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Activity.java
public void setContentView(@LayoutRes int layoutResID) {
    getWindow().setContentView(layoutResID);
    initWindowDecorActionBar();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activity.setContentView(..) 中直接调用 PhoneWindow.setContentView(..) 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// PhoneWindow.java
public void setContentView(int layoutResID) {
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        ...
    }

    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        ...
    } else {
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
    ...
}

private void installDecor() {
    mForceDecorInstall = false;
    if (mDecor == null) {
        mDecor = generateDecor(-1);
        ...
    } else {
        mDecor.setWindow(this);
    }
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor);
        ...
    }
}

protected DecorView generateDecor(int featureId) {
    ...
    return new DecorView(context, featureId, this, getAttributes());
}

protected ViewGroup generateLayout(DecorView decor) {
    ...
    int layoutResource;
    int features = getLocalFeatures();
    if ((features &amp;amp; ((1 &amp;lt;&amp;lt; FEATURE_LEFT_ICON) | (1 &amp;lt;&amp;lt; FEATURE_RIGHT_ICON))) != 0) {
        ..
    } else if ((features &amp;amp; ((1 &amp;lt;&amp;lt; FEATURE_PROGRESS) | (1 &amp;lt;&amp;lt; FEATURE_INDETERMINATE_PROGRESS))) != 0
        &amp;amp;&amp;amp; (features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_ACTION_BAR)) == 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_CUSTOM_TITLE)) != 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_NO_TITLE)) == 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) {
        ..
    } else {
        layoutResource = R.layout.screen_simple;
    }
    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);
    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
    ...
    return contentParent;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PhoneWindow.setContentView(..) 方法主要做3件事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建DecorView。&lt;/li&gt;
  &lt;li&gt;inflate Activity 根布局。&lt;/li&gt;
  &lt;li&gt;inflate Activity 视图布局（setContentView()传入的layoutResID）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中系统预置 Activity 根布局有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;feature&lt;/th&gt;
      &lt;th&gt;布局&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_LEFT_ICON&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_RIGHT_ICON&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_title_icons.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_PROGRESS&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_INDETERMINATE_PROGRESS&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_ACTION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_progress.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_CUSTOM_TITLE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_custom_title.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_NO_TITLE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_title.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_ACTION_MODE_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_simple_overlay_action_mode.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;else&lt;/td&gt;
      &lt;td&gt;screen_simple.xml&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以 screen_simple.xml 为例查看其布局：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// screen_simple.xml
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;
    android:orientation=&quot;vertical&quot;&amp;gt;
    &amp;lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot;
              android:inflatedId=&quot;@+id/action_mode_bar&quot;
              android:layout=&quot;@layout/action_mode_bar&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;wrap_content&quot;
              android:theme=&quot;?attr/actionBarTheme&quot; /&amp;gt;
    &amp;lt;FrameLayout
         android:id=&quot;@android:id/content&quot;
         android:layout_width=&quot;match_parent&quot;
         android:layout_height=&quot;match_parent&quot;
         android:foregroundInsidePadding=&quot;false&quot;
         android:foregroundGravity=&quot;fill_horizontal|top&quot;
         android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&amp;gt;
&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应整个 Activity 视图为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/decor.png&quot; alt=&quot;decor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终，Activity.setContentView(..) 传入的布局会添加到 FrameLayout(id=ID_ANDROID_CONTENT) 。&lt;/p&gt;

&lt;h2 id=&quot;32-viewrootimplsetview&quot;&gt;3.2 ViewRootImpl.setView(..)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ViewRootImpl.java
public ViewRootImpl(Context context, Display display) {
    this(context, display, WindowManagerGlobal.getWindowSession(),
            false /* useSfChoreographer */);
}

public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session) {
    this(context, display, session, false /* useSfChoreographer */);
}

public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session,
        boolean useSfChoreographer) {
    mWindowSession = session;
    mWindow = new W(this);
    ...
}

public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,
        int userId, Bundle bundle) {
    synchronized (this) {
        if (mView == null) {
            ...
            try {
                res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,
                        getHostVisibility(), mDisplay.getDisplayId(), userId,
                        mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,
                        mTempControls);
            } catch (RemoteException e) {
            } finally {
            }
            ...
        }
    }
}
// WindowManagerGlobal.java
public static IWindowSession getWindowSession() {
    synchronized (WindowManagerGlobal.class) {
        if (sWindowSession == null) {
            try {
                IWindowManager windowManager = getWindowManagerService();
                sWindowSession = windowManager.openSession(
                        new IWindowSessionCallback.Stub() {
                            @Override
                            public void onAnimatorScaleChanged(float scale) {
                                ValueAnimator.setDurationScale(scale);
                            }
                        });
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        return sWindowSession;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ViewRootImpl 是 View视图 与 WindowManager 的纽带，mIWindowSession、mWindow 为 Binder 对象，用于 APP 端与 WMS 之间的相互通信。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/win_binder.png&quot; alt=&quot;win_binder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里通过 IWindowSession.addToDisplayAsUser(..) 接口，请求WMS添加新窗口。&lt;/p&gt;

&lt;p&gt;此外，ViewRootImpl 管理整个 View 视图的绘制和 Input 事件分发。&lt;/p&gt;

&lt;h1 id=&quot;4wms添加窗口&quot;&gt;4.WMS添加窗口&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(Session session, IWindow client, LayoutParams attrs, ..) {
    WindowState parentWindow = null;
    final int type = attrs.type;
    synchronized (mGlobalLock) {
        final DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token);
        
        if (type &amp;gt;= FIRST_SUB_WINDOW &amp;amp;&amp;amp; type &amp;lt;= LAST_SUB_WINDOW) {
            parentWindow = windowForClientLocked(null, attrs.token, false);
            ...
        }

        ActivityRecord activity = null;
        final boolean hasParent = parentWindow != null;
        WindowToken token = displayContent.getWindowToken(
                hasParent ? parentWindow.mAttrs.token : attrs.token);
        final int rootType = hasParent ? parentWindow.mAttrs.type : type;

        if (token == null) {
            ...
        } else if (rootType &amp;gt;= FIRST_APPLICATION_WINDOW
                &amp;amp;&amp;amp; rootType &amp;lt;= LAST_APPLICATION_WINDOW) {
            activity = token.asActivityRecord();
            ...
        } else if (rootType == TYPE_INPUT_METHOD) {
            ...
        } else if (rootType == TYPE_VOICE_INTERACTION) {
            ...
        } else if (rootType == TYPE_WALLPAPER) {
            ...
        } else if (rootType == TYPE_ACCESSIBILITY_OVERLAY) {
            ...
        } else if (type == TYPE_TOAST) {
            ...
        } else if (type == TYPE_QS_DIALOG) {
            ...
        } else if (token.asActivityRecord() != null) {
            ...
        }

        final WindowState win = new WindowState(this, session, client, token, parentWindow,
                appOp[0], attrs, viewVisibility, session.mUid, userId,
                session.mCanAddInternalSystemWindow);
        win.attach();
        mWindowMap.put(client.asBinder(), win);
        win.mToken.addWindow(win);

        if (type == TYPE_APPLICATION_STARTING &amp;amp;&amp;amp; activity != null) {
            activity.attachStartingWindow(win);
        } else if (type == TYPE_INPUT_METHOD
            ...
        } else if (type == TYPE_INPUT_METHOD_DIALOG) {
            ...
        } else {
            ...
        }
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;41-创建windowstate&quot;&gt;4.1 创建WindowState&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    WindowToken token = displayContent.getWindowToken(
            hasParent ? parentWindow.mAttrs.token : attrs.token);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里传入的 token 是在创建 ActivityRecord 时创建的 Binder 对象（见上文2），获取到的 WindowToken 为 ActivityRecord 对象。&lt;/p&gt;

&lt;p&gt;WMS每一个新窗口都会对应创建一个 WindowState 对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    final WindowState win = new WindowState(this, session, client, token, parentWindow,
            appOp[0], attrs, viewVisibility, session.mUid, userId,
            session.mCanAddInternalSystemWindow);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以 Activity 页面弹出一个Dialog对话框为例，WindowToken 与 WindowState 的关系为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/win_token.png&quot; alt=&quot;win_token&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;42-创建surfacesession&quot;&gt;4.2 创建SurfaceSession&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    synchronized (mGlobalLock) {
        ...
        final WindowState win = new WindowState(...);
        win.attach();
        ...
    }
    return res;
}

// WindowState.java
void attach() {
    mSession.windowAddedLocked();
}

// Session.java
void windowAddedLocked() {
    ...
    if (mSurfaceSession == null) {
        mSurfaceSession = new SurfaceSession();
        ...
    }
}

// SurfaceSession.java
/** Create a new connection with the surface flinger. */
@UnsupportedAppUsage
public SurfaceSession() {
    mNativeClient = nativeCreate();
}

// android_view_SurfaceSession.cpp
static jlong nativeCreate(JNIEnv* env, jclass clazz) {
    SurfaceComposerClient* client = new SurfaceComposerClient();
    client-&amp;gt;incStrong((void*)nativeCreate);
    return reinterpret_cast&amp;lt;jlong&amp;gt;(client);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SurfaceSession 构造方法中通过 nativeCreate() 方法返回了一个 SurfaceComposerClient 指针，它表示一个跟 SurfaceFlinger 的连接，当其第一次被使用时会调用 onFirstRef() 方法，创建一个实现 ISurfaceComposerClient 接口的 Client 对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// SurfaceComposerClient.cpp
void SurfaceComposerClient::onFirstRef() {
    sp&amp;lt;ISurfaceComposer&amp;gt; sf(ComposerService::getComposerService());
    if (sf != nullptr &amp;amp;&amp;amp; mStatus == NO_INIT) {
        sp&amp;lt;ISurfaceComposerClient&amp;gt; conn;
        conn = sf-&amp;gt;createConnection();
        if (conn != nullptr) {
            mClient = conn;
            mStatus = NO_ERROR;
        }
    }
}

// SurfaceFlinger.cpp
sp&amp;lt;ISurfaceComposerClient&amp;gt; SurfaceFlinger::createConnection() {
    const sp&amp;lt;Client&amp;gt; client = new Client(this);
    return client-&amp;gt;initCheck() == NO_ERROR ? client : nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WMS 创建了一个 WindowState 对象表示客户端的一个 Window，接着调用 WindowState.attach() 方法创建了一个 SurfaceSession 对象，SurfaceSession 表示一个跟 SurfaceFlinger 的连接，它创建了一个 SurfaceComposerClient 对象，然后 SurfaceFlinger 又创建了一个 Client 对象。&lt;/p&gt;

&lt;h2 id=&quot;43-windowstate添加到activityrecord&quot;&gt;4.3 WindowState添加到ActivityRecord&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    final WindowState win = new WindowState(.., token, ..);
    ...
    win.mToken.addWindow(win);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;5应用绘制&quot;&gt;5.应用绘制&lt;/h1&gt;

&lt;h2 id=&quot;51-创建surface&quot;&gt;5.1 创建Surface&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ViewRootImpl.java
public final Surface mSurface = new Surface();
private final SurfaceControl mSurfaceControl = new SurfaceControl();
private BLASTBufferQueue mBlastBufferQueue;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建 ViewRootImp 实例时，会创建一个空的 Surface 和 SurfaceControl 对象，其初始化流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ViewRootImpl$TraversalRunnable.run(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.doTraversal(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.performTraversals(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.relayoutWindow(..)&lt;/li&gt;
  &lt;li&gt;Session.relayout(.., mSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowManagerService.relayoutWindow(.., outSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowManagerService.createSurfaceControl(outSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowStateAnimator.createSurfaceLocked()&lt;/li&gt;
  &lt;li&gt;new WindowSurfaceController(..)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.Builder.build()&lt;/li&gt;
  &lt;li&gt;new SurfaceControl(..)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.nativeCreate(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// android_view_SurfaceControl.cpp
static jlong nativeCreate(..) {
    sp&amp;lt;SurfaceComposerClient&amp;gt; client;
    if (sessionObj != NULL) {
        client = android_view_SurfaceSession_getClient(env, sessionObj);
    } else {
        client = SurfaceComposerClient::getDefault();
    }

    sp&amp;lt;SurfaceControl&amp;gt; surface;
    status_t err = client-&amp;gt;createSurfaceChecked(String8(name.c_str()), w, h, format, &amp;amp;surface,
                                                flags, parentHandle, std::move(metadata));
    surface-&amp;gt;incStrong((void *)nativeCreate);
    return reinterpret_cast&amp;lt;jlong&amp;gt;(surface.get());
}

// SurfaceComposerClient.cpp 
status_t SurfaceComposerClient::createSurfaceChecked(..) {
    status_t err = mStatus;

    if (mStatus == NO_ERROR) {
        sp&amp;lt;IBinder&amp;gt; handle;
        sp&amp;lt;IGraphicBufferProducer&amp;gt; gbp;

        err = mClient-&amp;gt;createSurface(name, w, h, format, flags, parentHandle, std::move(metadata),
                                     &amp;amp;handle, &amp;amp;gbp, &amp;amp;id, &amp;amp;transformHint);

        if (err == NO_ERROR) {
            *outSurface =
                    new SurfaceControl(this, handle, gbp, id, w, h, format, transformHint, flags);
        }
    }
    return err;
}

// surfaceflinger/Client.cpp
status_t Client::createSurface(..) {
    LayerCreationArgs args(mFlinger.get(), this, name.c_str(), flags, std::move(metadata));
    return mFlinger-&amp;gt;createLayer(args, outHandle, parentHandle, outLayerId, nullptr,
                                 outTransformHint);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;WindowSurfaceController.getSurfaceControl(outSurfaceControl)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.copyFrom(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;outSurfaceControl.copyFrom(mSurfaceControl, &quot;WindowSurfaceController.getSurfaceControl&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;SurfaceControl.nativeCopyFromSurfaceControl(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.updateBlastSurfaceIfNeeded()&lt;/li&gt;
  &lt;li&gt;new BLASTBufferQueue(mTag, mSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;BLASTBufferQueue.createSurface()&lt;/li&gt;
  &lt;li&gt;BLASTBufferQueue.nativeGetSurface(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// android_graphics_BLASTBufferQueue.cpp
static jobject nativeGetSurface(JNIEnv* env, jclass clazz, jlong ptr,
                                jboolean includeSurfaceControlHandle) {
    sp&amp;lt;BLASTBufferQueue&amp;gt; queue = reinterpret_cast&amp;lt;BLASTBufferQueue*&amp;gt;(ptr);
    return android_view_Surface_createFromSurface(env,
                                                  queue-&amp;gt;getSurface(includeSurfaceControlHandle));
}

// BLASTBufferQueue.cpp
sp&amp;lt;Surface&amp;gt; BLASTBufferQueue::getSurface(bool includeSurfaceControlHandle) {
    std::unique_lock _lock{mMutex};
    sp&amp;lt;IBinder&amp;gt; scHandle = nullptr;
    if (includeSurfaceControlHandle &amp;amp;&amp;amp; mSurfaceControl) {
        scHandle = mSurfaceControl-&amp;gt;getHandle();
    }
    return new BBQSurface(mProducer, true, scHandle, this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;Surface.transferFrom(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;mSurface.transferFrom(blastSurface);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;Surface.setNativeObjectLocked(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 Java 层中 ViewRootImpl 实例中持有一个 Surface 对象，该 Surface 对象中的 mNativeObject 属性指向 native 层中创建的 Surface 对象，native 层的 Surface 对应 SurfaceFlinger 中的 Layer 对象，它持有 Layer 中的 BufferQueueProducer 生产者指针，在 Surface 上绘制的内容最终会交由 SurfaceFlinger 来合成渲染送到显示器显示。&lt;/p&gt;

&lt;h2 id=&quot;52-view绘制构建阶段&quot;&gt;5.2 View绘制：构建阶段&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw1.png&quot; alt=&quot;view_draw1&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Choreographer.java

private final class FrameDisplayEventReceiver extends DisplayEventReceiver
        implements Runnable {

    @Override
    public void onVsync(..) {
        try {
            ...
            Message msg = Message.obtain(mHandler, this);
            msg.setAsynchronous(true);
            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
        } finally {
        }
    }

    @Override
    public void run() {
        doFrame(mTimestampNanos, mFrame, mLastVsyncEventData);
    }
}

void doFrame(..) {
    try {
        ...
        doCallbacks(Choreographer.CALLBACK_INPUT, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameData, frameIntervalNanos);
    } finally {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Choreographer中收到Vsync信号后，向主线程MessageQueue发送一条异步Message，当异步Message执行后会调用其doFrame(..)方法，依次执行 INPUT、ANIMATION、INSETS_ANIMATION、TRAVERSAL、COMMIT 回调。&lt;/p&gt;

&lt;p&gt;在 TRAVERSAL 回调中会执行 mTraversalRunnable ，其 run() 方法中调用 doTraversal() 方法，执行 performTraversals() 方法，接着依次执行 View 的 measure、layout、draw 流程的代码。&lt;/p&gt;

&lt;h2 id=&quot;53-view绘制渲染阶段&quot;&gt;5.3 View绘制：渲染阶段&lt;/h2&gt;

&lt;p&gt;RenderThread线程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw2.png&quot; alt=&quot;view_draw2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;渲染方式：软件绘制（CPU） VS 硬件绘制（GPU）&lt;/p&gt;

&lt;p&gt;渲染引擎：OpenGL VS Vulkan&lt;/p&gt;

&lt;h2 id=&quot;54-surfaceflinger合成显示&quot;&gt;5.4 SurfaceFlinger：合成显示&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw3.png&quot; alt=&quot;view_draw3&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;6小结&quot;&gt;6.小结&lt;/h1&gt;

&lt;p&gt;应用侧 Window 是一个抽象概念，用来描述顶层视图的外观和行为，唯一的实现类是 PhoneWindow。&lt;/p&gt;

&lt;p&gt;在创建 Activity / Dialog 时，会创建 PhoneWindow ，同时会创建 DecorView 。&lt;/p&gt;

&lt;p&gt;应用侧向WMS请求添加视图时，会创建ViewRootImpl，同时会创建 Surface，视图绘制的数据会写入  Surface，由 SurfaceFlinger 合成显示。&lt;/p&gt;

&lt;p&gt;WMS添加应用侧视图时会创建 WindowState 用来对应一个 Window，同时维护 Window 的 Z-Order 。&lt;/p&gt;

&lt;h1 id=&quot;7参考文档&quot;&gt;7.参考文档&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.simowce.com/all-about-blastbbq/&quot;&gt;BLASTBufferQueue 详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/50a30fa6952e&quot;&gt;BBQ 机制介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/cdc60627df90&quot;&gt;BBQ 原理解读&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/384a5cd2e304&quot;&gt;BBQ 运用场景&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/19/Activity%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/19/Activity%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>Activity</category>
        
        
      </item>
    
      <item>
        <title>Activity启动流程</title>
        <description>&lt;h1 id=&quot;1activity官方文档&quot;&gt;1.Activity官方文档&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/components/activities/intro-activities?hl=zh-cn&quot;&gt;Activity 简介&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle?hl=zh-cn&quot;&gt;Activity 生命周期&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/topics/manifest/activity-element?hl=zh-cn&quot;&gt;应用清单&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;2activity启动流程&quot;&gt;2.Activity启动流程&lt;/h1&gt;

&lt;p&gt;在桌面点击时钟图标打开闹钟应用，使用系统跟踪抓取 trace 文件，在 &lt;a href=&quot;https://ui.perfetto.dev/&quot;&gt;perfetto&lt;/a&gt; 打开查看：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/startActivity.perfetto-trace&quot;&gt;startActivity.perfetto-trace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_start.png&quot; alt=&quot;act_start&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了让整个过程可视化，对系统侧相关类做了代码插桩，在进入/退出方法处加上Trace日志：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/startActivityinjected.perfetto-trace&quot;&gt;startActivityinjected.perfetto-trace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在此基础上需要掌握调试安卓Framework源码 ，再结合trace来学习源码。&lt;/p&gt;

&lt;h2 id=&quot;21-点击应用图标&quot;&gt;2.1 点击应用图标&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;InputReader 负责从 EventHub 里面把 Input 事件读取出来，然后交给 InputDispatcher 进行事件分发。&lt;/li&gt;
  &lt;li&gt;InputDispatcher 在拿到 InputReader 获取的事件后对 Input 事件进行包装，然后寻找并分发到目标窗口。&lt;/li&gt;
  &lt;li&gt;InboundQueue（iq）队列中放着 InputDispatcher 从 InputReader 中拿到的 Input 事件。&lt;/li&gt;
  &lt;li&gt;OutboundQueue（oq）队列里面放的是即将要被派发给各个目标窗口的 Input 事件。&lt;/li&gt;
  &lt;li&gt;WaitQueue（wq）队列里面记录的是已经派发给目标窗口等待其处理完的 Input 事件。&lt;/li&gt;
  &lt;li&gt;PendingInputEventQueue（aq）队列中记录的是应用需要处理的 Input 事件。&lt;/li&gt;
  &lt;li&gt;deliverInputEvent 标识 App UI Thread 被 Input 事件唤醒。&lt;/li&gt;
  &lt;li&gt;App 响应处理 Input 事件，内部会在其界面 View 树中传递处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;22-启动闹钟应用&quot;&gt;2.2 启动闹钟应用&lt;/h2&gt;

&lt;h3 id=&quot;221-桌面请求启动闹钟应用&quot;&gt;2.2.1 桌面请求启动闹钟应用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Activity.startActivityForResult(..)&lt;/li&gt;
  &lt;li&gt;Instrumentation.execStartActivity(..)&lt;/li&gt;
  &lt;li&gt;ActivityTaskManager.&lt;em&gt;getService&lt;/em&gt;().startActivity(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private static final Singleton&amp;lt;IActivityTaskManager&amp;gt; IActivityTaskManagerSingleton =
        new Singleton&amp;lt;IActivityTaskManager&amp;gt;() {
            @Override
            protected IActivityTaskManager create() {
                final IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);
                return IActivityTaskManager.Stub.asInterface(b);
            }
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;222-系统侧处理请求&quot;&gt;2.2.2 系统侧处理请求&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/atms_start_act.png&quot; alt=&quot;atms_start_act&quot; /&gt;&lt;/p&gt;

&lt;p&gt;核心逻辑从ActivityStarter.execute()方法开始：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. ActivityStarter$Request.resolveActivity(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;解析 ResolveInfo 和 ActivityInfo，最终调用到 ComputerEngine.queryIntentActivitiesInternal(..)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/resolve_act.png&quot; alt=&quot;resolve_act&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有个细节是处理 显式启动 与 隐式启动 的区别：&lt;a href=&quot;https://developer.android.com/guide/components/intents-filters?hl=zh-cn&quot;&gt;Intent 和 Intent 过滤器&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;queryIntentActivitiesInternal(..) {
    ComponentName comp = intent.getComponent();
    if (comp != null) {
        getActivityInfo(..)
    } else {
        queryIntentActivitiesInternalBody(..)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. ActivityStarter.executeRequest()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.1 权限检查&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.1 启动权限检查：ActivityTaskSupervisor.checkStartAnyActivityPermission(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;应用AndroidManifest.xml配置项：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;android:exported&lt;/th&gt;
      &lt;th&gt;activity 是否可由其他应用的组件启动。&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;android:permission&lt;/td&gt;
      &lt;td&gt;启动 activity 或以其他方式使 activity 响应 intent 时，客户端必须具备的权限的名称。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;2.1.2 允许后台启动检查：ActivityStarter.shouldAbortBackgroundActivityStart(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;详见 &lt;a href=&quot;https://developer.android.com/guide/components/activities/background-starts?hl=zh-cn&quot;&gt;从后台启动 Activity 的限制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.2 创建ActivityRecord&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Activity 的实例是在应用侧创建的，系统侧会创建 ActivityRecord 与之对应，用来存储 Activity 的相关信息。&lt;/p&gt;

&lt;p&gt;相关文档：&lt;a href=&quot;http://gityuan.com/2017/06/11/activity_record/&quot;&gt;四大组件之ActivityRecord&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.3 ActivityStarter#startActivityUnchecked&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.1 ActivityTaskManagerService.deferWindowLayout(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;延迟当前进行的布局，因为页面即将要刷新，继续进行布局没有意义，与 continueWindowLayout() 成对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.2 ActivityStarter.startActivityInner(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这部分的核心逻辑围绕 &lt;a href=&quot;https://developer.android.com/guide/components/activities/tasks-and-back-stack?hl=zh-cn&quot;&gt;任务和返回堆栈 &lt;/a&gt;内容展开：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Task（任务）是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Task（任务）是一个整体单元，当用户开始一个新任务或通过主屏幕按钮进入主屏幕时，任务可移至“后台”。“后台”任务可重新返回到“前台”，以便用户可以从他们离开的地方继续操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了更直观地理解这部分内容，写了一个示例应用：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/activityLaunchMode.apk&quot;&gt;activityLaunchMode.apk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.ActivityStarter#setInitialState&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act1.png&quot; alt=&quot;act1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.ActivityStarter#computeLaunchingTaskFlags&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act2.png&quot; alt=&quot;act2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要判断是否添加 &lt;a href=&quot;https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_NEW_TASK&quot;&gt;FLAG_ACTIVITY_NEW_TASK&lt;/a&gt; 属性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.计算4个task&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Get top task at beginning because the order may be changed when reusing existing task.
final Task prevTopRootTask = mPreferredTaskDisplayArea.getFocusedRootTask();
final Task prevTopTask = prevTopRootTask != null ? prevTopRootTask.getTopLeafTask() : null;
final Task reusedTask = getReusableTask();
final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act3.png&quot; alt=&quot;act3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要逻辑是查找是否存在Activity可复用的Task。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.ActivityStarter#isAllowedToStart&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act4.png&quot; alt=&quot;act4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于 targetTask 再次判断 Activity 是否允许启动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.ActivityStarter#recycleTask&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final boolean newTask = targetTask == null;
final ActivityRecord targetTaskTop = newTask
        ? null : targetTask.getTopNonFinishingActivity();
if (targetTaskTop != null) {
    recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);
} else {
    mAddingToTask = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复用targetTask，从桌面点击应用图标启动应用，targetTask 为 null，不会走 recycleTask() 逻辑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.ActivityStarter#getOrCreateRootTask&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act5.png&quot; alt=&quot;act5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里会创建 RootTask（截图中选中位置）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.ActivityStarter#setNewTask&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (newTask) {
    final Task taskToAffiliate = (mLaunchTaskBehind &amp;amp;&amp;amp; mSourceRecord != null)
            ? mSourceRecord.getTask() : null;
    setNewTask(taskToAffiliate);
} else if (mAddingToTask) {
    addOrReparentStartingActivity(targetTask, &quot;adding to task&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act6.png&quot; alt=&quot;act6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;调用 Task.reuseOrCreateTask(..) 复用或者创建 Task（截图中选中位置），这里会复用刚才创建的 RootTask。&lt;/p&gt;

&lt;p&gt;这里还有一个逻辑是 ActivityStarter#addOrReparentStartingActivity ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (mStartActivity.getTaskFragment() == null
        || mStartActivity.getTaskFragment() == newParent) {
    newParent.addChild(mStartActivity, POSITION_TOP);
} else {
    mStartActivity.reparent(newParent, newParent.getChildCount() /* top */, reason);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mStartActivity 是 ActivityRecord，newParent 是 Task，将ActivityRecord添加到Task中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.Task#moveToFront&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act7.png&quot; alt=&quot;act7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里是将 mTargetRootTask 移至“前台”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.Task#startActivityLocked&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act8.png&quot; alt=&quot;act8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有个应用启动优化项：StartingWindow。&lt;/p&gt;

&lt;p&gt;相关介绍文档：&lt;a href=&quot;https://androidperformance.com/2018/05/20/zhihu-startingwindow/#/StartingWindow-对用户体验的影响&quot;&gt;知乎 救救你的 StartingWindow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10.RootWindowContainer#resumeFocusedTasksTopActivities&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act9.png&quot; alt=&quot;act9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前面已经把 mTargetRootTask 移至“前台”，这里是把 mStartActivity 移至“前台”，主要逻辑在TaskFragment#resumeTopActivity。&lt;/p&gt;

&lt;p&gt;在目标 Activity 显示出来之前，需要把 RootTask 中其他 Activities 暂停：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act10.png&quot; alt=&quot;act10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终会调用到 TaskFragment#schedulePauseActivity （截图中选中位置）通知桌面暂停Launcher，详见 2.2.3。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;void schedulePauseActivity(..) {
    mAtmService.getLifecycleManager().scheduleTransaction(prev.app.getThread(),
            prev.token, PauseActivityItem.obtain(..));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来会判断应用进程是否存在，如果不存在先创建应用进程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;boolean pausing = !deferPause &amp;amp;&amp;amp; taskDisplayArea.pauseBackTasks(next);
if (pausing) {
    if (next.attachedToProcess()) {
        //应用进程存在
        next.app.updateProcessInfo(..);
    } else if (!next.isProcessRunning()) {
        //应用进程不存在，创建进程
        mAtmService.startProcessAsync(..);
    }
} else if (mResumedActivity == next &amp;amp;&amp;amp; next.isState(RESUMED)
        &amp;amp;&amp;amp; taskDisplayArea.allResumedActivitiesComplete()) {
    //执行过渡动画
    executeAppTransition(options);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里闹钟进程不存在，会请求 Zygote 创建闹钟进程，详见 2.3。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.3 ActivityTaskManagerService.continueWindowLayout(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与上文 deferWindowLayout(..) 成对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.4 ActivityStarter.postStartActivityProcessing(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ActivityStartInterceptor 回调监听者 onActivityLaunched(..)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (ActivityManager.isStartResultSuccessful(result)) {
    mInterceptor.onActivityLaunched(targetTask.getTaskInfo(), r);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;223-桌面activitypause&quot;&gt;2.2.3 桌面activityPause&lt;/h3&gt;

&lt;p&gt;桌面收到系统侧 activityPause 通知，处理完后再通知系统侧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_pause1.png&quot; alt=&quot;act_pause1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统侧收到桌面 activityPause 通知：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_pause2.png&quot; alt=&quot;act_pause2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;startSpecificActivity(..) 有多个入口，当应用进程创建完执行 attachApplication 后，才会执行 realStartActivityLocked(..)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final WindowProcessController wpc = mService.getProcessController(..);
if (wpc != null &amp;amp;&amp;amp; wpc.hasThread()) {
    realStartActivityLocked(r, wpc, andResume, checkConfig);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 realStartActivityLocked(..) 中会通知应用侧执行 Activity 生命周期回调，详见 2.5：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final ClientTransaction clientTransaction = ClientTransaction.obtain(..);
clientTransaction.addCallback(LaunchActivityItem.obtain(..));
clientTransaction.setLifecycleStateRequest(ResumeActivityItem.obtain(..));
mService.getLifecycleManager().scheduleTransaction(clientTransaction);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;224-桌面activitystop&quot;&gt;2.2.4 桌面activityStop&lt;/h3&gt;

&lt;p&gt;上接 2.2.3，在显示出 Activity 前会执行 AppTransition 过渡动画：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_stop1.png&quot; alt=&quot;act_stop1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过渡动画执行完后，会通知桌面执行activityStop：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_stop2.png&quot; alt=&quot;act_stop2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结下两个应用 Activity 生命周期：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;桌面 Launcher 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onPause()&lt;/code&gt; 方法执行。&lt;/li&gt;
  &lt;li&gt;闹钟 DeskClockTabActivity 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStart()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onResume()&lt;/code&gt; 方法依次执行（闹钟 DeskClockTabActivity 现在具有用户焦点）。&lt;/li&gt;
  &lt;li&gt;桌面 Launcher 在屏幕上不再显示，其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStop()&lt;/code&gt; 方法执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;23-创建闹钟进程&quot;&gt;2.3 创建闹钟进程&lt;/h2&gt;

&lt;h3 id=&quot;231-系统侧请求创建闹钟进程&quot;&gt;2.3.1 系统侧请求创建闹钟进程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityManagerService.startProcess(..)&lt;/li&gt;
  &lt;li&gt;ActivityManagerService.startProcessLocked(..)&lt;/li&gt;
  &lt;li&gt;ProcessList.startProcessLocked(..)&lt;/li&gt;
  &lt;li&gt;ProcessList.startProcess(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (hostingRecord.usesWebviewZygote()) {
    WebViewZygote.getProcess().start(..)
} else if (hostingRecord.usesAppZygote()) {
    // see FLAG_USE_APP_ZYGOTE
    appZygote.getProcess().start(..)
} else {
    Process.start(..);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;ZYGOTE_PROCESS.start(..)&lt;/li&gt;
  &lt;li&gt;ZYGOTE_PROCESS.startViaZygote(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;static ZygoteState connect(@NonNull LocalSocketAddress zygoteSocketAddress,
        @Nullable LocalSocketAddress usapSocketAddress)
        throws IOException {

    final LocalSocket zygoteSessionSocket = new LocalSocket();

    try {
        zygoteSessionSocket.connect(zygoteSocketAddress);
    } catch (IOException ex) {
    }
    
    return new ZygoteState(..)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;ZYGOTE_PROCESS.zygoteSendArgsAndGetResult(..)&lt;/li&gt;
  &lt;li&gt;ZYGOTE_PROCESS.attemptZygoteSendArgsAndGetResult(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private Process.ProcessStartResult attemptZygoteSendArgsAndGetResult(
        ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx {
    try {
        final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;
        final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;

        zygoteWriter.write(msgStr);
        zygoteWriter.flush();

        // Always read the entire result from the input stream to avoid leaving
        // bytes in the stream for future process starts to accidentally stumble
        // upon.
        Process.ProcessStartResult result = new Process.ProcessStartResult();
        result.pid = zygoteInputStream.readInt();
        result.usingWrapper = zygoteInputStream.readBoolean();

        if (result.pid &amp;lt; 0) {
            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);
        }

        return result;
    } catch (IOException ex) {
        zygoteState.close();
        throw new ZygoteStartFailedEx(ex);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Q：这里为什么不采用Binder进行通信？&lt;/p&gt;

&lt;p&gt;A：fork机制限制，仅支持单线程，而binder会创建多线程。&lt;/p&gt;

&lt;h3 id=&quot;232-zygote创建闹钟进程&quot;&gt;2.3.2 Zygote创建闹钟进程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ZygoteServer.runSelectLoop(..)&lt;/li&gt;
  &lt;li&gt;ZygoteConnection.processCommand(..)&lt;/li&gt;
  &lt;li&gt;Zygote.forkAndSpecialize(..)&lt;/li&gt;
  &lt;li&gt;Zygote.nativeForkAndSpecialize(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;int pid = Zygote.forkAndSpecialize(..);
if (pid == 0) {
    // in child
    handleChildProc(..);
} else {
    // In the parent
    handleParentProc(..);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;24-闹钟主线程初始化&quot;&gt;2.4 闹钟主线程初始化&lt;/h2&gt;

&lt;h3 id=&quot;241-闹钟向系统侧请求attachapplication&quot;&gt;2.4.1 闹钟向系统侧请求attachApplication&lt;/h3&gt;

&lt;p&gt;闹钟进程创建完成后初始化，上接 2.3.2：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Zygote.handleChildProc(..)&lt;/li&gt;
  &lt;li&gt;ZygoteInit.zygoteInit(..)&lt;/li&gt;
  &lt;li&gt;RuntimeInit.applicationInit(..)&lt;/li&gt;
  &lt;li&gt;RuntimeInit.findStaticMain(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.main(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.attach(..)&lt;/li&gt;
  &lt;li&gt;ActivityManagerService.attachApplication(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/application1.png&quot; alt=&quot;application1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统侧收到闹钟 attachApplication 通知，上接 2.2.3，在此之后才会真正启动Activity：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/application2.png&quot; alt=&quot;application2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外，Looper 也是在 ActivityThread.main(..) 中初始化的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;Looper.prepareMainLooper();
Looper.loop();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;242-闹钟处理系统侧bindapplication请求&quot;&gt;2.4.2 闹钟处理系统侧bindApplication请求&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityThread$ApplicationThread.bindApplication(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.sendMessage(H.BIND_APPLICATION, data) // 第一条消息&lt;/li&gt;
  &lt;li&gt;ActivityThread.handleBindApplication(data)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
private void handleBindApplication(AppBindData data) {
    ...
    // JVMTI
    if (agent != null) {
        handleAttachAgent(agent, data.info);
    }

    // 1.创建ContextImpl
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);

    // 2.创建Instrumentation
    if (ii != null) {
        initInstrumentation(ii, data, appContext);
    } else {
        mInstrumentation = new Instrumentation();
        mInstrumentation.basicInit(this);
    }

    try {
        // 3.创建 Application
        app = data.info.makeApplicationInner(data.restrictedBackupMode, null);
        ...
        if (!data.restrictedBackupMode) {
            if (!ArrayUtils.isEmpty(data.providers)) {
                // 初始化ContentProvider
                installContentProviders(app, data.providers);
            }
        }
        ...
        try {
            // call Instrumentation.onCreate()
            mInstrumentation.onCreate(data.instrumentationArgs);
        }
        catch (Exception e) {
        }
        ...
        try {
            // call Application.onCreate()
            mInstrumentation.callApplicationOnCreate(app);
        } catch (Exception e) {
        }
    } finally {
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;25-闹钟activity生命周期&quot;&gt;2.5 闹钟Activity生命周期&lt;/h2&gt;

&lt;p&gt;上接 2.2.3，实例化Activity：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityThread$ApplicationThread.scheduleTransaction(..)&lt;/li&gt;
  &lt;li&gt;ClientTransactionHandler.scheduleTransaction(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread$H.handleMessage(..)&lt;/li&gt;
  &lt;li&gt;TransactionExecutor.execute(..)&lt;/li&gt;
  &lt;li&gt;LaunchActivityItem.execute(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.handleLaunchActivity(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.performLaunchActivity(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;try {
    java.lang.ClassLoader cl = appContext.getClassLoader();
    activity = mInstrumentation.newActivity(
            cl, component.getClassName(), r.intent);
} catch (Exception e) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activity创建后依次执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStart()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onResume()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_lifecycle.png&quot; alt=&quot;act_lifecycle&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;26-activity绘制及显示到屏幕&quot;&gt;2.6 Activity绘制及显示到屏幕&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_draw1.png&quot; alt=&quot;act_draw1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在VSYNC-app周期内：SurfaceFlinger的app线程唤醒home主线程，接下来执行Choreographer的doFrame流程，包括input，animation，traversal阶段，在traversal中执行draw绘制并将绘制的内容同步给RenderThread线程。RenderThread线程先从buffer队列中dequeueBuffer申请一个buffer，填充内容，然后queueBuffer将buffer加入队列，并通知SurfaceFlinger。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_draw2.png&quot; alt=&quot;act_draw2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在VSYNC-sf周期内：处理MessageQueue::INVALIDATE消息，从各Layer的BufferQueue拿到最新的缓冲数据，并根据内容更新脏区域；处理MessageQueue::REFRESH消息，通过HWC合成各Layer的buffer，发送至显示设备进行显示。&lt;/p&gt;

&lt;h1 id=&quot;3-小结&quot;&gt;3. 小结&lt;/h1&gt;

&lt;p&gt;本文以在桌面点击图标启动闹钟应用为例，结合trace简单介绍了Activity启动流程中的关键细节，主要包括：Framework侧处理Activity启动请求、任务和返回栈、Activity生命周期、应用进程创建及初始化及绘制流程等。&lt;/p&gt;

&lt;p&gt;可延伸的知识点包括：Context、Window、View事件分发、View绘制流程、Handler机制、Binder机制、类加载机制、fork机制、ServiceManager、SurfaceFlinger、代码插桩、插件化等。&lt;/p&gt;

&lt;h1 id=&quot;4-参考文档&quot;&gt;4. 参考文档：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/37370c1d17fc&quot;&gt;Android应用启动全流程分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/cf531a3af828&quot;&gt;Android卡顿掉帧问题分析之工具篇&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>Activity</category>
        
        
      </item>
    
      <item>
        <title>DisplayArea树层级结构</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/class_hierarchy.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;RootWindowContainer：最顶层的管理者，直接管理 DisplayContent 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DisplayContent：对应一个真实或者虚拟的显示设备。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TaskDisplayArea：是系统中所有应用任务的父节点，用于管理 Task 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Task：代表一个任务，可以包含多个 Activity 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ActivityRecord：对应一个 Activity 节点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;WindowState：对应一个窗口。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1window相关概念&quot;&gt;1.Window相关概念&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Window Type主要分为三大类：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Application windows（应用窗口）: 1~99&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sub-windows（子窗口）: 1000~1999&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;System windows（系统窗口）: 2000~2999&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Window Layer分为36层：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;default int getMaxWindowLayer() {
    return 36;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Z-Order计算：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;mBaseLayer = WindowLayer * 10000 + 1000;
mSubLayer = SubWindowLayer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Window Type与Window Layer对应关系如下：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Window Type&lt;/th&gt;
      &lt;th&gt;VALUE&lt;/th&gt;
      &lt;th&gt;Window Layer&lt;/th&gt;
      &lt;th&gt;Leaf Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BASE_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;APPLICATION_LAYER = 2&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;LEAF_TYPE_TASK_CONTAINERS = 1&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_STARTING&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DRAWN_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;LAST_APPLICATION_WINDOW&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;99&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1000&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_MEDIA&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1001&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;-2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_SUB_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1002&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_ATTACHED_DIALOG&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1003&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_MEDIA_OVERLAY&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1004&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_ABOVE_SUB_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1005&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SEARCH_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PHONE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_ALERT&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2003&lt;/td&gt;
      &lt;td&gt;12|9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_KEYGUARD&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2004&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_TOAST&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2005&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2006&lt;/td&gt;
      &lt;td&gt;23|20&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRIORITY_PHONE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2007&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2008&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_KEYGUARD_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2009&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_ERROR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2010&lt;/td&gt;
      &lt;td&gt;27|9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_METHOD&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2011&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;LEAF_TYPE_IME_CONTAINERS = 2&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_METHOD_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2012&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_WALLPAPER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2013&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2014&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SECURE_SYSTEM_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2015&lt;/td&gt;
      &lt;td&gt;33&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DRAG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2016&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_SUB_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2017&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_POINTER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2018&lt;/td&gt;
      &lt;td&gt;35&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NAVIGATION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2019&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOLUME_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2020&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BOOT_PROGRESS&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2021&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_CONSUMER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2022&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NAVIGATION_BAR_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2024&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DISPLAY_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2026&lt;/td&gt;
      &lt;td&gt;29&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_MAGNIFICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2027&lt;/td&gt;
      &lt;td&gt;28&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRIVATE_PRESENTATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2030&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOICE_INTERACTION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2031&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_ACCESSIBILITY_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2032&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOICE_INTERACTION_STARTING&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2033&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DOCK_DIVIDER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2034&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_QS_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2035&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SCREENSHOT&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2036&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRESENTATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2037&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2038&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2039&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NOTIFICATION_SHADE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2040&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_ADDITIONAL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2041&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_CARWITH_NAVIGATION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2998&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;常见Window及Window Type：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Window&lt;/th&gt;
      &lt;th&gt;Window Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Activity&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BASE_APPLICATION&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TaskSnapshotWindow&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_STARTING&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dialog&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PopupWindow&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_PANEL&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Toast&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_TOAST&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;2为什么要构建displayarea树&quot;&gt;2.为什么要构建DisplayArea树？&lt;/h1&gt;

&lt;h2 id=&quot;21-需求分析&quot;&gt;2.1 需求分析&lt;/h2&gt;

&lt;p&gt;手机系统有N个类型的Window，需要划分Layer维护Window显示Z-order；&lt;/p&gt;

&lt;p&gt;有N个Feature（功能），每个Feature能够影响N个Layer层；&lt;/p&gt;

&lt;p&gt;窗口类型是可增加的，Feature是可增删的；&lt;/p&gt;

&lt;h2 id=&quot;22-方案设计&quot;&gt;2.2 方案设计&lt;/h2&gt;

&lt;p&gt;构建DisplayArea树，创建Feature节点，支持动态增删Feature，叶子节点维护Layer层级。&lt;/p&gt;

&lt;p&gt;以 DefaultTaskDisplayArea 节点为例：&lt;/p&gt;

&lt;p&gt;其父节点为 5|0|12 -&amp;gt; 3|0|14 -&amp;gt; 6|0|14 -&amp;gt; 4|0|31 -&amp;gt; DisplayContent，其含义为该节点的所有子节点均支持 FullscreenMagnification|5、OneHanded|3、HideDisplayCutout|6、WindowedMagnification|4 功能（Feature）。&lt;/p&gt;

&lt;p&gt;同时 DefaultTaskDisplayArea 节点的子节点的层级范围为 2|2，即所有子节点均为应用窗口，其Layer值是固定的。&lt;/p&gt;

&lt;h1 id=&quot;3构建displayarea树流程&quot;&gt;3.构建DisplayArea树流程&lt;/h1&gt;

&lt;h2 id=&quot;31-创建rootwindowcontainer&quot;&gt;3.1 创建RootWindowContainer&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;SystemServer.main(..)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SystemServer.run()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SystemServer.startOtherServices(..)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;vm = WindowManagerService.main(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
private WindowManagerService(..) {
    mRoot = new RootWindowContainer(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;32-创建displaycontent&quot;&gt;3.2 创建DisplayContent&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityManagerService.setWindowManager(wm)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ActivityTaskManagerService.setWindowManager(wm)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;RootWindowContainer.setWindowManager(wm)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// RootWindowContainer.java
private final ImeContainer mImeWindowsContainer = new ImeContainer(mWmService);
void setWindowManager(WindowManagerService wm) {
    ..
    final Display[] displays = mDisplayManager.getDisplays();
    for (int displayNdx = 0; displayNdx &amp;lt; displays.length; ++displayNdx) {
        final Display display = displays[displayNdx];
        final DisplayContent displayContent = new DisplayContent(display, this);
        addChild(displayContent, POSITION_BOTTOM);
        if (displayContent.mDisplayId == DEFAULT_DISPLAY) {
            mDefaultDisplay = displayContent;
        }
    }
    ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;33-创建defaulttaskdisplayarea&quot;&gt;3.3 创建DefaultTaskDisplayArea&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DisplayContent.java
DisplayContent(Display display, RootWindowContainer root) {
    ..
    final Transaction pendingTransaction = getPendingTransaction();
    configureSurfaces(pendingTransaction);
    pendingTransaction.apply();
    ..
}

private void configureSurfaces(Transaction transaction) {
    ..
    if (mDisplayAreaPolicy == null) {
        // Setup the policy and build the display area hierarchy.
        // Build the hierarchy only after creating the surface so it is reparented correctly
        mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(
                mWmService, this /* content */, this /* root */,
                mImeWindowsContainer);
    }
    ..
}

//DisplayAreaPolicy.java
static final class DefaultProvider implements DisplayAreaPolicy.Provider {
    @Override
    public DisplayAreaPolicy instantiate(WindowManagerService wmService,
            DisplayContent content, RootDisplayArea root,
            DisplayArea.Tokens imeContainer) {
        final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,
                &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);
        final List&amp;lt;TaskDisplayArea&amp;gt; tdaList = new ArrayList&amp;lt;&amp;gt;();
        tdaList.add(defaultTaskDisplayArea);

        // Define the features that will be supported under the root of the whole logical
        // display. The policy will build the DisplayArea hierarchy based on this.
        final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root);
        // Set the essential containers (even if the display doesn&apos;t support IME).
        rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);
        if (content.isTrusted()) {
            // Only trusted display can have system decorations.
            configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);
        }

        // Instantiate the policy with the hierarchy defined above. This will create and attach
        // all the necessary DisplayAreas to the root.
        return new DisplayAreaPolicyBuilder().setRootHierarchy(rootHierarchy).build(wmService);
    }
    
    private void configureTrustedHierarchyBuilder(HierarchyBuilder rootHierarchy,
            WindowManagerService wmService, DisplayContent content) {
        rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;WindowedMagnification&quot;,
                FEATURE_WINDOWED_MAGNIFICATION)
                .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                .setNewDisplayAreaSupplier(DisplayArea.Dimmable::new)
                .build());
        if (content.isDefaultDisplay) {
            rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;HideDisplayCutout&quot;,
                    FEATURE_HIDE_DISPLAY_CUTOUT)
                    .all()
                    .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL, TYPE_STATUS_BAR,
                            TYPE_NOTIFICATION_SHADE)
                    .build())
                    .addFeature(new Feature.Builder(wmService.mPolicy, &quot;OneHanded&quot;,
                            FEATURE_ONE_HANDED)
                            .all()
                            .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL,
                                    TYPE_SECURE_SYSTEM_OVERLAY)
                            .build());
        }
        rootHierarchy
                .addFeature(new Feature.Builder(wmService.mPolicy, &quot;FullscreenMagnification&quot;,
                        FEATURE_FULLSCREEN_MAGNIFICATION)
                        .all()
                        .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY, TYPE_INPUT_METHOD,
                                TYPE_INPUT_METHOD_DIALOG, TYPE_MAGNIFICATION_OVERLAY,
                                TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL)
                        .build())
                .addFeature(new Feature.Builder(wmService.mPolicy, &quot;ImePlaceholder&quot;,
                        FEATURE_IME_PLACEHOLDER)
                        .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG)
                        .build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 configureTrustedHierarchyBuilder(..) 方法中配置Feature及其能够影响到的Layer层：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Feature名&lt;/th&gt;
      &lt;th&gt;Feature ID&lt;/th&gt;
      &lt;th&gt;对应功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;WindowedMagnification&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;窗口放大镜功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HideDisplayCutout&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;隐藏刘海功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OneHanded&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;单手模式。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FullscreenMagnification&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;屏幕放大镜功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ImePlaceholder&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;特殊情况下用来放置输入法的节点。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在Feature类中使用一个长度为 getMaxWindowLayer() + 1 的boolean数组，用来标识该Feature能够影响到的Layer层：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;34-displayareapolicy构建过程&quot;&gt;3.4 DisplayAreaPolicy构建过程&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DisplayAreaPolicyBuilder.java
private void build(@Nullable List&amp;lt;HierarchyBuilder&amp;gt; displayAreaGroupHierarchyBuilders) {
    final WindowManagerPolicy policy = mRoot.mWmService.mPolicy;
    final int maxWindowLayerCount = policy.getMaxWindowLayer() + 1;
    final DisplayArea.Tokens[] displayAreaForLayer =
            new DisplayArea.Tokens[maxWindowLayerCount];
    final Map&amp;lt;Feature, List&amp;lt;DisplayArea&amp;lt;WindowContainer&amp;gt;&amp;gt;&amp;gt; featureAreas =
            new ArrayMap&amp;lt;&amp;gt;(mFeatures.size());
    for (int i = 0; i &amp;lt; mFeatures.size(); i++) {
        featureAreas.put(mFeatures.get(i), new ArrayList&amp;lt;&amp;gt;());
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;341-构建root节点&quot;&gt;3.4.1 构建root节点：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;PendingArea[] areaForLayer = new PendingArea[maxWindowLayerCount];
final PendingArea root = new PendingArea(null, 0, null);
Arrays.fill(areaForLayer, root);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;342-构建featurearea&quot;&gt;3.4.2 构建featureArea：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Create DisplayAreas to cover all defined features.
final int size = mFeatures.size();
for (int i = 0; i &amp;lt; size; i++) {
    final Feature feature = mFeatures.get(i);
    PendingArea featureArea = null;
    for (int layer = 0; layer &amp;lt; maxWindowLayerCount; layer++) {
        if (feature.mWindowLayers[layer]) {
            if (featureArea == null || featureArea.mParent != areaForLayer[layer]) {
                featureArea = new PendingArea(feature, layer, areaForLayer[layer]);
                areaForLayer[layer].mChildren.add(featureArea);
            }
            areaForLayer[layer] = featureArea;
        } else {
            featureArea = null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;黄色部分与上图是相对应的，创建的PendingArea显示格式为：Feature ID|minLayer&lt;/p&gt;

&lt;p&gt;构建出如下一棵树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/tree1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;343-构建-leafarea&quot;&gt;3.4.3 构建 leafArea：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Create Tokens as leaf for every layer.
PendingArea leafArea = null;
int leafType = LEAF_TYPE_TOKENS;
for (int layer = 0; layer &amp;lt; maxWindowLayerCount; layer++) {
    int type = typeOfLayer(policy, layer);
    if (leafArea == null || leafArea.mParent != areaForLayer[layer]
            || type != leafType) {
        leafArea = new PendingArea(null /* feature */, layer, areaForLayer[layer]);
        areaForLayer[layer].mChildren.add(leafArea);
        leafType = type;
        if (leafType == LEAF_TYPE_TASK_CONTAINERS) {
            addTaskDisplayAreasToApplicationLayer(areaForLayer[layer]);
            addDisplayAreaGroupsToApplicationLayer(areaForLayer[layer],
                    displayAreaGroupHierarchyBuilders);
            leafArea.mSkipTokens = true;
        } else if (leafType == LEAF_TYPE_IME_CONTAINERS) {
            leafArea.mExisting = mImeContainer;
            leafArea.mSkipTokens = true;
        }
    }
    leafArea.mMaxLayer = layer;
}

private static int typeOfLayer(WindowManagerPolicy policy, int layer) {
    if (layer == APPLICATION_LAYER) {
        return LEAF_TYPE_TASK_CONTAINERS; // 容纳App窗口的TaskDisplayArea
    } else if (layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD)
            || layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD_DIALOG)) {
        return LEAF_TYPE_IME_CONTAINERS; // 容纳输入法窗口的ImeContainer
    } else {
        return LEAF_TYPE_TOKENS; // 容纳其他非App类型窗口的DisplayArea.Tokens
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;黄色部分表示复用同一个leafArea，更新其mMaxLayer值，这里创建的PendingArea显示格式为：minLayer|maxLayer&lt;/p&gt;

&lt;h3 id=&quot;344-更新整棵树所有节点的maxlayer&quot;&gt;3.4.4 更新整棵树所有节点的maxLayer&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;int computeMaxLayer() {
    for (int i = 0; i &amp;lt; mChildren.size(); i++) {
        mMaxLayer = Math.max(mMaxLayer, mChildren.get(i).computeMaxLayer());
    }
    return mMaxLayer;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;345-构建整棵树&quot;&gt;3.4.5 构建整棵树&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;void instantiateChildren(DisplayArea&amp;lt;DisplayArea&amp;gt; parent, DisplayArea.Tokens[] areaForLayer,
        int level, Map&amp;lt;Feature, List&amp;lt;DisplayArea&amp;lt;WindowContainer&amp;gt;&amp;gt;&amp;gt; areas) {
    mChildren.sort(Comparator.comparingInt(pendingArea -&amp;gt; pendingArea.mMinLayer));
    for (int i = 0; i &amp;lt; mChildren.size(); i++) {
        final PendingArea child = mChildren.get(i);
        final DisplayArea area = child.createArea(parent, areaForLayer);
        if (area == null) {
            // TaskDisplayArea and ImeContainer can be set at different hierarchy, so it can
            // be null.
            continue;
        }
        parent.addChild(area, WindowContainer.POSITION_TOP);
        if (child.mFeature != null) {
            areas.get(child.mFeature).add(area);
        }
        child.instantiateChildren(area, areaForLayer, level + 1, areas);
    }
}

private DisplayArea createArea(DisplayArea&amp;lt;DisplayArea&amp;gt; parent,
        DisplayArea.Tokens[] areaForLayer) {
    if (mExisting != null) {
        // LEAF_TYPE_TASK_CONTAINERS
        // LEAF_TYPE_IME_CONTAINERS
        if (mExisting.asTokens() != null) {
            // Store the WindowToken container for layers
            fillAreaForLayers(mExisting.asTokens(), areaForLayer);
        }
        return mExisting;
    }
    if (mSkipTokens) {
        // LEAF_TYPE_TASK_CONTAINERS
        // LEAF_TYPE_IME_CONTAINERS
        return null;
    }
    DisplayArea.Type type;
    if (mMinLayer &amp;gt; APPLICATION_LAYER) {
        type = DisplayArea.Type.ABOVE_TASKS; // 位于App窗口之下的非App窗口
    } else if (mMaxLayer &amp;lt; APPLICATION_LAYER) {
        type = DisplayArea.Type.BELOW_TASKS; // 位于App窗口之上的非App窗口
    } else {
        type = DisplayArea.Type.ANY; // App窗口
    }
    if (mFeature == null) {
        final DisplayArea.Tokens leaf = new DisplayArea.Tokens(parent.mWmService, type,
                &quot;Leaf:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer);
        fillAreaForLayers(leaf, areaForLayer);
        return leaf;
    } else {
        return mFeature.mNewDisplayAreaSupplier.create(parent.mWmService, type,
                mFeature.mName + &quot;:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer, mFeature.mId);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整棵树的根节点是 DisplayContent，这里创建的DisplayArea显示格式为：Feature ID|minLayer|maxLayer；叶子节点的显示格式为：minLayer|maxLayer&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/tree2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;执行命令：adb shell dumpsys activity containers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;ACTIVITY MANAGER CONTAINERS (dumpsys activity containers)
ROOT 
  #0 Display 0 name=&quot;内置屏幕&quot;
   #2 Leaf:36:36 
    #1 WindowToken{7fb09c2 type=2024 android.os.BinderProxy@da9960d} 
     #0 e873d3 RoundCornerBottom 
    #0 WindowToken{2c592ae type=2024 android.os.BinderProxy@5ce3f29} 
     #0 164a84f RoundCornerTop 
   #1 HideDisplayCutout:32:35 
    #2 OneHanded:34:35 
     #0 FullscreenMagnification:34:35 
      #0 Leaf:34:35 
    #1 FullscreenMagnification:33:33 
     #0 Leaf:33:33 
    #0 OneHanded:32:32 
     #0 Leaf:32:32 
   #0 WindowedMagnification:0:31 
    #6 HideDisplayCutout:26:31 
     #0 OneHanded:26:31 
      #2 FullscreenMagnification:29:31 
       #0 Leaf:29:31 
      #1 Leaf:28:28 
       #1 WindowToken{6cffb72 type=2027 android.os.BinderProxy@9b9807d} 
        #0 e90cc40 GestureStubRight 
       #0 WindowToken{288fa0d type=2027 android.os.BinderProxy@3713ca4} 
        #0 1d77f10 GestureStubLeft 
      #0 FullscreenMagnification:26:27 
       #0 Leaf:26:27 
    #5 Leaf:24:25 
     #3 WindowToken{2cfd75e type=2024 android.os.BinderProxy@a18e899} 
      #0 6d1873f GestureStubHome 
     #2 WindowToken{4a05ae3 type=2024 android.os.BinderProxy@b34e312} 
      #0 28a0ce0 SecondaryHomeHandle0 
     #1 WindowToken{6986f7 type=2024 android.os.BinderProxy@f7da2f6} 
      #0 e17e964 pip-dismiss-overlay 
     #0 WindowToken{dfc6ab6 type=2019 android.os.BinderProxy@e0bfb78} 
      #0 bc113b7 NavigationBar0 
    #4 HideDisplayCutout:18:23 
     #0 OneHanded:18:23 
      #0 FullscreenMagnification:18:23 
       #0 Leaf:18:23 
        #1 WindowToken{2ecacd2 type=2017 android.os.BinderProxy@63e9b5d} 
         #0 7d9c1a3 control_center 
        #0 WindowToken{7960200 type=2017 android.os.BinderProxy@7c7083} 
         #0 b7b0a39 NotificationModalWindowManager 
    #3 OneHanded:17:17 
     #0 FullscreenMagnification:17:17 
      #0 Leaf:17:17 
       #0 WindowToken{37bf169 type=2040 android.os.BinderProxy@80f5833} 
        #0 f89f7ee NotificationShade 
    #2 HideDisplayCutout:16:16 
     #0 OneHanded:16:16 
      #0 FullscreenMagnification:16:16 
       #0 Leaf:16:16 
    #1 OneHanded:15:15 
     #0 FullscreenMagnification:15:15 
      #0 Leaf:15:15 
       #0 WindowToken{ac189b4 type=2000 android.os.BinderProxy@75516c6} 
        #0 194a9dd StatusBar 
    #0 HideDisplayCutout:0:14 
     #0 OneHanded:0:14 
      #1 ImePlaceholder:13:14 
       #0 ImeContainer 
        #0 WindowToken{720aa04 type=2011 android.os.Binder@d506617} 
         #0 f966473 InputMethod 
      #0 FullscreenMagnification:0:12 
       #2 Leaf:3:12 
        #0 WindowToken{ec3f545 type=2038 android.os.BinderProxy@fd8013a} 
         #0 329a9af ShellDropTarget 
       #1 DefaultTaskDisplayArea 
        #2 Task=18 
         #0 Task=19 
          #0 ActivityRecord{296e207 u0 com.miui.home/.launcher.Launcher} t19} 
           #0 9eb98f2 com.miui.home/com.miui.home.launcher.Launcher 
        #1 Task=4 
        #0 Task=5 
         #1 Task=7 
         #0 Task=6 
       #0 Leaf:0:1 
        #1 WallpaperWindowToken{d4d41d3 token=android.os.BinderProxy@2da4fc2} 
         #0 d44d722 com.miui.miwallpaper.wallpaperservice.MiuiKeyguardPictorialWallpaper 
        #0 WallpaperWindowToken{22dbaad token=android.os.Binder@fe41bc4} 
         #0 8db5a66 com.miui.miwallpaper.wallpaperservice.ImageWallpaper 
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到Activity是在DefaultTaskDisplayArea节点下，其他新创建的Window会根据Layer值插入到对应Leaf节点上。&lt;/p&gt;

&lt;h1 id=&quot;4参考资料&quot;&gt;4.参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7140289958085935141&quot;&gt;DisplayArea层级结构（一） —— DisplayArea层级结构的生成&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/7140289685879783432&quot;&gt;DisplayArea层级结构（二） —— 向DisplayArea层级结构添加窗口&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/7140289813516648456&quot;&gt;DisplayArea层级结构（三） —— 总结&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/shensky711/article/details/121530510&quot;&gt;WMS 层级结构 &amp;amp;&amp;amp; DisplayAreaGroup 引入&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/jieliaoyuan8279/article/details/123157937&quot;&gt;窗口层次: DisplayArea树&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 24 Dec 2022 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/12/24/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/12/24/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</guid>
        
        <category>Android</category>
        
        
      </item>
    
  </channel>
</rss>
