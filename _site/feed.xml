<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android学习笔记</title>
    <description>Android学习笔记</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 29 Sep 2023 12:07:26 +0800</pubDate>
    <lastBuildDate>Fri, 29 Sep 2023 12:07:26 +0800</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>抖音Android基础技术大揭秘</title>
        <description>&lt;h1 id=&quot;1抖音android基础技术大揭秘-vol01&quot;&gt;1.抖音Android基础技术大揭秘 Vol.01&lt;/h1&gt;

&lt;p&gt;掘金：&lt;a href=&quot;https://live.juejin.cn/4354/6654710&quot;&gt;字节跳动技术沙龙（第10期）&lt;/a&gt;&lt;br /&gt;
B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1eh4y1s7kR&quot;&gt;字节跳动技术沙龙（第10期）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin1.png&quot; alt=&quot;douyin1&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2抖音android基础技术大揭秘-vol02&quot;&gt;2.抖音Android基础技术大揭秘 Vol.02&lt;/h1&gt;

&lt;p&gt;掘金：&lt;a href=&quot;https://live.juejin.cn/4354/9932368&quot;&gt;字节跳动技术沙龙（第12期）&lt;/a&gt;&lt;br /&gt;
B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1bc411V7tE&quot;&gt;字节跳动技术沙龙（第12期）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin2.png&quot; alt=&quot;douyin2&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3抖音android基础技术大揭秘-vol03&quot;&gt;3.抖音Android基础技术大揭秘 Vol.03&lt;/h1&gt;

&lt;p&gt;掘金：&lt;a href=&quot;https://live.byteoc.com/9281/2307433&quot;&gt;抖音Android基础技术大揭秘第三期&lt;/a&gt;&lt;br /&gt;
B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1Fh4y1X71b&quot;&gt;抖音Android基础技术大揭秘第三期&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin3.png&quot; alt=&quot;douyin3&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4抖音android基础技术大揭秘-vol04&quot;&gt;4.抖音Android基础技术大揭秘 Vol.04&lt;/h1&gt;

&lt;p&gt;B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1zu4y1o74x/&quot;&gt;抖音Android基础技术大揭秘第四期&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin4.png&quot; alt=&quot;douyin4&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 29 May 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/05/29/%E6%8A%96%E9%9F%B3Android%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E5%A4%A7%E6%8F%AD%E7%A7%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/05/29/%E6%8A%96%E9%9F%B3Android%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E5%A4%A7%E6%8F%AD%E7%A7%98/</guid>
        
        <category>Android</category>
        
        <category>Performance</category>
        
        <category>Stability</category>
        
        
      </item>
    
      <item>
        <title>微信Tinker热修复</title>
        <description>&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/Tencent/tinker/tree/dev/tinker-android&quot;&gt;https://github.com/Tencent/tinker/tree/dev/tinker-android&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如何快速接入请参考&lt;a href=&quot;https://github.com/Tencent/tinker/wiki/Tinker-接入指南&quot;&gt;Tinker 接入指南&lt;/a&gt;；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何自定义类请参考&lt;a href=&quot;https://github.com/Tencent/tinker/wiki/Tinker-自定义扩展&quot;&gt;Tinker 自定义扩展&lt;/a&gt;；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tinker的API预览请参考&lt;a href=&quot;https://github.com/Tencent/tinker/wiki/Tinker-API概览&quot;&gt;Tinker API预览&lt;/a&gt;；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;tinker-android的源码主要包括三大模块：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;模块类库&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;tinker-android-anno&lt;br /&gt;tinker-android-anno-support&lt;/td&gt;
      &lt;td&gt;编译时注解，用于生成空的Application类。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tinker-android-lib&lt;/td&gt;
      &lt;td&gt;开发者API，提供三方开发接口。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tinker-android-loader&lt;/td&gt;
      &lt;td&gt;补丁包加载，热修复核心逻辑。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;1tinker-android-anno&quot;&gt;1.tinker-android-anno&lt;/h1&gt;

&lt;p&gt;Android应用启动时会先创建Application类，tinker加载Patch补丁包的逻辑也在Application初始化流程中。如果Application类中还引用了其他类，就有可能导致在tinker加载Patch补丁包前就已经加载过了其他类，这样一来就无法通过优先加载补丁包里的类达到热修复的目的，因此要将这些类从Application类中解耦出来。&lt;/p&gt;

&lt;p&gt;为了实现业务逻辑与Application解耦，tinker设计了一个基于TinkerApplication和ApplicationLike的解耦方案，开发者需要继承TinkerApplication自定义一个空的Application，同时将业务逻辑写到ApplicationLike中。&lt;/p&gt;

&lt;p&gt;这个插件的作用是通过解析配置在自定义ApplicationLike类的DefaultLifeCycle注解，在编译期间生成一个自定义Application类，其逻辑在AnnotationProcessor，其模板代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// TinkerAnnoApplication.tmpl
package %PACKAGE%;

import com.tencent.tinker.loader.app.TinkerApplication;

public class %APPLICATION% extends TinkerApplication {

    public %APPLICATION%() {
        super(%TINKER_FLAGS%, &quot;%APPLICATION_LIFE_CYCLE%&quot;, &quot;%TINKER_LOADER_CLASS%&quot;, %TINKER_LOAD_VERIFY_FLAG%, %TINKER_USE_DLC%, %TINKER_USE_INTERPRET_MODE_ON_SUPPORTED_32BIT_SYSTEM%);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外还设计了TinkerApplicationInlineFence类来阻止方法内联。&lt;/p&gt;

&lt;h1 id=&quot;2tinker-android-lib&quot;&gt;2.tinker-android-lib&lt;/h1&gt;

&lt;p&gt;这个类库主要功能包括：初始化tinker，通知tinker合成patch，tinker合成patch，触发dex2oat。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/HotFix/tinker1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;21-tinker初始化&quot;&gt;2.1 Tinker初始化&lt;/h2&gt;

&lt;p&gt;Tinker类的构造方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private Tinker(Context context, int tinkerFlags, LoadReporter loadReporter, PatchReporter patchReporter,
               PatchListener listener, File patchDirectory, File patchInfoFile, File patchInfoLockFile,
               AbstractFilePatch customPatcher, boolean isInMainProc, boolean isPatchProcess, boolean tinkerLoadVerifyFlag) {
    this.context = context;
    this.listener = listener; // 通知tinker合成新patch， 默认实现DefaultPatchListener
    this.loadReporter = loadReporter; // 加载补丁回调，默认实现DefaultLoadReporter
    this.patchReporter = patchReporter; // 合成补丁回调，默认实现DefaultPatchReporter
    this.tinkerFlags = tinkerFlags; // 定制tinker功能
    this.patchDirectory = patchDirectory; // /data/data/xx.xx.xx/tinker
    this.patchInfoFile = patchInfoFile; // /data/data/xx.xx.xx/tinker/patch.info
    this.patchInfoLockFile = patchInfoLockFile; // /data/data/xx.xx.xx/tinker/info.lock
    this.customPatcher = customPatcher; // patch合成策略
    this.isMainProcess = isInMainProc; // 是否是主进程
    this.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag; // 加载补丁是否校验md5
    this.isPatchProcess = isPatchProcess; // 是否是patch进程
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tinker初始化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;public void install(Intent intentResult) {
    install(intentResult, DefaultTinkerResultService.class, new UpgradePatch());
}

// intentResult 是ApplicationLike.getTinkerResultIntent()返回值
// serviceClass 默认是DefaultTinkerResultService ，合成patch后策略
// upgradePatch 默认是UpgradePatch，合成patch过程
public void install(Intent intentResult, Class&amp;lt;? extends AbstractResultService&amp;gt; serviceClass,
                    AbstractPatch upgradePatch) {
    sInstalled = true;
    TinkerPatchService.setPatchProcessor(upgradePatch, serviceClass);
    ...
    tinkerLoadResult = new TinkerLoadResult();
    tinkerLoadResult.parseTinkerResult(getContext(), intentResult);
    //after load code set
    loadReporter.onLoadResult(patchDirectory, tinkerLoadResult.loadCode, tinkerLoadResult.costTime);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;22-应用通知tinker合成patch&quot;&gt;2.2 应用通知tinker合成patch&lt;/h2&gt;

&lt;p&gt;应用基于PatchListener接口通知Tinker有新patch，传入的path是patch的绝对路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public interface PatchListener {
    int onPatchReceived(String path);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PatchListener的默认实现类是DefaultPatchListener，当收onPatchReceived回调后会先做校验，再启动TinkerPatchService合成new patch。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;public int onPatchReceived(String path) {
    return checkPackageAndRunPatchService(path, false);
}

protected int checkPackageAndRunPatchService(String path, boolean useEmergencyMode) {
    final File patchFile = new File(path);
    final String patchMD5 = SharePatchFileUtil.getMD5(patchFile);
    final int returnCode = patchCheck(path, patchMD5);
    if (returnCode == ShareConstants.ERROR_PATCH_OK) {
        runForgService();
        TinkerPatchService.runPatchService(context, path, useEmergencyMode);
    } else {
        Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path), returnCode);
    }
    return returnCode;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;23-合成new-patch&quot;&gt;2.3 合成new patch&lt;/h2&gt;

&lt;p&gt;Tinker会启动TinkerPatchService来合成new patch，运行在一个独立的patch进程中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private static void doApplyPatch(Context context, Intent intent) {
    try {
        PatchResult patchResult = new PatchResult();
        try {
            result = upgradePatchProcessor.tryPatch(context, path, useEmergencyMode, patchResult);
        } catch (Throwable throwable) {
        }
        AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));
    } finally {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;合成new patch的核心逻辑在UpgradePatch，主要步骤包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;基于ShareSecurityCheck校验应用签名、tinkerID、tinkerFlag。&lt;/li&gt;
  &lt;li&gt;基于本地记录的已加载的patch信息，校验new patch是否可以被合成。&lt;/li&gt;
  &lt;li&gt;将new patch拷贝到 data/data/xx.xx.xx/tinker/patch-xxx 目录，并重命名为.apk。&lt;/li&gt;
  &lt;li&gt;分别合成补丁中dex文件，so库，资源文件，合成dex后对新dex做dex2oat操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;DexDiffPatchInternal.tryRecoverDexFiles(..)&lt;/th&gt;
      &lt;th&gt;合成dex&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ArkHotDiffPatchInternal.tryRecoverArkHotLibrary(..)&lt;/td&gt;
      &lt;td&gt;适配华为方舟编译器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SoDiffPatchInternal.tryRecoverLibraryFiles(..)&lt;/td&gt;
      &lt;td&gt;合成so库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ResDiffPatchInternal.tryRecoverResourceFiles(..)&lt;/td&gt;
      &lt;td&gt;合成资源文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;24-触发dex2oat&quot;&gt;2.4 触发dex2oat&lt;/h2&gt;

&lt;p&gt;核心逻辑在TinkerDexOptimizer的OptimizeWorker内部类中，不同Android版本触发方式有区别：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;boolean run() {
    try {
        String optimizedPath = SharePatchFileUtil.optimizedPathFor(this.dexFile, this.optimizedDir);
        if (!ShareTinkerInternals.isArkHotRuning()) {
            if (useInterpretMode) { // VM_IS_ART &amp;amp;&amp;amp; L &amp;lt;= SDK_INT &amp;lt;= N &amp;amp;&amp;amp; isSystemOTA
                interpretDex2Oat(dexFile.getAbsolutePath(), optimizedPath, targetISA);
            } else if (TinkerApplication.getInstance().isUseInterpretModeOnSupported32BitSystem() &amp;amp;&amp;amp;
                    ShareTinkerInternals.isVersionInRange(21, 25, true) &amp;amp;&amp;amp;
                    ShareTinkerInternals.is32BitEnv()
            ) { // L &amp;lt;= SDK_INT &amp;lt;= N
                interpretDex2Oat(dexFile.getAbsolutePath(), optimizedPath, targetISA);
                DexFile.loadDex(dexFile.getAbsolutePath(), optimizedPath, 0);
            } else if (ShareTinkerInternals.isNewerOrEqualThanVersion(26, true)) { // SDK_INT &amp;gt;= O
                if (ShareTinkerInternals.isNewerOrEqualThanVersion(29, true)) { // SDK_INT &amp;gt;= Q
                    NewClassLoaderInjector.triggerDex2Oat(context, optimizedDir,
                            useDLC, dexFile.getAbsolutePath());
                    triggerPMDexOptOnDemand(context, dexFile.getAbsolutePath(), optimizedPath);
                } else {
                    NewClassLoaderInjector.triggerDex2Oat(context, optimizedDir,
                            useDLC, dexFile.getAbsolutePath());
                }
            } else {
                DexFile.loadDex(dexFile.getAbsolutePath(), optimizedPath, 0);
            }
        }
    } catch (final Throwable e) {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;interpretDex2Oat是通过新创建一个进程执行command来执行dex2oat：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final List&amp;lt;String&amp;gt; commandAndParams = new ArrayList&amp;lt;&amp;gt;();
commandAndParams.add(&quot;dex2oat&quot;);
// for 7.1.1, duplicate class fix
if (Build.VERSION.SDK_INT &amp;gt;= 24) {
    commandAndParams.add(&quot;--runtime-arg&quot;);
    commandAndParams.add(&quot;-classpath&quot;);
    commandAndParams.add(&quot;--runtime-arg&quot;);
    commandAndParams.add(&quot;&amp;amp;&quot;);
}
commandAndParams.add(&quot;--dex-file=&quot; + dexFilePath);
commandAndParams.add(&quot;--oat-file=&quot; + oatFilePath);
commandAndParams.add(&quot;--instruction-set=&quot; + targetISA);
if (Build.VERSION.SDK_INT &amp;gt; 25) {
    commandAndParams.add(&quot;--compiler-filter=quicken&quot;);
} else {
    commandAndParams.add(&quot;--compiler-filter=interpret-only&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;DexFile.loadDex加载dex文件触发dex2oat。&lt;/li&gt;
  &lt;li&gt;NewClassLoaderInjector.triggerDex2Oat创建新的ClassLoader触发dex2oat。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;3tinker-android-loader&quot;&gt;3.tinker-android-loader&lt;/h1&gt;

&lt;p&gt;这个类库的核心功能是加载已合成好的Patch，其流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/HotFix/tinker2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在tryLoadPatchFilesInternal方法中会读取合成patch时写入本地的PatchInfo，这里介绍各个字段含义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);

public SharePatchInfo(String oldVer, String newVer, boolean isProtectedApp, boolean useCustomPatch, String versionToRemove, String finger, String oatDir, boolean isRemoveInterpretOATDir) {
    this.oldVersion = oldVer; // 旧patch的md5值
    this.newVersion = newVer; // 新patch的md5值
    this.isProtectedApp = isProtectedApp; // 是否为加固应用
    this.versionToRemove = versionToRemove; // 要删除patch的md5值
    this.fingerPrint = finger; // Build.FINGERPRINT
    this.oatDir = oatDir; // 默认&quot;odex&quot;，在Android O及以下OTA升级时会被置为&quot;interpet&quot;
    this.isRemoveInterpretOATDir = isRemoveInterpretOATDir; // 是否删除&quot;interpet&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来会做一系列校验工作：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;TinkerDexLoader.checkComplete(..)&lt;/th&gt;
      &lt;th&gt;校验要加载的dex以及对应的的odex是否存在&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;TinkerArkHotLoader.checkComplete(..)&lt;/td&gt;
      &lt;td&gt;适配华为方舟编译器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TinkerSoLoader.checkComplete(..)&lt;/td&gt;
      &lt;td&gt;校验so库合法性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TinkerResourceLoader.checkComplete(..)&lt;/td&gt;
      &lt;td&gt;校验补丁资源正确性&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;最后会加载dex和资源文件：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;TinkerDexLoader.loadTinkerJars(..)&lt;/th&gt;
      &lt;th&gt;加载dex，isSystemOTA==true以解释模式加载&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;TinkerArkHotLoader.loadTinkerArkHot(..)&lt;/td&gt;
      &lt;td&gt;适配华为方舟编译器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TinkerResourceLoader.loadTinkerResources(..)&lt;/td&gt;
      &lt;td&gt;加载资源文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;31-loadtinkerjars&quot;&gt;3.1 loadTinkerJars&lt;/h2&gt;

&lt;p&gt;在Android N及以上版本且非加固应用，会重新创建一个ClassLoader：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// SystemClassLoaderAdder.java
public static void installDexes(Application application, ClassLoader loader, File dexOptDir, List&amp;lt;File&amp;gt; files,
                                boolean isProtectedApp, boolean useDLC) throws Throwable {
    if (!files.isEmpty()) {
        ...
        if (Build.VERSION.SDK_INT &amp;gt;= 24 &amp;amp;&amp;amp; !isProtectedApp) { // SDK_INT &amp;gt;= N
            classLoader = NewClassLoaderInjector.inject(application, loader, dexOptDir, useDLC, files);
        } else {
            injectDexesInternal(classLoader, files, dexOptDir);
        }
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Android O_MR1及以上版本可以指定创建DelegateLastClassLoader：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// NewClassLoaderInjector.java
public static ClassLoader inject(Application app, ClassLoader oldClassLoader, File dexOptDir,
                                 boolean useDLC, List&amp;lt;File&amp;gt; patchedDexes) throws Throwable {
    final String[] patchedDexPaths = new String[patchedDexes.size()];
    for (int i = 0; i &amp;lt; patchedDexPaths.length; ++i) {
        patchedDexPaths[i] = patchedDexes.get(i).getAbsolutePath();
    }
    final ClassLoader newClassLoader = createNewClassLoader(oldClassLoader,
          dexOptDir, useDLC, true, patchedDexPaths);
    doInject(app, newClassLoader);
    return newClassLoader;
}

private static ClassLoader createNewClassLoader(ClassLoader oldClassLoader,
                                                File dexOptDir,
                                                boolean useDLC,
                                                boolean forActualLoading,
                                                String... patchDexPaths) throws Throwable {
    ...
    final String combinedDexPath = dexPathBuilder.toString(); // 拼接patchDexPaths
    ...
    final String combinedLibraryPath = libraryPathBuilder.toString();

    ClassLoader result = null;
    if (useDLC &amp;amp;&amp;amp; ShareTinkerInternals.isNewerOrEqualThanVersion(27, true)) { // SDK_INT &amp;gt;= O_MR1
        if (ShareTinkerInternals.isNewerOrEqualThanVersion(31, true)) { // SDK_INT &amp;gt;= S
            result = new DelegateLastClassLoader(combinedDexPath, combinedLibraryPath, oldClassLoader);
        } else {
            result = new DelegateLastClassLoader(combinedDexPath, combinedLibraryPath, ClassLoader.getSystemClassLoader());
            final Field parentField = ClassLoader.class.getDeclaredField(&quot;parent&quot;);
            parentField.setAccessible(true);
            parentField.set(result, oldClassLoader);
        }
    } else {
        result = new TinkerClassLoader(combinedDexPath, dexOptDir, combinedLibraryPath, oldClassLoader);
    }
    ...
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;doInject方法中会替换ContextImpl，LoadedApk，Resources，DrawableInflater类的mClassLoader成员变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private static void doInject(Application app, ClassLoader classLoader) throws Throwable {
    Thread.currentThread().setContextClassLoader(classLoader);

    final Context baseContext = (Context) findField(app.getClass(), &quot;mBase&quot;).get(app);
    try {
        findField(baseContext.getClass(), &quot;mClassLoader&quot;).set(baseContext, classLoader);
    } catch (Throwable ignored) {
        // There&apos;s no mClassLoader field in ContextImpl before Android O.
        // However we should try our best to replace this field in case some
        // customized system has one.
    }

    final Object basePackageInfo = findField(baseContext.getClass(), &quot;mPackageInfo&quot;).get(baseContext);
    findField(basePackageInfo.getClass(), &quot;mClassLoader&quot;).set(basePackageInfo, classLoader);

    final Resources res = app.getResources();
    try {
        findField(res.getClass(), &quot;mClassLoader&quot;).set(res, classLoader);
    } catch (Throwable ignored) {
        // Ignored.
    }
    try {
        final Object drawableInflater = findField(res.getClass(), &quot;mDrawableInflater&quot;).get(res);
        if (drawableInflater != null) {
            findField(drawableInflater.getClass(), &quot;mClassLoader&quot;).set(drawableInflater, classLoader);
        }
    } catch (Throwable ignored) {
        // Ignored.
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;32-loadtinkerresources&quot;&gt;3.2 loadTinkerResources&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;将LoadedApk实例中mResDir成员变量设为新资源包路径。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// 反射ActivityThread的mPackages和mResourcePackages成员变量获取到LoadedApk
final ArrayMap&amp;lt;String, WeakReference&amp;lt;LoadedApk&amp;gt;&amp;gt; mPackages = new ArrayMap&amp;lt;&amp;gt;();
final ArrayMap&amp;lt;String, WeakReference&amp;lt;LoadedApk&amp;gt;&amp;gt; mResourcePackages = new ArrayMap&amp;lt;&amp;gt;();
// 替换LoadedApk的mResDir
private String mResDir;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;创建新的AssetManager实例，并设置它的资源路径为新资源包路径。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;newAssetManager = (AssetManager) newAssetManagerCtor.newInstance();
// Create a new AssetManager instance and point it to the resources installed under
if (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == 0) {
    throw new IllegalStateException(&quot;Could not create new AssetManager&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;将Resources.mAssets设为新创建的AssetManager，清除原app的Resources中typedArray缓存，刷新资源配置。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// 反射ResourcesManager的mResourceReferences成员变量获取到Resources
private final ArrayList&amp;lt;WeakReference&amp;lt;Resources&amp;gt;&amp;gt; mResourceReferences = new ArrayList&amp;lt;&amp;gt;();
// 反射Resources的mResourcesImpl成员变量获取到ResourcesImpl
private ResourcesImpl mResourcesImpl;
// 反射ResourcesImpl的mAssets成员变量替换为newAssetManager
final AssetManager mAssets;

// 清空Resources的typedArray缓存，循环调用其acquire方法
final SynchronizedPool&amp;lt;TypedArray&amp;gt; mTypedArrayPool = new SynchronizedPool&amp;lt;&amp;gt;(5);

// 刷新资源配置，调用updateConfiguration方法
resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;4小结&quot;&gt;4.小结&lt;/h1&gt;

&lt;p&gt;Q：为什么要基于patch合成新的dex？&lt;/p&gt;

&lt;p&gt;Qzone热修复方案为了规避Dalvik虚拟机pre-verify问题需要代码插桩做规避，直接影响了程序运行时性能，此外在Art虚拟机上还需要规避内存错乱的问题。tinker采用合成dex的方式可以规避以上两个问题。&lt;/p&gt;

&lt;p&gt;Q：为什么要替换PatchClassLoader？&lt;/p&gt;

&lt;p&gt;dex2oat流程中传入profile文件，会生成app_image的base.art文件。app image的作用是记录已经编译好的“热代码”，并且在启动时一次性把它们加载到缓存，预先加载代替用时查找以提升应用的性能。也就是说系统在查找类时会直接使用base.apk中的class，这样一来热修复机制就失效了，所以要创建新的ClassLoader。&lt;/p&gt;

&lt;p&gt;Q：Android8.0之前系统OTA后加载补丁为什么会ANR？&lt;/p&gt;

&lt;p&gt;A：Android 8.0之前动态加载的dex会被以speed模式全量编译，系统OTA更新后导致旧的补丁dex的oat文件失效，此时运行app就会对它重新执行dex2oat，可能耗时比较久造成ANR。&lt;/p&gt;

&lt;h1 id=&quot;参考文档&quot;&gt;参考文档&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/WeMobileDev/article/blob/master/微信Android热补丁实践演进之路.md&quot;&gt;微信Android热补丁实践演进之路&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;amp;mid=2649286341&amp;amp;idx=1&amp;amp;sn=054d595af6e824cbe4edd79427fc2706#rd&quot;&gt;Android N混合编译与对热补丁影响解析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;amp;mid=2649286426&amp;amp;idx=1&amp;amp;sn=eb75349c0c3663f10fbdd74ef87be338&amp;amp;chksm=8334c398b4434a8e6933ddb4fda4a4f06c729c7d2ffef37e4598cb90f4602f5310486b7f95ff#rd&quot;&gt;ART下的方法内联策略及其对Android热修复方案的影响分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/6971232987681652773&quot;&gt;Android 热修复Tinker源码分析（一）补丁包的生成&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/6980259462036586526&quot;&gt;Android 热修复Tinker源码分析（二）补丁包的合成&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/6980259506097750030&quot;&gt;Android 热修复Tinker源码分析（三）补丁的加载&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Apr 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/04/20/%E5%BE%AE%E4%BF%A1Tinker%E7%83%AD%E4%BF%AE%E5%A4%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/04/20/%E5%BE%AE%E4%BF%A1Tinker%E7%83%AD%E4%BF%AE%E5%A4%8D/</guid>
        
        <category>Android</category>
        
        <category>HotFix</category>
        
        <category>Tinker</category>
        
        
      </item>
    
      <item>
        <title>美团Robust热修复</title>
        <description>&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/Meituan-Dianping/Robust&quot;&gt;https://github.com/Meituan-Dianping/Robust&lt;/a&gt;&lt;br /&gt;
WIKI：&lt;a href=&quot;https://github.com/Meituan-Dianping/Robust/wiki&quot;&gt;https://github.com/Meituan-Dianping/Robust/wiki&lt;/a&gt;&lt;br /&gt;
Instant Run原理：&lt;a href=&quot;https://android.googlesource.com/platform/tools/base/+/studio-3.0/instant-run/&quot;&gt;https://android.googlesource.com/platform/tools/base/+/studio-3.0/instant-run/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Robust的源码主要包括三大模块：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;模块类库&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;gradle-plugin&lt;/td&gt;
      &lt;td&gt;代码插桩，静态字段ChangeQuickRedirect&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;auto-patch-plugin&lt;br /&gt;autopatchbase&lt;/td&gt;
      &lt;td&gt;生成补丁包&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;patch&lt;/td&gt;
      &lt;td&gt;加载补丁&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;1代码插桩&quot;&gt;1.代码插桩&lt;/h1&gt;

&lt;p&gt;基于Gradle Transform在构建阶段对字节码插桩。&lt;/p&gt;

&lt;p&gt;支持两种插桩实现方式：JavaAssist和ASM。&lt;/p&gt;

&lt;p&gt;核心类是：RobustTransform，AsmInsertImpl，RobustAsmUtils，JavaAssistInsertImpl&lt;/p&gt;

&lt;p&gt;插入的字节码内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// JavaAssistInsertImpl.java
String body = &quot;Object argThis = null;&quot;;
if (!isStatic) {
    body += &quot;argThis = $0;&quot;;
}
String parametersClassType = getParametersClassType(ctMethod); // 函数参数
body += &quot;   if (com.meituan.robust.PatchProxy.isSupport($args, argThis, &quot; + Constants.INSERT_FIELD_NAME + &quot;, &quot; + isStatic +
        &quot;, &quot; + methodMap.get(ctBehavior.getLongName()) + &quot;,&quot; + parametersClassType + &quot;,&quot; + returnTypeString + &quot;.class)) {&quot;;
body += getReturnStatement(returnTypeString, isStatic, methodMap.get(ctBehavior.getLongName()), parametersClassType, returnTypeString + &quot;.class&quot;); // 函数返回值
body += &quot;   }&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简化为Java代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public static ChangeQuickRedirect changeQuickRedirect;

if (PatchProxy.isSupport(函数参数, this, changeQuickRedirect, 是否静态方法, 方法ID, 参数类型，返回值类型)) {
    return PatchProxy.accessDispatch(函数参数, this, changeQuickRedirect, 是否静态方法, 方法ID, 参数类型，返回值类型);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;2生成补丁包&quot;&gt;2.生成补丁包&lt;/h1&gt;

&lt;h2 id=&quot;21-patch文件的构成&quot;&gt;2.1 Patch文件的构成&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;PatchesInfoImpl&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PatchesInfoImpl实现了PatchesInfo接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public interface PatchesInfo {
    List&amp;lt;PatchedClassInfo&amp;gt; getPatchedClassesInfo();
}

public class PatchedClassInfo {
    public String patchedClassName; // apk中的类名
    public String patchClassName; // 补丁包中的xxPatchControl
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;xxPatch&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;修复bug的全部逻辑代码。此外把改动方法中调用的方法和字段访问全部改为了反射调用，同时要解决Proguard造成的混淆、以及内联的问题。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;xxPatchControl&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现了ChangeQuickRedirect接口，APK中的bug方法转到补丁中的fix方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-TypeScript&quot;&gt;public interface ChangeQuickRedirect {
    Object accessDispatch(String methodName, Object[] paramArrayOfObject);
    boolean isSupport(String methodName, Object[] paramArrayOfObject);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应代码插桩里的逻辑，当isSupport方法返回true时，才会执行accessDispatch方法。在accessDispatch方法中会创建xxPatch的实例，调用xxPatch里的修复方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;xxInLinePatch，处理内联问题。&lt;/li&gt;
  &lt;li&gt;XXPatchRobustAssist，处理super问题。&lt;/li&gt;
  &lt;li&gt;最后一种是新增类的，Add注解加在那个类上，就会把这个类放入补丁内部。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;22-autopatchbase核心类&quot;&gt;2.2 autopatchbase核心类&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;com.meituan.robust.patch.annotaion.Add&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用来标记新增的类和方法的注解。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;com.meituan.robust.patch.annotaion.Modify&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用来标记被改动的类和方法的注解。如果这个注解是放在一个类A上面，自动化补丁会生成类APatch，APatch会被打入补丁，原始APK中的类A中每个方法都不会被执行，只会执行APatch中的方法；如果注解标记的是方法，则表明这个方法是需要被打入补丁中的，只有被标注的方法会打入补丁，打入补丁之后，就会执行补丁的方法，原始方法不会在执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;com.meituan.robust.patch.RobustModify&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对泛型、匿名内部类等需要在泛型方法里面使用RobustModify.modify()来标注需要打入补丁中的方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;com.meituan.robust.utils.EnhancedRobustUtils，反射的工具类。&lt;/li&gt;
  &lt;li&gt;com.meituan.robust.utils.PatchTemplate，补丁的模板类。&lt;/li&gt;
  &lt;li&gt;com.meituan.robust.ChangeQuickRedirect，xxControl的实现接口。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3加载补丁&quot;&gt;3.加载补丁&lt;/h1&gt;

&lt;p&gt;官方热修复原理图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/HotFix/robust.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;简单来说就是下发补丁后，会将 badClass 的 changeQuickRedirect 置为 patched.class，在 badMethod 方法中跳转到 patchedMethod ，达到热修复目的。&lt;/p&gt;

&lt;p&gt;其核心流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建PatchExecutor线程并执行&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public void run() {
    try {
        //拉取补丁列表
        List&amp;lt;Patch&amp;gt; patches = fetchPatchList();
        //应用补丁列表
        applyPatchList(patches);
    } catch (Throwable t) {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;遍历patches执行patch(..)方法，创建DexClassLoader加载patch&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;try {
    File dexOutputDir = getPatchCacheDirPath(context, patch.getName() + patch.getMd5());
    classLoader = new DexClassLoader(patch.getTempPath(), dexOutputDir.getAbsolutePath(),
            null, PatchExecutor.class.getClassLoader());
} catch (Throwable throwable) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;加载patchesInfo类并创建实例&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;Class patchesInfoClass;
PatchesInfo patchesInfo = null;
try {
    Log.d(&quot;robust&quot;, &quot;patch patch_info_name:&quot; + patch.getPatchesInfoImplClassFullName());
    patchesInfoClass = classLoader.loadClass(patch.getPatchesInfoImplClassFullName());
    patchesInfo = (PatchesInfo) patchesInfoClass.newInstance();
} catch (Throwable t) {
    Log.e(&quot;robust&quot;, &quot;patch failed 188 &quot;, t);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;遍历patchesInfo中的PatchedClassInfo，替换changeQuickRedirect变量&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;for (PatchedClassInfo patchedClassInfo : patchedClasses) {
    String patchedClassName = patchedClassInfo.patchedClassName;
    String patchClassName = patchedClassInfo.patchClassName;

    try {
        // apk中的类
        sourceClass = classLoader.loadClass(patchedClassName.trim());
    } catch (ClassNotFoundException e) {
        isClassNotFoundException = true;
        continue;
    }

    // 反射获取到changeQuickRedirect
    Field[] fields = sourceClass.getDeclaredFields();
    Field changeQuickRedirectField = null;
    for (Field field : fields) {
        if (TextUtils.equals(field.getType().getCanonicalName(), ChangeQuickRedirect.class.getCanonicalName()) &amp;amp;&amp;amp; TextUtils.equals(field.getDeclaringClass().getCanonicalName(), sourceClass.getCanonicalName())) {
            changeQuickRedirectField = field;
            break;
        }
    }

    // 将changeQuickRedirect替换为patchClassName的实例
    try {
        patchClass = classLoader.loadClass(patchClassName);
        Object patchObject = patchClass.newInstance();
        changeQuickRedirectField.setAccessible(true);
        changeQuickRedirectField.set(null, patchObject);
    } catch (Throwable t) {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;4小结&quot;&gt;4.小结&lt;/h1&gt;

&lt;p&gt;Robust热修复采用 InstantRun 的热更新机制，可以即时生效，不需要重启，采用插桩和多ClassLoader方案，兼容性和稳定性较好。核心难点在于补丁包的生成，需要考虑代码混淆、方法内联、匿名类、匿名方法的影响。&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Apr 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/04/12/%E7%BE%8E%E5%9B%A2Robust%E7%83%AD%E4%BF%AE%E5%A4%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/04/12/%E7%BE%8E%E5%9B%A2Robust%E7%83%AD%E4%BF%AE%E5%A4%8D/</guid>
        
        <category>Android</category>
        
        <category>HotFix</category>
        
        <category>Rubust</category>
        
        
      </item>
    
      <item>
        <title>Android热修复原理</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/HotFix/hook.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Dalvik&lt;/th&gt;
      &lt;th&gt;ART&lt;/th&gt;
      &lt;th&gt;AOP&lt;/th&gt;
      &lt;th&gt;HotFix&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Dexposed&lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt;替换Method的nativeFunc&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AndFix / HotFix&lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt;替换Method的entrypoint&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Sophix&lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt;优化AndFix，整体替换Method&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AndroidMethodHook&lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt;Sophix + dexmaker&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Epic&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt;✓&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;ART上的Dexposed&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;1aop框架&quot;&gt;1.AOP框架&lt;/h1&gt;

&lt;p&gt;摘自百度百科：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;11-aspectj框架&quot;&gt;1.1 Aspectj框架&lt;/h2&gt;

&lt;p&gt;官网：https://eclipse.dev/aspectj/&lt;/p&gt;

&lt;p&gt;摘自百度百科：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法，它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在Android中使用Aspectj框架：&lt;/p&gt;

&lt;p&gt;开源项目：https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx&lt;/p&gt;

&lt;p&gt;gradle_plugin_android_aspectjx一个基于AspectJ并在此基础上扩展出来可应用于Android开发平台的AOP框架，可作用于java源码，class文件及jar包，同时支持kotlin的应用。&lt;/p&gt;

&lt;p&gt;其核心原理是基于Gradle Transform接口，通过字节码插桩技术插入切面方法。&lt;/p&gt;

&lt;h2 id=&quot;12-xposed框架&quot;&gt;1.2 Xposed框架&lt;/h2&gt;

&lt;p&gt;官网：https://devtut.github.io/android/xposed.html&lt;/p&gt;

&lt;p&gt;摘自百度百科：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Xposed框架(Xposed Framework)是一套开源的、在Android高权限模式下运行的框架服务，可以在不修改APK文件的情况下影响程序运行（修改系统）的框架服务，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在已root手机上，通过替换 system/bin/app_process 以及虚拟机动态链接库，实现对Davilk/ART虚拟机劫持，使得应用在启动时加载 XposedBridge.jar 初始化Hook模块。Hook核心原理是将需要hook的函数注册为Native层函数，当执行到这一函数时虚拟机会优先执行Native层函数，然后再去执行Java层函数，这样完成函数的hook。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/HotFix/xposed.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2java层热修复&quot;&gt;2.Java层热修复&lt;/h1&gt;

&lt;h2 id=&quot;21-编译时注解&quot;&gt;2.1 编译时注解&lt;/h2&gt;

&lt;p&gt;APT（Annotation Processing Tool）即注解处理器（通常也叫做编译时注解、编译时代码自动生成），是一种处理注解的工具，确切的说它是javac的一个工具，它用来在编译时扫描和处理注解。注解处理器以Java代码（或者编译过的字节码）作为输入，生成.java文件作为输出。 简单来说就是在编译期，通过注解生成.java文件。&lt;/p&gt;

&lt;p&gt;业界基于APT的开源项目有：&lt;a href=&quot;https://github.com/android/databinding-samples&quot;&gt;DataBinding&lt;/a&gt; / &lt;a href=&quot;https://github.com/JakeWharton/butterknife&quot;&gt;butterknife&lt;/a&gt; / &lt;a href=&quot;https://github.com/google/dagger&quot;&gt;dagger2&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;22-字节码插桩&quot;&gt;2.2 字节码插桩&lt;/h2&gt;

&lt;p&gt;Java Source文件（.java）在经过javac编译器编译后会生成字节码文件（.class）。字节码插桩技术就是对字节码文件做修改，以达到代码注入的目的。&lt;/p&gt;

&lt;p&gt;1.基于ASM&lt;/p&gt;

&lt;p&gt;官网地址：&lt;a href=&quot;https://asm.ow2.io/&quot;&gt;https://asm.ow2.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Android Framework源码编译中有应用到ASM插桩，详见：&lt;a href=&quot;https://android.googlesource.com/platform/frameworks/base/+/refs/heads/main/tools/locked_region_code_injection/src/lockedregioncodeinjection&quot;&gt;lockedregioncodeinjection&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.基于Javassist&lt;/p&gt;

&lt;p&gt;官网地址：&lt;a href=&quot;http://www.javassist.org/&quot;&gt;http://www.javassist.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Javassist提供两种级别的API：源代码级别和字节码级别。&lt;/p&gt;

&lt;p&gt;相比于ASM需要开发者熟悉字节码指令，Javassist支持使用Java编码的形式编辑或生成class文件。&lt;/p&gt;

&lt;h2 id=&quot;23-dex插桩&quot;&gt;2.3 Dex插桩&lt;/h2&gt;

&lt;p&gt;Android编译流程中会将字节码文件打包生成dex文件，Dex插桩就是对dex文件做修改以达到代码注入的目的。&lt;/p&gt;

&lt;p&gt;业界开源项目有：&lt;a href=&quot;https://github.com/facebook/redex&quot;&gt;redex&lt;/a&gt; / DexInjector&lt;/p&gt;

&lt;p&gt;相关联知识点：&lt;/p&gt;

&lt;p&gt;1.smali&lt;/p&gt;

&lt;p&gt;JVM 的执行是 Stack-based , 基于栈帧的，而 Dalvik 虚拟机是 Register-based，基于寄存器的。&lt;/p&gt;

&lt;p&gt;smali/baksmali 是针对 dalvik 使用的 dex 格式的汇编/反汇编器。它的语法基于 Jasmin’s/dedexer，支持 dex 格式的所有功能（注释，调试信息，行信息等等）。因此我们可以认为 smali 和 Dalvik 字节码文件是等价的。&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;https://android.googlesource.com/platform/tools/dexter/+/refs/heads/master&quot;&gt;dexter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;dexter 工具是google开发的一个类似dexdump的工具，但其内部实现了对dex文件结构和字节码指令的一套完整的操作api，轻量简洁，对字节码的操作可以达到ASM的体验。&lt;/p&gt;

&lt;h1 id=&quot;3native层热修复&quot;&gt;3.Native层热修复&lt;/h1&gt;

&lt;h2 id=&quot;31-dexposed&quot;&gt;3.1 Dexposed&lt;/h2&gt;

&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/alibaba/dexposed&quot;&gt;https://github.com/alibaba/dexposed&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;核心实现在dexposed.cpp，首先基于dvm接口找到方法地址，其次保存原始方法信息，最后将原始方法设置为Native方法，并将nativeFunc指向自定义的函数地址。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;static void com_taobao_android_dexposed_DexposedBridge_hookMethodNative(JNIEnv* env, jclass clazz, jobject reflectedMethodIndirect,
            jobject declaredClassIndirect, jint slot, jobject additionalInfoIndirect) {
    // Find the internal representation of the method
    ClassObject* declaredClass = (ClassObject*) dvmDecodeIndirectRef(dvmThreadSelf(), declaredClassIndirect);
    Method* method = dvmSlotToMethod(declaredClass, slot);
    
    // Save a copy of the original method and other hook info
    DexposedHookInfo* hookInfo = (DexposedHookInfo*) calloc(1, sizeof(DexposedHookInfo));
    memcpy(hookInfo, method, sizeof(hookInfo-&amp;gt;originalMethodStruct));
    hookInfo-&amp;gt;reflectedMethod = dvmDecodeIndirectRef(dvmThreadSelf(), env-&amp;gt;NewGlobalRef(reflectedMethodIndirect));
    hookInfo-&amp;gt;additionalInfo = dvmDecodeIndirectRef(dvmThreadSelf(), env-&amp;gt;NewGlobalRef(additionalInfoIndirect));

    // Replace method with our own code
    SET_METHOD_FLAG(method, ACC_NATIVE);
    method-&amp;gt;nativeFunc = &amp;amp;dexposedCallHandler;
    method-&amp;gt;insns = (const u2*) hookInfo;
    method-&amp;gt;registersSize = method-&amp;gt;insSize;
    method-&amp;gt;outsSize = 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要掌握的知识点包括：dvm虚拟机中如何描述Java中的类和方法，以及dvm虚拟机执行方法的逻辑。&lt;/p&gt;

&lt;h2 id=&quot;32-andfix--hotfix&quot;&gt;3.2 AndFix / HotFix&lt;/h2&gt;

&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/alibaba/AndFix&quot;&gt;https://github.com/alibaba/AndFix&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;AndFix的策略是方法替换，首先加载补丁包获取到要替换的方法，其次基于art接口找到原始方法地址和补丁包中替换方法地址，最后将替换方法内容覆盖原始方法内容。&lt;/p&gt;

&lt;p&gt;不同Android版本中底层ArtMethod会有改动，因此要基于Android版本做适配。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// art_method_replace_7_0.cpp
void replace_7_0(JNIEnv* env, jobject src, jobject dest) {
    art::mirror::ArtMethod* smeth =
            (art::mirror::ArtMethod*) env-&amp;gt;FromReflectedMethod(src);

    art::mirror::ArtMethod* dmeth =
            (art::mirror::ArtMethod*) env-&amp;gt;FromReflectedMethod(dest);

    reinterpret_cast&amp;lt;art::mirror::Class*&amp;gt;(dmeth-&amp;gt;declaring_class_)-&amp;gt;clinit_thread_id_ =
            reinterpret_cast&amp;lt;art::mirror::Class*&amp;gt;(smeth-&amp;gt;declaring_class_)-&amp;gt;clinit_thread_id_;
    reinterpret_cast&amp;lt;art::mirror::Class*&amp;gt;(dmeth-&amp;gt;declaring_class_)-&amp;gt;status_ =
            reinterpret_cast&amp;lt;art::mirror::Class*&amp;gt;(smeth-&amp;gt;declaring_class_)-&amp;gt;status_ -1;
    //for reflection invoke
    reinterpret_cast&amp;lt;art::mirror::Class*&amp;gt;(dmeth-&amp;gt;declaring_class_)-&amp;gt;super_class_ = 0;

    smeth-&amp;gt;declaring_class_ = dmeth-&amp;gt;declaring_class_;
    smeth-&amp;gt;access_flags_ = dmeth-&amp;gt;access_flags_  | 0x0001;
    smeth-&amp;gt;dex_code_item_offset_ = dmeth-&amp;gt;dex_code_item_offset_;
    smeth-&amp;gt;dex_method_index_ = dmeth-&amp;gt;dex_method_index_;
    smeth-&amp;gt;method_index_ = dmeth-&amp;gt;method_index_;
    smeth-&amp;gt;hotness_count_ = dmeth-&amp;gt;hotness_count_;

    smeth-&amp;gt;ptr_sized_fields_.dex_cache_resolved_methods_ =
            dmeth-&amp;gt;ptr_sized_fields_.dex_cache_resolved_methods_;
    smeth-&amp;gt;ptr_sized_fields_.dex_cache_resolved_types_ =
            dmeth-&amp;gt;ptr_sized_fields_.dex_cache_resolved_types_;

    smeth-&amp;gt;ptr_sized_fields_.entry_point_from_jni_ =
            dmeth-&amp;gt;ptr_sized_fields_.entry_point_from_jni_;
    smeth-&amp;gt;ptr_sized_fields_.entry_point_from_quick_compiled_code_ =
            dmeth-&amp;gt;ptr_sized_fields_.entry_point_from_quick_compiled_code_;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;33-sophix&quot;&gt;3.3 Sophix&lt;/h2&gt;

&lt;p&gt;Sophix对AndFix做了优化，通过定义两个相邻的方法，获取其在内存中的地址，计算差值获取到ArtMethod的大小，实现method整体拷贝，从而规避了Android版本适配问题。&lt;/p&gt;

&lt;h2 id=&quot;34-androidmethodhook&quot;&gt;3.4 AndroidMethodHook&lt;/h2&gt;

&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/panhongwei/AndroidMethodHook&quot;&gt;https://github.com/panhongwei/AndroidMethodHook&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;AndroidMethodHook在Sophix基础上，通过dexmaker在运行时动态生成dex文件，实现AOP。&lt;/p&gt;

&lt;h2 id=&quot;35-epic&quot;&gt;3.5 Epic&lt;/h2&gt;

&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/tiann/epic&quot;&gt;https://github.com/tiann/epic&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;强制编译Method成为Native代码，避免解释执行。&lt;/li&gt;
  &lt;li&gt;修改代码起始字节，替换成跳转指令，跳转到跳板函数，在跳板函数中做分发逻辑。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/HotFix/epic.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;36-artdroid&quot;&gt;3.6 ARTDroid&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://ceur-ws.org/Vol-1575/paper_10.pdf&quot;&gt;https://ceur-ws.org/Vol-1575/paper_10.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ART中调用一个virtual method的时候，会查相应Class类里面的一张表，如果修改这张表对应项的指向，就能达到Hook的目的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/HotFix/artdroid.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;参考文档&quot;&gt;参考文档：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://weishu.me/2017/11/23/dexposed-on-art/&quot;&gt;论ART上运行时 Method AOP实现&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://rk700.github.io/2017/06/30/hook-on-android-n/&quot;&gt;在Android N上对Java方法做hook遇到的坑&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://rk700.github.io/2017/03/30/YAHFA-introduction/&quot;&gt;YAHFA–ART环境下的Hook框架&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 05 Apr 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/04/05/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/04/05/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86/</guid>
        
        <category>Android</category>
        
        <category>HotFix</category>
        
        
      </item>
    
      <item>
        <title>Android资源加载流程</title>
        <description>&lt;p&gt;官方文档：&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/topics/resources/providing-resources?hl=zh-cn&quot;&gt;应用资源概览&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/studio/command-line/aapt2?hl=zh-cn&quot;&gt;AAPT2&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;1资源文件类型&quot;&gt;1.资源文件类型&lt;/h1&gt;

&lt;p&gt;Android应用程序资源可以分为两大类，分别是assets和res：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;assets&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;assets类资源放在工程根目录的assets子目录下，它里面保存的是一些原始的文件，可以以任何方式来进行组织。这些文件最终会被原装不动地打包在apk文件中。如果我们要在程序中访问这些文件，那么就需要指定文件名来访问。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;res&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;res类资源放在工程根目录的res子目录下，它里面保存的文件大多数都会被编译，并且都会被赋予资源ID。这样我们就可以在程序中通过R类来访问res类的资源。res类资源按照不同的用途可以进一步划分为以下子类型：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;目录&lt;/th&gt;
      &lt;th&gt;资源类型&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;animator/&lt;/td&gt;
      &lt;td&gt;用于定义属性动画的 XML 文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;anim/&lt;/td&gt;
      &lt;td&gt;用于定义补间动画的 XML 文件。属性动画也可保存在此目录中，但为了区分这两种类型，属性动画首选 animator/ 目录。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;color/&lt;/td&gt;
      &lt;td&gt;定义颜色状态列表的 XML 文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;drawable/&lt;/td&gt;
      &lt;td&gt;位图文件（PNG、.9.png、JPG 或 GIF）或编译为以下可绘制资源子类型的 XML 文件：位图文件九宫图（可调整大小的位图）状态列表形状动画可绘制对象其他可绘制对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mipmap/&lt;/td&gt;
      &lt;td&gt;适用于不同启动器图标密度的可绘制对象文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;layout/&lt;/td&gt;
      &lt;td&gt;用于定义界面布局的 XML 文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;menu/&lt;/td&gt;
      &lt;td&gt;用于定义应用菜单（例如选项菜单、上下文菜单或子菜单）的 XML 文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;raw/&lt;/td&gt;
      &lt;td&gt;需以原始形式保存的任意文件。如要使用原始 InputStream 打开这些资源，请使用资源 ID（即 R.raw.filename）调用 Resources.openRawResource()。但是，如需访问原始文件名和文件层次结构，请考虑将资源保存在 assets/ 目录（而非 res/raw/）下。assets/ 中的文件没有资源 ID，因此您只能使用 AssetManager 读取这些文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;values/&lt;/td&gt;
      &lt;td&gt;包含字符串、整数和颜色等简单值的 XML 文件。其他 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;res/&lt;/code&gt; 子目录中的 XML 资源文件会根据 XML 文件名定义单个资源，而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;values/&lt;/code&gt; 目录中的文件可描述多个资源。对于此目录中的文件，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;resources&amp;gt;&lt;/code&gt; 元素的每个子元素均会定义一个资源。例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;string&amp;gt;&lt;/code&gt; 元素会创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R.string&lt;/code&gt; 资源，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;color&amp;gt;&lt;/code&gt; 元素会创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R.color&lt;/code&gt; 资源。由于每个资源均使用自己的 XML 元素进行定义，因此您可以随意命名文件，并在某个文件中放入不同的资源类型。但是，您可能需要将独特的资源类型放在不同的文件中，使其一目了然。例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：arrays.xml 用于资源数组（类型化数组）colors.xml 用于颜色值dimens.xml 用于维度值strings.xml 用于字符串值styles.xml 用于样式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;xml/&lt;/td&gt;
      &lt;td&gt;可在运行时通过调用 Resources.getXML() 读取的任意 XML 文件。各种 XML 配置文件（例如搜索配置）都必须保存在此处。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;font/&lt;/td&gt;
      &lt;td&gt;带有扩展名的字体文件（例如 TTF、OTF 或 TTC），或包含 &lt;font-family&gt; 元素的 XML 文件。&lt;/font-family&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上述资源文件，除了raw类型资源和drawable类型资源的Bitmap文件之外，其它的资源文件均为文本格式的XML文件，它们在打包的过程中，会被编译成二进制格式的XML文件。这些二进制格式的XML文件分别有一个字符串资源池，用来保存文件中引用到的每一个字符串，包括XML元素标签、属性名称、属性值，以及其它的一切文本值所使用到的字符串。这样原来在文本格式的XML文件中的每一个放置字符串的地方在二进制格式的XML文件中都被替换成一个索引到字符串资源池的整数值。这样做有两个好处：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;文件占用更小。例如，假设在原来的文本格式的XML文件中，有四个地方使用的都是同一个字符串，那么在最终编译出来的二进制格式的XML文件中，字符串资源池只有一份字符串值，而引用它的四个地方只占用一个整数值。&lt;/li&gt;
  &lt;li&gt;解析速度更快。由于在二进制格式的XML文件中，所有的XML元素标签和属性等值都是使用整数来描述的，因此，在解析的过程中，就不再需要进行字符串解析，这样就可以提高解析速度。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Android资源打包工具aapt在编译和打包资源的过程中，会执行以下两个额外的操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;赋予每一个非assets资源一个ID值，这些ID值以常量的形式定义在一个R.java文件中。&lt;/li&gt;
  &lt;li&gt;生成一个resources.arsc文件，用来描述那些具有ID值的资源的配置信息，它的内容就相当于是一个资源索引表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;resources.arsc文件格式定义在 &lt;a href=&quot;https://android.googlesource.com/platform/frameworks/base/+/56a2301/include/androidfw/ResourceTypes.h&quot;&gt;ResourceTypes.h&lt;/a&gt; ，资源ID是一个4字节的无符号整数 0xPPTTEEEE 的形式，其中 PP 是 PackageId，TT 是 TypeIndex，EEEE 是EntryIndex。Package ID中7f是应用包资源，01是系统资源。&lt;/p&gt;

&lt;h1 id=&quot;2资源管理器&quot;&gt;2.资源管理器&lt;/h1&gt;

&lt;p&gt;上文提到Android应用程序资源可以分为assets和res两大类，在代码中访问这两大类资源分别使用的AssetManager和Resources，可以通过Context获取到实例，实现类是ContextImpl：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ContextImpl.java
public AssetManager getAssets() {
    return getResources().getAssets();
}

@Override
public Resources getResources() {
    return mResources;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/ResourceLoader/resource1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;应用启动流程中，在创建Application实例前会先创建ContextImpl实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// LoadedApk.java
private Application makeApplicationInner(boolean forceDefaultAppClass,
        Instrumentation instrumentation, boolean allowDuplicateInstances) {
    ...
    try {
        final java.lang.ClassLoader cl = getClassLoader();
        ...
        // 创建ContextImpl实例
        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
        ...
        app = mActivityThread.mInstrumentation.newApplication(
                cl, appClass, appContext);
        appContext.setOuterContext(app);
    } catch (Exception e) {
        ...
    } 
    ...
    return app;
}

// ContextImpl.java
static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo) {
    return createAppContext(mainThread, packageInfo, null);
}

static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo,
        String opPackageName) {
    if (packageInfo == null) throw new IllegalArgumentException(&quot;packageInfo&quot;);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo,
        ContextParams.EMPTY, null, null, null, null, null, 0, null, opPackageName);
    context.setResources(packageInfo.getResources());
    context.mContextType = isSystemOrSystemUI(context) ? CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI
            : CONTEXT_TYPE_NON_UI;
    return context;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建完ContextImpl实例后会调用LoadedApk.getResources()方法初始化mResources成员变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// LoadedApk.java
public Resources getResources() {
    if (mResources == null) {
        final String[] splitPaths = getSplitPaths(null);
        ...
        mResources = ResourcesManager.getInstance().getResources(null, mResDir,
                splitPaths, mLegacyOverlayDirs, mOverlayPaths,
                mApplicationInfo.sharedLibraryFiles, null, null, getCompatibilityInfo(),
                getClassLoader(), null);
    }
    return mResources;
}

private void setApplicationInfo(ApplicationInfo aInfo) {
    final int myUid = Process.myUid();
    aInfo = adjustNativeLibraryPaths(aInfo);
    mApplicationInfo = aInfo;
    mAppDir = aInfo.sourceDir;
    mResDir = aInfo.uid == myUid ? aInfo.sourceDir : aInfo.publicSourceDir;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的mResDir与mAppDir都是aInfo.sourceDir，也就是/data/app/xx/xx/base.apk。&lt;/p&gt;

&lt;p&gt;继续查看创建Resources的逻辑，这里传入的activityToken为null：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesManager.java
public Resources getResources(
        @Nullable IBinder activityToken,
        @Nullable String resDir,
        @Nullable String[] splitResDirs,
        @Nullable String[] legacyOverlayDirs,
        @Nullable String[] overlayPaths,
        @Nullable String[] libDirs,
        @Nullable Integer overrideDisplayId,
        @Nullable Configuration overrideConfig,
        @NonNull CompatibilityInfo compatInfo,
        @Nullable ClassLoader classLoader,
        @Nullable List&amp;lt;ResourcesLoader&amp;gt; loaders) {
    try {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, &quot;ResourcesManager#getResources&quot;);
        final ResourcesKey key = new ResourcesKey(
                resDir,
                splitResDirs,
                combinedOverlayPaths(legacyOverlayDirs, overlayPaths),
                libDirs,
                overrideDisplayId != null ? overrideDisplayId : INVALID_DISPLAY,
                overrideConfig,
                compatInfo,
                loaders == null ? null : loaders.toArray(new ResourcesLoader[0]));
        classLoader = classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();

        final ApkAssetsSupplier assetsSupplier = createApkAssetsSupplierNotLocked(key);
        ...
        Resources resources;
        // 每个Activity会创建一个对应的Resources
        if (activityToken != null) {
            Configuration initialOverrideConfig = new Configuration(key.mOverrideConfiguration);
            rebaseKeyForActivity(activityToken, key, overrideDisplayId != null);
            resources = createResourcesForActivity(activityToken, key, initialOverrideConfig,
                    overrideDisplayId, classLoader, assetsSupplier);
        } else {
            resources = createResources(key, classLoader, assetsSupplier);
        }
        return resources;
    } finally {
    }
}

private Resources createResources(@NonNull ResourcesKey key, @NonNull ClassLoader classLoader,
        @Nullable ApkAssetsSupplier apkSupplier) {
    synchronized (mLock) {
        ResourcesImpl resourcesImpl = findOrCreateResourcesImplForKeyLocked(key, apkSupplier);
        ...
        return createResourcesLocked(classLoader, resourcesImpl, key.mCompatInfo);
    }
}

private @NonNull Resources createResourcesLocked(@NonNull ClassLoader classLoader,
        @NonNull ResourcesImpl impl, @NonNull CompatibilityInfo compatInfo) {
    cleanupReferences(mResourceReferences, mResourcesReferencesQueue);

    Resources resources = compatInfo.needsCompatResources() ? new CompatResources(classLoader)
            : new Resources(classLoader);
    resources.setImpl(impl);
    resources.setCallbacks(mUpdateCallbacks);
    mResourceReferences.add(new WeakReference&amp;lt;&amp;gt;(resources, mResourcesReferencesQueue));
    return resources;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建ResourcesImpl的实例，可以看到ResourcesImpl的实例会被弱引用缓存到mResourceImpls中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesManager.java
private @Nullable ResourcesImpl findOrCreateResourcesImplForKeyLocked(
        @NonNull ResourcesKey key, @Nullable ApkAssetsSupplier apkSupplier) {
    ResourcesImpl impl = findResourcesImplForKeyLocked(key);
    if (impl == null) {
        impl = createResourcesImpl(key, apkSupplier);
        if (impl != null) {
            mResourceImpls.put(key, new WeakReference&amp;lt;&amp;gt;(impl));
        }
    }
    return impl;
}

private @Nullable ResourcesImpl createResourcesImpl(@NonNull ResourcesKey key,
        @Nullable ApkAssetsSupplier apkSupplier) {
    final AssetManager assets = createAssetManager(key, apkSupplier);
    ...
    final ResourcesImpl impl = new ResourcesImpl(assets, displayMetrics, config, daj);
    return impl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建AssetManager的实例，关键操作是addApkAssets方法，参数是ApkAssets对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesManager.java
protected @Nullable AssetManager createAssetManager(@NonNull final ResourcesKey key) {
    return createAssetManager(key, /* apkSupplier */ null);
}

private @Nullable AssetManager createAssetManager(@NonNull final ResourcesKey key,
        @Nullable ApkAssetsSupplier apkSupplier) {
    final AssetManager.Builder builder = new AssetManager.Builder();

    final ArrayList&amp;lt;ApkKey&amp;gt; apkKeys = extractApkKeys(key);
    for (int i = 0, n = apkKeys.size(); i &amp;lt; n; i++) {
        final ApkKey apkKey = apkKeys.get(i);
        try {
            // 添加到mUserApkAssets
            builder.addApkAssets(
                    (apkSupplier != null) ? apkSupplier.load(apkKey) : loadApkAssets(apkKey));
        } catch (IOException e) {
        }
    }

    if (key.mLoaders != null) {
        for (final ResourcesLoader loader : key.mLoaders) {
            // 添加到mLoaders
            builder.addLoader(loader);
        }
    }

    return builder.build();
}

private static @NonNull ArrayList&amp;lt;ApkKey&amp;gt; extractApkKeys(@NonNull final ResourcesKey key) {
    final ArrayList&amp;lt;ApkKey&amp;gt; apkKeys = new ArrayList&amp;lt;&amp;gt;();

    if (key.mResDir != null) {
        apkKeys.add(new ApkKey(key.mResDir, false /*sharedLib*/, false /*overlay*/));
    }
    if (key.mSplitResDirs != null) { ... }
    if (key.mLibDirs != null) { ... }
    if (key.mOverlayPaths != null)  { ... }

    return apkKeys;
}

// AssetManager.java
public AssetManager build() {
    final ApkAssets[] systemApkAssets = getSystem().getApkAssets();
    ...
    final int totalApkAssetCount = systemApkAssets.length + mUserApkAssets.size()
            + loaderApkAssets.size();
    final ApkAssets[] apkAssets = new ApkAssets[totalApkAssetCount];
    // 简化为apkAssets = systemApkAssets + mUserApkAssets + mLoaders去重
    ...

    final AssetManager assetManager = new AssetManager(false /*sentinel*/);
    assetManager.mApkAssets = apkAssets;
    AssetManager.nativeSetApkAssets(assetManager.mObject, apkAssets,
            false /*invalidateCaches*/);
    assetManager.mLoaders = mLoaders.isEmpty() ? null
            : mLoaders.toArray(new ResourcesLoader[0]);

    return assetManager;
}

// 创建加载系统资源的ApkAssets
public static AssetManager getSystem() {
    synchronized (sSync) {
        createSystemAssetsInZygoteLocked(false, FRAMEWORK_APK_PATH);
        return sSystem;
    }
}

public static void createSystemAssetsInZygoteLocked(boolean reinitialize,
        String frameworkPath) {
    try {
        final ArrayList&amp;lt;ApkAssets&amp;gt; apkAssets = new ArrayList&amp;lt;&amp;gt;();
        // &quot;/system/framework/framework-res.apk&quot;
        apkAssets.add(ApkAssets.loadFromPath(frameworkPath, ApkAssets.PROPERTY_SYSTEM));

        final String[] systemIdmapPaths =
                OverlayConfig.getZygoteInstance().createImmutableFrameworkIdmapsInZygote();
        for (String idmapPath : systemIdmapPaths) {
            // Android系统资源覆盖机制
            apkAssets.add(ApkAssets.loadOverlayFromPath(idmapPath, ApkAssets.PROPERTY_SYSTEM));
        }
        sSystemApkAssetsSet = new ArraySet&amp;lt;&amp;gt;(apkAssets);
        sSystemApkAssets = apkAssets.toArray(new ApkAssets[apkAssets.size()]);
        if (sSystem == null) {
            sSystem = new AssetManager(true /*sentinel*/);
        }
        sSystem.setApkAssets(sSystemApkAssets, false /*invalidateCaches*/);
    } catch (IOException e) {
    }
}

private AssetManager(boolean sentinel) {
    mObject = nativeCreate();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Android资源覆盖机制参考官方文档：&lt;a href=&quot;https://source.android.com/docs/core/runtime/rros&quot;&gt;Change the value of an app’s resources at runtime&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接下来创建ApkAssets的实例，在构造方法中调用native方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesManager.java
ApkAssets load(final ApkKey apkKey) throws IOException {
    ApkAssets apkAssets = mLocalCache.get(apkKey);
    if (apkAssets == null) {
        apkAssets = loadApkAssets(apkKey);
        mLocalCache.put(apkKey, apkAssets);
    }
    return apkAssets;
}

private @NonNull ApkAssets loadApkAssets(@NonNull final ApkKey key) throws IOException {
    ApkAssets apkAssets;
    ...
    if (key.overlay) {
        apkAssets = ApkAssets.loadOverlayFromPath(overlayPathToIdmapPath(key.path), flags);
    } else {
        apkAssets = ApkAssets.loadFromPath(key.path, flags);
    }

    synchronized (mLock) {
        mCachedApkAssets.put(key, new WeakReference&amp;lt;&amp;gt;(apkAssets));
    }

    return apkAssets;
}

// ApkAssets.java
public static @NonNull ApkAssets loadFromPath(@NonNull String path, @PropertyFlags int flags)
        throws IOException {
    return new ApkAssets(FORMAT_APK, path, flags, null /* assets */);
}

private ApkAssets(@FormatType int format, @NonNull String path, @PropertyFlags int flags,
        @Nullable AssetsProvider assets) throws IOException {
    Objects.requireNonNull(path, &quot;path&quot;);
    mFlags = flags;
    mNativePtr = nativeLoad(format, path, flags, assets);
    mStringBlock = new StringBlock(nativeGetStringBlock(mNativePtr), true /*useSparse*/);
    mAssets = assets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kResourcesArsc是常量”resources.arsc”，加载资源文件，创建native侧ApkAssets。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// android_content_res_ApkAssets.cpp
static jlong NativeLoad(JNIEnv* env, jclass /*clazz*/, const format_type_t format,
                        jstring java_path, const jint property_flags, jobject assets_provider) {
  ScopedUtfChars path(env, java_path);

  auto loader_assets = LoaderAssetsProvider::Create(env, assets_provider);
  std::unique_ptr&amp;lt;ApkAssets&amp;gt; apk_assets;
  switch (format) {
    case FORMAT_APK: {
        auto assets = MultiAssetsProvider::Create(std::move(loader_assets),
                                                  ZipAssetsProvider::Create(path.c_str(),
                                                                            property_flags));
        apk_assets = ApkAssets::Load(std::move(assets), property_flags);
        break;
    }
    ...
  }

  return CreateGuardedApkAssets(std::move(apk_assets));
}

// Asset.cpp
std::unique_ptr&amp;lt;ApkAssets&amp;gt; ApkAssets::Load(std::unique_ptr&amp;lt;AssetsProvider&amp;gt; assets,
                                           package_property_t flags) {
  return LoadImpl(std::move(assets), flags, nullptr /* idmap_asset */, nullptr /* loaded_idmap */);
}

std::unique_ptr&amp;lt;ApkAssets&amp;gt; ApkAssets::LoadImpl(std::unique_ptr&amp;lt;AssetsProvider&amp;gt; assets,
                                               package_property_t property_flags,
                                               std::unique_ptr&amp;lt;Asset&amp;gt; idmap_asset,
                                               std::unique_ptr&amp;lt;LoadedIdmap&amp;gt; loaded_idmap) {
  // Open the resource table via mmap unless it is compressed. This logic is taken care of by Open.
  bool resources_asset_exists = false;
  auto resources_asset = assets-&amp;gt;Open(kResourcesArsc, Asset::AccessMode::ACCESS_BUFFER,
                                      &amp;amp;resources_asset_exists);
  return LoadImpl(std::move(resources_asset), std::move(assets), property_flags,
                  std::move(idmap_asset), std::move(loaded_idmap));
}

std::unique_ptr&amp;lt;ApkAssets&amp;gt; ApkAssets::LoadImpl(std::unique_ptr&amp;lt;Asset&amp;gt; resources_asset,
                                               std::unique_ptr&amp;lt;AssetsProvider&amp;gt; assets,
                                               package_property_t property_flags,
                                               std::unique_ptr&amp;lt;Asset&amp;gt; idmap_asset,
                                               std::unique_ptr&amp;lt;LoadedIdmap&amp;gt; loaded_idmap) {
  std::unique_ptr&amp;lt;LoadedArsc&amp;gt; loaded_arsc;
  if (resources_asset != nullptr) {
    const auto data = resources_asset-&amp;gt;getIncFsBuffer(true /* aligned */);
    const size_t length = resources_asset-&amp;gt;getLength();
    if (!data || length == 0) {
      return {};
    }
    loaded_arsc = LoadedArsc::Load(data, length, loaded_idmap.get(), property_flags);
  } else {
    loaded_arsc = LoadedArsc::CreateEmpty();
  }
  return std::unique_ptr&amp;lt;ApkAssets&amp;gt;(new ApkAssets(std::move(resources_asset),
                                                  std::move(loaded_arsc), std::move(assets),
                                                  property_flags, std::move(idmap_asset),
                                                  std::move(loaded_idmap)));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个过程主要是创建了AssetManager，ResourcesImpl，Resources这三个类的实例，三者之间的关系为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ResourceLoader/resource2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在ResourcesManager中会缓存创建的ResourcesImpl和Resources。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;/**
 * A mapping of ResourceImpls and their configurations. These are heavy weight objects
 * which should be reused as much as possible.
 */
@UnsupportedAppUsage
private final ArrayMap&amp;lt;ResourcesKey, WeakReference&amp;lt;ResourcesImpl&amp;gt;&amp;gt; mResourceImpls =
        new ArrayMap&amp;lt;&amp;gt;();

/**
 * A list of Resource references that can be reused.
 */
@UnsupportedAppUsage
private final ArrayList&amp;lt;WeakReference&amp;lt;Resources&amp;gt;&amp;gt; mResourceReferences = new ArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用想要动态添加资源，可以基于资源路径构造ApkAssets，调用AssetManager的setApkAssets接口添加。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// AssetManager.java
public void setApkAssets(@NonNull ApkAssets[] apkAssets, boolean invalidateCaches) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3资源文件加载&quot;&gt;3.资源文件加载&lt;/h1&gt;

&lt;p&gt;Android资源文件在打包时，非assets资源会编译到resources.arsc文件，使用Resources根据资源ID加载；非assets文件会直接打包到apk，使用AssetManager根据文件名加载。事实上，Resources加载资源也是由AssetManager实现的，接下来以加载Activity布局文件为例，介绍下资源加载流程。&lt;/p&gt;

&lt;h2 id=&quot;31-加载res资源文件&quot;&gt;3.1 加载res资源文件&lt;/h2&gt;

&lt;p&gt;LayoutInflater类主要功能是从xml实例化View视图，Resources通过资源ID加载布局xml文件，然后解析xml文件实例化View视图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// LayoutInflater.java
public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
    XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}

// 解析xml文件实例化View视图
public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;

        try {
            advanceToRootNode(parser);
            final String name = parser.getName();
            if (TAG_MERGE.equals(name)) { // &quot;merge&quot;
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        temp.setLayoutParams(params);
                    }
                }

                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);

                if (root != null &amp;amp;&amp;amp; attachToRoot) {
                    root.addView(temp, params);
                }

                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
        } catch (Exception e) {
        } finally {
        }

        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Resources通过ResourcesImpl查找对应的布局文件，如果没有找到会抛出NotFoundException：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Resources.java
public XmlResourceParser getLayout(@LayoutRes int id) throws NotFoundException {
    return loadXmlResourceParser(id, &quot;layout&quot;);
}

XmlResourceParser loadXmlResourceParser(@AnyRes int id, @NonNull String type)
        throws NotFoundException {
    final TypedValue value = obtainTempTypedValue();
    try {
        final ResourcesImpl impl = mResourcesImpl;
        impl.getValue(id, value, true);
        if (value.type == TypedValue.TYPE_STRING) {
            return loadXmlResourceParser(value.string.toString(), id,
                    value.assetCookie, type);
        }
        throw new NotFoundException(&quot;Resource ID #0x&quot; + Integer.toHexString(id)
                + &quot; type #0x&quot; + Integer.toHexString(value.type) + &quot; is not valid&quot;);
    } finally {
        releaseTempTypedValue(value);
    }
}

XmlResourceParser loadXmlResourceParser(String file, int id, int assetCookie,
                                        String type) throws NotFoundException {
    return mResourcesImpl.loadXmlResourceParser(file, id, assetCookie, type);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResourcesImpl通过AssetManager的native方法查找资源：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ResourcesImpl.java
void getValue(@AnyRes int id, TypedValue outValue, boolean resolveRefs)
        throws NotFoundException {
    boolean found = mAssets.getResourceValue(id, 0, outValue, resolveRefs);
    if (found) {
        return;
    }
    throw new NotFoundException(&quot;Resource ID #0x&quot; + Integer.toHexString(id));
}

boolean getResourceValue(@AnyRes int resId, int densityDpi, @NonNull TypedValue outValue,
        boolean resolveRefs) {
    Objects.requireNonNull(outValue, &quot;outValue&quot;);
    synchronized (this) {
        ensureValidLocked();
        final int cookie = nativeGetResourceValue(
                mObject, resId, (short) densityDpi, outValue, resolveRefs);
        if (cookie &amp;lt;= 0) {
            return false;
        }
        ...
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建AssetManager2实例，调用其GetResource方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// android_util_AssetManager.cpp
static jint NativeGetResourceValue(JNIEnv* env, jclass /*clazz*/, jlong ptr, jint resid,
                                   jshort density, jobject typed_value,
                                   jboolean resolve_references) {
  ScopedLock&amp;lt;AssetManager2&amp;gt; assetmanager(AssetManagerFromLong(ptr));
  auto value = assetmanager-&amp;gt;GetResource(static_cast&amp;lt;uint32_t&amp;gt;(resid), false /*may_be_bag*/,
                                         static_cast&amp;lt;uint16_t&amp;gt;(density));
  if (!value.has_value()) {
    return ApkAssetsCookieToJavaCookie(kInvalidCookie);
  }

  if (resolve_references) {
    auto result = assetmanager-&amp;gt;ResolveReference(value.value());
    if (!result.has_value()) {
      return ApkAssetsCookieToJavaCookie(kInvalidCookie);
    }
  }
  return CopyValue(env, *value, typed_value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AssetManager2查找资源的核心逻辑，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// AssetManager2.cpp 
base::expected&amp;lt;AssetManager2::SelectedValue, NullOrIOError&amp;gt; AssetManager2::GetResource(
      uint32_t resid, bool may_be_bag, uint16_t density_override) const {
  auto result = FindEntry(resid, density_override, false /* stop_at_first_match */,
                          false /* ignore_configuration */);
  auto result_map_entry = std::get_if&amp;lt;incfs::verified_map_ptr&amp;lt;ResTable_map_entry&amp;gt;&amp;gt;(&amp;amp;result-&amp;gt;entry);
  if (result_map_entry != nullptr) {
      if (!may_be_bag) {
        LOG(ERROR) &amp;lt;&amp;lt; base::StringPrintf(&quot;Resource %08x is a complex map type.&quot;, resid);
        return base::unexpected(std::nullopt);
      }

      // Create a reference since we can&apos;t represent this complex type as a Res_value.
      return SelectedValue(Res_value::TYPE_REFERENCE, resid, result-&amp;gt;cookie, result-&amp;gt;type_flags,
                           resid, result-&amp;gt;config);
  }

  // Convert the package ID to the runtime assigned package ID.
  Res_value value = std::get&amp;lt;Res_value&amp;gt;(result-&amp;gt;entry);
  result-&amp;gt;dynamic_ref_table-&amp;gt;lookupResourceValue(&amp;amp;value);

  return SelectedValue(value.dataType, value.data, result-&amp;gt;cookie, result-&amp;gt;type_flags,
                       resid, result-&amp;gt;config);
}

base::expected&amp;lt;FindEntryResult, NullOrIOError&amp;gt; AssetManager2::FindEntry(
    uint32_t resid, uint16_t density_override, bool stop_at_first_match,
    bool ignore_configuration) const {
  // Might use this if density_override != 0.
  ResTable_config density_override_config;

  // Select our configuration or generate a density override configuration.
  const ResTable_config* desired_config = &amp;amp;configuration_;
  if (density_override != 0 &amp;amp;&amp;amp; density_override != configuration_.density) {
    density_override_config = configuration_;
    density_override_config.density = density_override;
    desired_config = &amp;amp;density_override_config;
  }

  // 这里对应上文资源ID生成规则
  const uint32_t package_id = get_package_id(resid);
  const uint8_t type_idx = get_type_id(resid) - 1;
  const uint16_t entry_idx = get_entry_id(resid);
  uint8_t package_idx = package_ids_[package_id];
  if (UNLIKELY(package_idx == 0xff)) {
    ANDROID_LOG(ERROR) &amp;lt;&amp;lt; base::StringPrintf(&quot;No package ID %02x found for ID 0x%08x.&quot;,
                                             package_id, resid);
    return base::unexpected(std::nullopt);
  }

  // 主要用来处理Runtime Resources Overlay
  const PackageGroup&amp;amp; package_group = package_groups_[package_idx];
  auto result = FindEntryInternal(package_group, type_idx, entry_idx, *desired_config,
                                  stop_at_first_match, ignore_configuration);
  if (UNLIKELY(!result.has_value())) {
    return base::unexpected(result.error());
  }

  bool overlaid = false;
  if (!stop_at_first_match &amp;amp;&amp;amp; !ignore_configuration &amp;amp;&amp;amp; !apk_assets_[result-&amp;gt;cookie]-&amp;gt;IsLoader()) {
    // 查找资源覆盖的逻辑
  }

  return result;
}

// 核心逻辑是根据资源id，找到package_group，遍历package_group根据资源类型找到最佳匹配
base::expected&amp;lt;FindEntryResult, NullOrIOError&amp;gt; AssetManager2::FindEntryInternal(
    const PackageGroup&amp;amp; package_group, uint8_t type_idx, uint16_t entry_idx,
    const ResTable_config&amp;amp; desired_config, bool stop_at_first_match,
    bool ignore_configuration) const {
  ApkAssetsCookie best_cookie = kInvalidCookie;
  const LoadedPackage* best_package = nullptr;
  incfs::verified_map_ptr&amp;lt;ResTable_type&amp;gt; best_type;
  const ResTable_config* best_config = nullptr;
  uint32_t best_offset = 0U;
  uint32_t type_flags = 0U;

  const bool use_filtered = !ignore_configuration &amp;amp;&amp;amp; &amp;amp;desired_config == &amp;amp;configuration_;

  // RRO机制可能存在多个package
  const size_t package_count = package_group.packages_.size();
  for (size_t pi = 0; pi &amp;lt; package_count; pi++) {
    const ConfiguredPackage&amp;amp; loaded_package_impl = package_group.packages_[pi];
    const LoadedPackage* loaded_package = loaded_package_impl.loaded_package_;
    const ApkAssetsCookie cookie = package_group.cookies_[pi];

    const TypeSpec* type_spec = loaded_package-&amp;gt;GetTypeSpecByTypeIndex(type_idx);
    const bool package_is_loader = loaded_package-&amp;gt;IsCustomLoader();

    auto entry_flags = type_spec-&amp;gt;GetFlagsForEntryIndex(entry_idx);
    type_flags |= entry_flags.value();

    // 根据设备的当前配置信息，去选择最合适的资源项
    const FilteredConfigGroup&amp;amp; filtered_group = loaded_package_impl.filtered_configs_[type_idx];
    const size_t type_entry_count = (use_filtered) ? filtered_group.type_entries.size()
                                                   : type_spec-&amp;gt;type_entries.size();
    // 遍历资源类型查找最佳匹配
    for (size_t i = 0; i &amp;lt; type_entry_count; i++) {
      const TypeSpec::TypeEntry* type_entry = (use_filtered) ? filtered_group.type_entries[i]
                                                             : &amp;amp;type_spec-&amp;gt;type_entries[i];

      const ResTable_config&amp;amp; this_config = type_entry-&amp;gt;config;
      if (!(use_filtered || ignore_configuration || this_config.match(desired_config))) {
        continue;
      }
      
      // 查找最佳匹配
      Resolution::Step::Type resolution_type;
      if (best_config == nullptr) {
        resolution_type = Resolution::Step::Type::INITIAL;
      } else if (this_config.isBetterThan(*best_config, &amp;amp;desired_config)) {
        resolution_type = Resolution::Step::Type::BETTER_MATCH;
      } else if (package_is_loader &amp;amp;&amp;amp; this_config.compare(*best_config) == 0) {
        resolution_type = Resolution::Step::Type::OVERLAID;
      } else {
        continue;
      }

      const auto&amp;amp; type = type_entry-&amp;gt;type;
      const auto offset = LoadedPackage::GetEntryOffset(type, entry_idx);
      if (!offset.has_value()) {
        continue;
      }

      best_cookie = cookie;
      best_package = loaded_package;
      best_type = type;
      best_config = &amp;amp;this_config;
      best_offset = offset.value();

      if (stop_at_first_match) {
        break;
      }
    }
  }

  auto best_entry_result = LoadedPackage::GetEntryFromOffset(best_type, best_offset);
  const incfs::map_ptr&amp;lt;ResTable_entry&amp;gt; best_entry = *best_entry_result;
  const auto entry = GetEntryValue(best_entry.verified());

  return FindEntryResult{
    .cookie = best_cookie,
    .entry = *entry,
    .config = *best_config,
    .type_flags = type_flags,
    .package_name = &amp;amp;best_package-&amp;gt;GetPackageName(),
    .type_string_ref = StringPoolRef(best_package-&amp;gt;GetTypeStringPool(), best_type-&amp;gt;id - 1),
    .entry_string_ref = StringPoolRef(best_package-&amp;gt;GetKeyStringPool(),
                                      best_entry-&amp;gt;key.index),
    .dynamic_ref_table = package_group.dynamic_ref_table.get(),
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;32-加载assets资源&quot;&gt;3.2 加载assets资源&lt;/h2&gt;

&lt;p&gt;通过Context获取到AssetManager实例，调用其open方法传入文件名：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// AssetManager.java
public @NonNull InputStream open(@NonNull String fileName) throws IOException {
    return open(fileName, ACCESS_STREAMING);
}

public @NonNull InputStream open(@NonNull String fileName, int accessMode) throws IOException {
    Objects.requireNonNull(fileName, &quot;fileName&quot;);
    synchronized (this) {
        ensureOpenLocked();
        final long asset = nativeOpenAsset(mObject, fileName, accessMode);
        if (asset == 0) {
            throw new FileNotFoundException(&quot;Asset file: &quot; + fileName);
        }
        final AssetInputStream assetInputStream = new AssetInputStream(asset);
        incRefsLocked(assetInputStream.hashCode());
        return assetInputStream;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在native侧同样创建AssetManager2，调用其Open方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// android_util_AssetManager.cpp
static jlong NativeOpenAsset(JNIEnv* env, jclass /*clazz*/, jlong ptr, jstring asset_path,
                             jint access_mode) {
  ScopedUtfChars asset_path_utf8(env, asset_path);
  ...
  ScopedLock&amp;lt;AssetManager2&amp;gt; assetmanager(AssetManagerFromLong(ptr));
  std::unique_ptr&amp;lt;Asset&amp;gt; asset =
      assetmanager-&amp;gt;Open(asset_path_utf8.c_str(), static_cast&amp;lt;Asset::AccessMode&amp;gt;(access_mode));
  if (!asset) {
    jniThrowException(env, &quot;java/io/FileNotFoundException&quot;, asset_path_utf8.c_str());
    return 0;
  }
  return reinterpret_cast&amp;lt;jlong&amp;gt;(asset.release());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;apk_assets_存储的是已经加载的所有apk包，遍历apk_assets_通过AssetsProvider查找文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// AssetManager2.cpp 
std::unique_ptr&amp;lt;Asset&amp;gt; AssetManager2::Open(const std::string&amp;amp; filename,
                                           Asset::AccessMode mode) const {
  const std::string new_path = &quot;assets/&quot; + filename;
  return OpenNonAsset(new_path, mode);
}

std::unique_ptr&amp;lt;Asset&amp;gt; AssetManager2::OpenNonAsset(const std::string&amp;amp; filename,
                                                   Asset::AccessMode mode,
                                                   ApkAssetsCookie* out_cookie) const {
  for (int32_t i = apk_assets_.size() - 1; i &amp;gt;= 0; i--) {
    // 通过文件名加载文件时忽略RRO
    if (apk_assets_[i]-&amp;gt;IsOverlay()) {
      continue;
    }

    std::unique_ptr&amp;lt;Asset&amp;gt; asset = apk_assets_[i]-&amp;gt;GetAssetsProvider()-&amp;gt;Open(filename, mode);
    if (asset) {
      if (out_cookie != nullptr) {
        *out_cookie = i;
      }
      return asset;
    }
  }

  if (out_cookie != nullptr) {
    *out_cookie = kInvalidCookie;
  }
  return {};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AssetsProvider是在上文创建ApkAssets时创建的，读取文件分为文件压缩/文件未压缩两种：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// AssetsProvider.cpp
std::unique_ptr&amp;lt;Asset&amp;gt; AssetsProvider::Open(const std::string&amp;amp; path, Asset::AccessMode mode,
                                            bool* file_exists) const {
  return OpenInternal(path, mode, file_exists);
}

std::unique_ptr&amp;lt;Asset&amp;gt; ZipAssetsProvider::OpenInternal(const std::string&amp;amp; path,
                                                       Asset::AccessMode mode,
                                                       bool* file_exists) const {
    if (file_exists != nullptr) {
      *file_exists = false; // 初始化为false
    }

    ZipEntry entry;
    // zip_archive.cc 
    if (FindEntry(zip_handle_.get(), path, &amp;amp;entry) != 0) {
      return {};
    }

    if (file_exists != nullptr) {
      *file_exists = true; // 找到文件，设置为true
    }

    const int fd = GetFileDescriptor(zip_handle_.get());
    const off64_t fd_offset = GetFileDescriptorOffset(zip_handle_.get());
    const bool incremental_hardening = (flags_ &amp;amp; PROPERTY_DISABLE_INCREMENTAL_HARDENING) == 0U;
    incfs::IncFsFileMap asset_map;
    if (entry.method == kCompressDeflated) { // 是否是压缩文件
      if (!asset_map.Create(fd, entry.offset + fd_offset, entry.compressed_length,
                            name_.GetDebugName().c_str(), incremental_hardening)) {
        LOG(ERROR) &amp;lt;&amp;lt; &quot;Failed to mmap file &apos;&quot; &amp;lt;&amp;lt; path &amp;lt;&amp;lt; &quot;&apos; in APK &apos;&quot; &amp;lt;&amp;lt; name_.GetDebugName()
                   &amp;lt;&amp;lt; &quot;&apos;&quot;;
        return {};
      }

      std::unique_ptr&amp;lt;Asset&amp;gt; asset =
          Asset::createFromCompressedMap(std::move(asset_map), entry.uncompressed_length, mode);
      return asset;
    }

    if (!asset_map.Create(fd, entry.offset + fd_offset, entry.uncompressed_length,
                          name_.GetDebugName().c_str(), incremental_hardening)) {
      LOG(ERROR) &amp;lt;&amp;lt; &quot;Failed to mmap file &apos;&quot; &amp;lt;&amp;lt; path &amp;lt;&amp;lt; &quot;&apos; in APK &apos;&quot; &amp;lt;&amp;lt; name_.GetDebugName() &amp;lt;&amp;lt; &quot;&apos;&quot;;
      return {};
    }
    ...
    auto asset = Asset::createFromUncompressedMap(std::move(asset_map), mode, std::move(ufd));
    return asset;
}

std::unique_ptr&amp;lt;Asset&amp;gt; Asset::createFromUncompressedMap(incfs::IncFsFileMap&amp;amp;&amp;amp; dataMap,
                                                                   AccessMode mode,
                                                                   base::unique_fd fd)
{
    auto pAsset = util::make_unique&amp;lt;_FileAsset&amp;gt;();
    status_t result = pAsset-&amp;gt;openChunk(std::move(dataMap), std::move(fd));
    pAsset-&amp;gt;mAccessMode = mode;
    return std::move(pAsset);
}

status_t _FileAsset::openChunk(incfs::IncFsFileMap&amp;amp;&amp;amp; dataMap, base::unique_fd fd)
{
    assert(mFp == NULL);    // no reopen
    assert(!mMap.has_value());
    assert(dataMap != NULL);

    mMap = std::move(dataMap);
    mStart = -1;            // not used
    mLength = mMap-&amp;gt;length();
    mFd = std::move(fd);
    assert(mOffset == 0);

    return NO_ERROR;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;参考文档&quot;&gt;参考文档：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/8738877&quot;&gt;Android资源管理框架（Asset Manager）简要介绍和学习计划&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/8744683&quot;&gt;Android应用程序资源的编译和打包过程分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/8791064&quot;&gt;Android应用程序资源管理器（Asset Manager）的创建过程分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/8806798&quot;&gt;Android应用程序资源的查找过程分析&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 30 Mar 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/03/30/Android%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/03/30/Android%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>ResourceLoader</category>
        
        
      </item>
    
      <item>
        <title>Android类加载流程</title>
        <description>&lt;h1 id=&quot;1基本概念&quot;&gt;1.基本概念&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;1.1 类加载器的作用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;类的加载需要类加载器完成，在JVM中，一个类的唯一性是需要这个类本身和类加载器一起才能确定的，每个类加载器都有一个独立的命名空间。&lt;/p&gt;

&lt;p&gt;不同的类加载器，即使是同一个类字节码文件，最后再JVM里的类对象也不是同一个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 双亲委派模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，&lt;/p&gt;

&lt;p&gt;因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    // 交给父类加载器尝试加载
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                // 父类加载器无法加载时自身尝试加载
                c = findClass(name);

                // this is the defining class loader; record the stats
                PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。&lt;/p&gt;

&lt;p&gt;例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，&lt;/p&gt;

&lt;p&gt;因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，&lt;/p&gt;

&lt;p&gt;并放在程序的Class Path中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3 Java与Android类加载器比较&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JVM加载的是class文件，ART加载的是dex文件。&lt;/p&gt;

&lt;p&gt;Java中四种类加载器：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ClassLoader/java.png&quot; alt=&quot;java&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Android中类加载器：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ClassLoader/android.png&quot; alt=&quot;android&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2android类加载器&quot;&gt;2.Android类加载器&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;ClassLoader：&lt;/strong&gt;对Java的ClassLoader代码做了精简，其中loadClass()核心逻辑不变，仍采用双亲委派模型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BootClassLoader&lt;/strong&gt;：继承于ClassLoader，是ClassLoader的内部类。是SystemClassLoader的父加载器，同时也是Android中所有ClassLoader的最终parent。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ClassLoader.java 
private static ClassLoader createSystemClassLoader() {
    String classPath = System.getProperty(&quot;java.class.path&quot;, &quot;.&quot;);
    String librarySearchPath = System.getProperty(&quot;java.library.path&quot;, &quot;&quot;);
    return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());
}

public ClassLoader getClassLoader() {
    return (classLoader == null) ? BootClassLoader.getInstance() : classLoader;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;BaseDexClassLoader&lt;/strong&gt;：继承于ClassLoader，是PathClassLoader和DexClassLoader的父类。&lt;/p&gt;

&lt;p&gt;BaseDexClassLoader重写了ClassLoader的findClass()方法，核心在于维护了DexPathList这个类对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// BaseDexClassLoader.java 
private final DexPathList pathList;

public BaseDexClassLoader(String dexPath,
        String librarySearchPath, ClassLoader parent, ClassLoader[] sharedLibraryLoaders,
        ClassLoader[] sharedLibraryLoadersAfter,
        boolean isTrusted) {
    super(parent);
    ...
    this.pathList = new DexPathList(this, dexPath, librarySearchPath, null, isTrusted);
    ...
}
 
@Override
protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
    ...
    Class c = pathList.findClass(name, suppressedExceptions);
    if (c != null) {
        return c;
    }
    ...
    return c;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;PathClassLoader&lt;/strong&gt;：继承于BaseDexClassLoader，用来加载系统类和apk中的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DexClassLoader&lt;/strong&gt;：继承于BaseDexClassLoader，可以用来加载外置的dex文件或者apk，jar等。&lt;/p&gt;

&lt;p&gt;在Android8.1之后，optimizedDirectory参数已废弃，默认传入null。也就是说Android8.1版本及以后，PathClassLoader和DexClassLoader没有区别。&lt;/p&gt;

&lt;h1 id=&quot;3dexpathlist&quot;&gt;3.DexPathList&lt;/h1&gt;

&lt;p&gt;DexPathList核心功能是维护dexElements数组，用来记录dex文件集合。在BaseDexClassLoader构造函数中将dexPath传入，在DexPathList的splitDexPath()方法解析文件路径，在makeDexElements()方法添加到dexElements数组中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DexPathList.java
private Element[] dexElements;
 
DexPathList(ClassLoader definingContext, String dexPath,
        String librarySearchPath, File optimizedDirectory, boolean isTrusted) {
    ...
    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,
                                       suppressedExceptions, definingContext, isTrusted);
    ...
}

// 生成dexElements数组
private static Element[] makeDexElements(List&amp;lt;File&amp;gt; files, File optimizedDirectory,
        List&amp;lt;IOException&amp;gt; suppressedExceptions, ClassLoader loader, boolean isTrusted) {
  Element[] elements = new Element[files.size()];
  int elementsPos = 0;
  for (File file : files) {
      if (file.isDirectory()) {
              ...
      } else if (file.isFile()) {
          String name = file.getName();

          DexFile dex = null;
          if (name.endsWith(DEX_SUFFIX)) {
              // Raw dex file (not inside a zip/jar).
              try {
                  dex = loadDexFile(file, optimizedDirectory, loader, elements);
                  if (dex != null) {
                      elements[elementsPos++] = new Element(dex, null);
                  }
              } catch (IOException suppressed) {
                  ...
              }
          } else {
              ...
          }
          if (dex != null &amp;amp;&amp;amp; isTrusted) {
            dex.setTrusted();
          }
      } else {
          System.logW(&quot;ClassLoader referenced unknown path: &quot; + file);
      }
  }
  if (elementsPos != elements.length) {
      elements = Arrays.copyOf(elements, elementsPos);
  }
  return elements;
}

// 加载dex文件，创建DexFile对象
private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader,
                                   Element[] elements)
        throws IOException {
    if (optimizedDirectory == null) {
        return new DexFile(file, loader, elements);
    } else {
        String optimizedPath = optimizedPathFor(file, optimizedDirectory);
        return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);
    }
}

static class Element {
    private final File path;
    private final Boolean pathIsDirectory;
    private final DexFile dexFile;
 
    public Class&amp;lt;?&amp;gt; findClass(String name, ClassLoader definingContext,List&amp;lt;Throwable&amp;gt; suppressed) {
        return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed) : null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上文提到BaseDexClassLoader重写了ClassLoader的findClass()方法，其实现是直接调用DexPathList的findClass()方法，其核心逻辑是遍历所有dex文件，调用DexFile的loadClassBinaryName()方法加载类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DexPathList.java
public Class&amp;lt;?&amp;gt; findClass(String name, List&amp;lt;Throwable&amp;gt; suppressed) {
    for (Element element : dexElements) {
        Class&amp;lt;?&amp;gt; clazz = element.findClass(name, definingContext, suppressed);
        if (clazz != null) {
            return clazz;
        }
    }
    ...
    return null;
}

// DexFile.java 
public Class loadClassBinaryName(String name, ClassLoader loader, List&amp;lt;Throwable&amp;gt; suppressed) {
    return defineClass(name, loader, mCookie, this, suppressed);
}

private static Class defineClass(String name, ClassLoader loader, Object cookie,
                                 DexFile dexFile, List&amp;lt;Throwable&amp;gt; suppressed) {
    Class result = null;
    try {
        result = defineClassNative(name, loader, cookie, dexFile);
    } catch (NoClassDefFoundError e) {
        ...
    } catch (ClassNotFoundException e) {
        ...
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从DexPathList的findClass()方法我们可以看到，在尝试加载一个类的时候，会遍历所有dex文件，只要找到就会直接返回，不会再继续遍历dexElements。&lt;/p&gt;

&lt;p&gt;也就是说当两个类不同的dex中出现，会优先处理排在前面的dex文件，这便是热修复的核心精髓，将需要修复的类所打包的dex文件插入到dexElements前面。&lt;/p&gt;

&lt;h1 id=&quot;4类加载流程&quot;&gt;4.类加载流程&lt;/h1&gt;

&lt;p&gt;在启动应用创建进程后，会调用ActivityThread.main()方法，在main()方法中ActivityThread与AMS建立交互，&lt;/p&gt;

&lt;p&gt;然后AMS调用ApplicationThread.bindApplication()方法，在bindApplication()方法中发送BIND_APPLICATION消息，执行handleBindApplication()方法，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
public static void main(String[] args) {
    ...
    ActivityThread thread = new ActivityThread();
    thread.attach(false, startSeq);
    ...
}
 
private void attach(boolean system, long startSeq) {
    ...
    final IActivityManager mgr = ActivityManager.getService();
    try {
        mgr.attachApplication(mAppThread, startSeq);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
    ...
}
 
private class ApplicationThread extends IApplicationThread.Stub {
    public final void bindApplication(String processName, ApplicationInfo appInfo,
        ...
        sendMessage(H.BIND_APPLICATION, data);
    }
}
 
private void handleBindApplication(AppBindData data) {
    ...
    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo, isSdkSandbox);
    ...
    Application app = data.info.makeApplication(data.restrictedBackupMode, null);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在handleBindApplication()方法中会调用getPackageInfoNoCheck()方法，其过程中会创建LoadedApk对象，这里需要注意的是构建LoadedApk传入的baseLoader为null，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,
        CompatibilityInfo compatInfo) {
    return getPackageInfo(ai, compatInfo, null, false, true, false, isSdkSandbox);
}
 
private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,
        ClassLoader baseLoader, boolean securityViolation, boolean includeCode,
        boolean registerPackage, boolean isSdkSandbox) {
        ...
        packageInfo =
                new LoadedApk(this, aInfo, compatInfo, baseLoader,
                        securityViolation, includeCode
                        &amp;amp;&amp;amp; (aInfo.flags &amp;amp; ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);
        ...
        return packageInfo;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，LoadedApk对象已经创建，其mBaseClassLoader为null。接下来继续makeApplication()的逻辑，&lt;/p&gt;

&lt;p&gt;这里会调用getClassLoader()方法，此时mClassLoader为null，调用createOrUpdateClassLoaderLocked()方法，&lt;/p&gt;

&lt;p&gt;此时mDefaultClassLoader也为null，调用ApplicationLoaders创建DefaultClassLoader，&lt;/p&gt;

&lt;p&gt;最后初始化mClassLoader，这里mDefaultClassLoader==mClassLoader，两者是相同的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// LoadedApk.java
public Application makeApplication(boolean forceDefaultAppClass,
        Instrumentation instrumentation) {
    return makeApplicationInner(forceDefaultAppClass, instrumentation,
            /* allowDuplicateInstances= */ true);
}

private Application makeApplicationInner(boolean forceDefaultAppClass,
        Instrumentation instrumentation, boolean allowDuplicateInstances) {
    ...
    final String myProcessName = Process.myProcessName();
    String appClass = mApplicationInfo.getCustomApplicationClassNameForProcess(
            myProcessName);
    if (forceDefaultAppClass || (appClass == null)) {
        appClass = &quot;android.app.Application&quot;;
    }

    try {
        final java.lang.ClassLoader cl = getClassLoader();
        ...
        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
        ...
        app = mActivityThread.mInstrumentation.newApplication(
                cl, appClass, appContext);
        appContext.setOuterContext(app);
    } catch (Exception e) {
        ...
    } 
    ...
    return app;
}
 
public ClassLoader getClassLoader() {
    synchronized (this) {
        if (mClassLoader == null) {
            createOrUpdateClassLoaderLocked(null /*addedPaths*/);
        }
        return mClassLoader;
    }
}
 
private void createOrUpdateClassLoaderLocked(List&amp;lt;String&amp;gt; addedPaths) {
    ...
    final List&amp;lt;String&amp;gt; zipPaths = new ArrayList&amp;lt;&amp;gt;(10);
    final List&amp;lt;String&amp;gt; libPaths = new ArrayList&amp;lt;&amp;gt;(10);
    ...
    makePaths(mActivityThread, isBundledApp, mApplicationInfo, zipPaths, libPaths);
    ...
    final String zip = (zipPaths.size() == 1) ? zipPaths.get(0) :
        TextUtils.join(File.pathSeparator, zipPaths);
    if (mDefaultClassLoader == null) {
        ...
        mDefaultClassLoader = ApplicationLoaders.getDefault().getClassLoaderWithSharedLibraries(
                zip, mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath,
                libraryPermittedPath, mBaseClassLoader,
                mApplicationInfo.classLoaderName, sharedLibraries.first, nativeSharedLibraries,
                sharedLibraries.second);
        mAppComponentFactory = createAppFactory(mApplicationInfo, mDefaultClassLoader);
        ...
    }
    if (!libPaths.isEmpty()) {
        ...
        try {
            ApplicationLoaders.getDefault().addNative(mDefaultClassLoader, libPaths);
        } finally {
            ...
        }
    }
    if (addedPaths != null &amp;amp;&amp;amp; addedPaths.size() &amp;gt; 0) {
        final String add = TextUtils.join(File.pathSeparator, addedPaths);
        ApplicationLoaders.getDefault().addPath(mDefaultClassLoader, add);
        ...
    }
    ...
    if (mClassLoader == null) {
        mClassLoader = mAppComponentFactory.instantiateClassLoader(mDefaultClassLoader,
                new ApplicationInfo(mApplicationInfo));
    }
}

public static void makePaths(ActivityThread activityThread,
                             boolean isBundledApp,
                             ApplicationInfo aInfo,
                             List&amp;lt;String&amp;gt; outZipPaths,
                             List&amp;lt;String&amp;gt; outLibPaths) {
    final String appDir = aInfo.sourceDir; // Full path to the base APK for this application.
    final String libDir = aInfo.nativeLibraryDir; // Full path to the directory where native JNI libraries are stored.

    outZipPaths.clear();
    outZipPaths.add(appDir); // data/app/**/base.apk
    ...
    if (outLibPaths != null) {
        if (outLibPaths.isEmpty()) {
            outLibPaths.add(libDir); 
        }

        if (aInfo.primaryCpuAbi != null) {
            ...
            for (String apk : outZipPaths) {
                outLibPaths.add(apk + &quot;!/lib/&quot; + aInfo.primaryCpuAbi);
            }
        }
        ...
    }
    ...
    appendSharedLibrariesLibPathsIfNeeded(
            aInfo.sharedLibraryInfos, aInfo, outSeenPaths, outLibPaths);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来看ApplicationLoaders里的逻辑，在getClassLoaderWithSharedLibraries()方法中会调用getClassLoader()方法，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ApplicationLoaders.java
ClassLoader getClassLoaderWithSharedLibraries(
        String zip, int targetSdkVersion, boolean isBundled,
        String librarySearchPath, String libraryPermittedPath,
        ClassLoader parent, String classLoaderName,
        List&amp;lt;ClassLoader&amp;gt; sharedLibraries, List&amp;lt;String&amp;gt; nativeSharedLibraries,
        List&amp;lt;ClassLoader&amp;gt; sharedLibrariesLoadedAfterApp) {
    // For normal usage the cache key used is the same as the zip path.
    return getClassLoader(zip, targetSdkVersion, isBundled, librarySearchPath,
                          libraryPermittedPath, parent, zip, classLoaderName, sharedLibraries,
                          nativeSharedLibraries, sharedLibrariesLoadedAfterApp);
}

// 这里传入的parent==null
private ClassLoader getClassLoader(String zip, int targetSdkVersion, boolean isBundled,
                                  String librarySearchPath, String libraryPermittedPath,
                                  ClassLoader parent, String cacheKey,
                                  String classLoaderName, List&amp;lt;ClassLoader&amp;gt; sharedLibraries,
                                  List&amp;lt;String&amp;gt; nativeSharedLibraries,
                                  List&amp;lt;ClassLoader&amp;gt; sharedLibrariesLoadedAfterApp) {
    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent(); // java.lang.BootClassLoader

    synchronized (mLoaders) {
        if (parent == null) {
            parent = baseParent;
        }

        if (parent == baseParent) {
            ...
            ClassLoader classloader = ClassLoaderFactory.createClassLoader(
                    zip,  librarySearchPath, libraryPermittedPath, parent,
                    targetSdkVersion, isBundled, classLoaderName, sharedLibraries,
                    nativeSharedLibraries, sharedLibrariesLoadedAfterApp);
            ...
            return classloader;
        }

        ClassLoader loader = ClassLoaderFactory.createClassLoader(
                zip, null, parent, classLoaderName, sharedLibraries,
                null /*sharedLibrariesLoadedAfterApp*/);

        return loader;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着看ClassLoaderFactory的逻辑，这里classloaderName为null，因此创建的是PathClassLoader。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ClassLoaderFactory.java
public static ClassLoader createClassLoader(String dexPath,
       String librarySearchPath, ClassLoader parent, String classloaderName,
       List&amp;lt;ClassLoader&amp;gt; sharedLibraries, List&amp;lt;ClassLoader&amp;gt; sharedLibrariesLoadedAfter) {
   ...
   if (isPathClassLoaderName(classloaderName)) {
       return new PathClassLoader(dexPath, librarySearchPath, parent, arrayOfSharedLibraries,
               arrayOfSharedLibrariesLoadedAfterApp);
   } else if (isDelegateLastClassLoaderName(classloaderName)) {
       return new DelegateLastClassLoader(dexPath, librarySearchPath, parent,
               arrayOfSharedLibraries, arrayOfSharedLibrariesLoadedAfterApp);
   }

    throw new AssertionError(&quot;Invalid classLoaderName: &quot; + classloaderName);
}
 
public static boolean isPathClassLoaderName(String name) {
    return name == null || PATH_CLASS_LOADER_NAME.equals(name) ||
            DEX_CLASS_LOADER_NAME.equals(name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回到LoadedApk.makeApplication()的逻辑，接下来会创建Application，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Instrumentation.java 
public Application newApplication(ClassLoader cl, String className, Context context)
        throws InstantiationException, IllegalAccessException,
        ClassNotFoundException {
    Application app = getFactory(context.getPackageName())
            .instantiateApplication(cl, className);
    app.attach(context);
    return app;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的className默认是android.app.Application，cl是之前创建的PathClassLoader。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// AppComponentFactory.java
public @NonNull Application instantiateApplication(@NonNull ClassLoader cl,
        @NonNull String className)
        throws InstantiationException, IllegalAccessException, ClassNotFoundException {
    return (Application) cl.loadClass(className).newInstance();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是应用PathClassLoader的创建流程以及应用代码是如何被加载的。需要注意的是基于双亲委派模型，最终加载android.app.Application类的classloader是BootClassLoader。&lt;/p&gt;

&lt;h1 id=&quot;5delegatelastclassloader&quot;&gt;5.DelegateLastClassLoader&lt;/h1&gt;

&lt;p&gt;在上文分析创建PathClassLoader代码中，还有一种类加载器DelegateLastClassLoader，继承于PathClassLoader，其加载class核心逻辑如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;@Override
protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // First, check whether the class has already been loaded. Return it if that&apos;s the
    // case.
    Class&amp;lt;?&amp;gt; cl = findLoadedClass(name);
    if (cl != null) {
        return cl;
    }
 
    // Next, check whether the class in question is present in the boot classpath.
    try {
        return Object.class.getClassLoader().loadClass(name);
    } catch (ClassNotFoundException ignored) {
    }
 
    // Next, check whether the class in question is present in the dexPath that this classloader
    // operates on, or its shared libraries.
    ClassNotFoundException fromSuper = null;
    try {
        return findClass(name);
    } catch (ClassNotFoundException ex) {
        fromSuper = ex;
    }
 
    // Finally, check whether the class in question is present in the parent classloader.
    try {
        return getParent().loadClass(name);
    } catch (ClassNotFoundException cnfe) {
        // The exception we&apos;re catching here is the CNFE thrown by the parent of this
        // classloader. However, we would like to throw a CNFE that provides details about
        // the class path / list of dex files associated with *this* classloader, so we choose
        // to throw the exception thrown from that lookup.
        throw fromSuper;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，判断该类是否已经被加载，如果已加载直接返回。&lt;/p&gt;

&lt;p&gt;然后，尝试由BootClassLoader加载。&lt;/p&gt;

&lt;p&gt;接着，尝试由DelegateLastClassLoader自身加载。&lt;/p&gt;

&lt;p&gt;最后，尝试由DelegateLastClassLoader的父加载器加载。&lt;/p&gt;

&lt;p&gt;可以看到DelegateLastClassLoader打破了双亲委派模型，先尝试自身加载，在交由parent加载。&lt;/p&gt;

&lt;h1 id=&quot;6replugin&quot;&gt;6.RePlugin&lt;/h1&gt;

&lt;p&gt;项目地址：https://github.com/Qihoo360/RePlugin&lt;/p&gt;

&lt;p&gt;其核心是在应用Application创建的时候，通过hook替换掉应用Context中的mPackageInfo中的mClassLoader，在自定义的DexClassLoader中优先加载插件类。&lt;/p&gt;

&lt;p&gt;RePluginClassLoader：用于替换Context中的mPackageInfo中的mClassLoader。&lt;/p&gt;

&lt;p&gt;PluginDexClassLoader：处理类加载逻辑，优先加载插件类。&lt;/p&gt;

&lt;p&gt;PatchClassLoaderUtils：通过hook实现替换Context中的mPackageInfo中的mClassLoader的功能。&lt;/p&gt;

&lt;h1 id=&quot;参考文档&quot;&gt;参考文档：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1517603&quot;&gt;彻底搞懂JVM类加载器：基本概念&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.tencent.com/developer/article/1520709&quot;&gt;类加载器中的双亲委派模型详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gityuan.com/2017/03/19/android-classloader/&quot;&gt;Android类加载器ClassLoader&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 24 Mar 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/03/24/Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/03/24/Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>ClassLoader</category>
        
        
      </item>
    
      <item>
        <title>Activity事件分发流程</title>
        <description>&lt;h1 id=&quot;1ims初始化&quot;&gt;1.IMS初始化&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/input/ims.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;InputManagerService初始化过程中主要创建了2个Native线程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;InputReader，读取底层输入，转换成Input事件，交给InputDispatcher分发。&lt;/li&gt;
  &lt;li&gt;InputDispatcher，向窗口分发Input事件，监控窗口ANR。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;InputManager::InputManager(
        const sp&amp;lt;InputReaderPolicyInterface&amp;gt;&amp;amp; readerPolicy,
        const sp&amp;lt;InputDispatcherPolicyInterface&amp;gt;&amp;amp; dispatcherPolicy) {
    mDispatcher = createInputDispatcher(dispatcherPolicy);
    mClassifier = std::make_unique&amp;lt;InputClassifier&amp;gt;(*mDispatcher);
    mBlocker = std::make_unique&amp;lt;UnwantedInteractionBlocker&amp;gt;(*mClassifier);
    mReader = createInputReader(readerPolicy, *mBlocker);
}

std::unique_ptr&amp;lt;InputDispatcherInterface&amp;gt; createInputDispatcher(
        const sp&amp;lt;InputDispatcherPolicyInterface&amp;gt;&amp;amp; policy) {
    return std::make_unique&amp;lt;android::inputdispatcher::InputDispatcher&amp;gt;(policy);
}

std::unique_ptr&amp;lt;InputReaderInterface&amp;gt; createInputReader(
        const sp&amp;lt;InputReaderPolicyInterface&amp;gt;&amp;amp; policy, InputListenerInterface&amp;amp; listener) {
    return std::make_unique&amp;lt;InputReader&amp;gt;(std::make_unique&amp;lt;EventHub&amp;gt;(), policy, listener);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://android.googlesource.com/platform/frameworks/base.git/+/android-4.2.2_r1/services/input/InputListener.cpp&quot;&gt;QueuedInputListener&lt;/a&gt;类图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/input/qil.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2窗口注册inputchannel&quot;&gt;2.窗口注册InputChannel&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;应用侧向WMS添加窗口时，会调用Native层的IMS创建InputChannel。&lt;/li&gt;
  &lt;li&gt;在InputDispatcher中会创建socketpair，基于fd创建一对InputChannel。&lt;/li&gt;
  &lt;li&gt;创建的clientChannel会填充到ViewRootImpl中创建的Java层InputChannel对象。&lt;/li&gt;
  &lt;li&gt;创建的serverChannel会保存到InputDispatcher的mConnectionsByToken。&lt;/li&gt;
  &lt;li&gt;基于Looper的epoll机制，当APP与IMS互相Socket通信时执行回调方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;21-java层&quot;&gt;2.1 Java层&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/input/java.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;22-native层&quot;&gt;2.2 Native层&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/input/native.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3窗口input事件&quot;&gt;3.窗口Input事件&lt;/h1&gt;

&lt;p&gt;通过 adb shell getevent 可查看Input设备以及实时Input事件，以按下Power键为例：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;add device 8: /dev/input/event2&lt;/p&gt;

  &lt;p&gt;name:     “pmic_pwrkey”&lt;/p&gt;

  &lt;p&gt;/dev/input/event2: 0001 0074 00000001&lt;/p&gt;

  &lt;p&gt;/dev/input/event2: 0000 0000 00000000&lt;/p&gt;

  &lt;p&gt;/dev/input/event2: 0001 0074 00000000&lt;/p&gt;

  &lt;p&gt;/dev/input/event2: 0000 0000 00000000&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Input事件传递流程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/input/input.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;InboundQueue：从 InputReader 中拿到的 Input 事件。&lt;/p&gt;

&lt;p&gt;OutboundQueue：即将要被派发给目标窗口的 Input 事件。&lt;/p&gt;

&lt;p&gt;WaitQueue：已经派发给目标窗口等待其回调 finishInputEvent 的 Input 事件。&lt;/p&gt;

&lt;h2 id=&quot;31-inputreader从eventhub中读取input事件&quot;&gt;3.1 InputReader从EventHub中读取Input事件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void InputReader::loopOnce() {
    ...
    // 获取事件
    size_t count = mEventHub-&amp;gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);
    { 
        AutoMutex _l(mLock);
        if (count) {
            // 处理事件
            processEventsLocked(mEventBuffer, count);
        }
        ...
    } 
    ...
    mQueuedListener-&amp;gt;flush(); // 传递事件
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;从EventHub中读取的事件可以是设备输入事件，也可以是设备增减变更触发的事件。&lt;/li&gt;
  &lt;li&gt;对于设备变更，会根据实际情况调用addDeviceLocked() / removeDeviceLocked() / handleConfigurationChangedLocked()处理。&lt;/li&gt;
  &lt;li&gt;对于设备输入事件，会调用processEventsForDeviceLocked()进一步处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void InputReader::processEventsForDeviceLocked(int32_t eventHubId, const RawEvent* rawEvents,
                                               size_t count) {
    auto deviceIt = mDevices.find(eventHubId);
    std::shared_ptr&amp;lt;InputDevice&amp;gt;&amp;amp; device = deviceIt-&amp;gt;second;
    device-&amp;gt;process(rawEvents, count);
}

void InputDevice::process(const RawEvent* rawEvents, size_t count) {
    for (const RawEvent* rawEvent = rawEvents; count != 0; rawEvent++) {
        for_each_mapper_in_subdevice(rawEvent-&amp;gt;deviceId, [rawEvent](InputMapper&amp;amp; mapper) {
            mapper.process(rawEvent);
        });
        --count;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;InputMapper用于解析原始输入事件，将RawEvent数据转换成EventEntry。&lt;/li&gt;
  &lt;li&gt;最后通过调用mQueuedListener-&amp;gt;flush()传递到InputDispatcher，回调其notifyMotion()方法。&lt;/li&gt;
  &lt;li&gt;调用enqueueInboundEventLocked()方法，加入到InboundQueue队列。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;32-inputdispatcher分发input事件&quot;&gt;3.2 InputDispatcher分发Input事件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void InputDispatcher::dispatchOnce() {
    nsecs_t nextWakeupTime = LONG_LONG_MAX;
    {
        AutoMutex _l(mLock);
        if (!haveCommandsLocked()) {
            // 分发事件
            dispatchOnceInnerLocked(&amp;amp;nextWakeupTime);
        }
        // 执行command
        if (runCommandsLockedInterruptable()) {
            nextWakeupTime = LONG_LONG_MIN;
        }
    }
    nsecs_t currentTime = now();
    int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);
    mLooper-&amp;gt;pollOnce(timeoutMillis);
}

bool InputDispatcher::haveCommandsLocked() const {
    return !mCommandQueue.empty();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;dispatchOnceInnerLocked()方法中根据EventEntry的类型执行不同的方法。&lt;/li&gt;
  &lt;li&gt;在dispatchMotionLocked()方法中调用findTouchedWindowTargetsLocked()基于WindowHandle找到目标窗口。&lt;/li&gt;
  &lt;li&gt;在dispatchEventLocked()方法中最终调用到startDispatchCycleLocked()方法将Input事件发送到应用窗口，同时将DispatchEntry从outboundQueue中移除，同时添加到waitQueue队列。。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime,
                                               const sp&amp;lt;Connection&amp;gt;&amp;amp; connection) {
    while (connection-&amp;gt;status == Connection::Status::NORMAL &amp;amp;&amp;amp; !connection-&amp;gt;outboundQueue.empty()) {
        DispatchEntry* dispatchEntry = connection-&amp;gt;outboundQueue.front();
        dispatchEntry-&amp;gt;deliveryTime = currentTime;
        const std::chrono::nanoseconds timeout = getDispatchingTimeoutLocked(connection);
        dispatchEntry-&amp;gt;timeoutTime = currentTime + timeout.count();

        // Publish the event.
        status_t status;
        const EventEntry&amp;amp; eventEntry = *(dispatchEntry-&amp;gt;eventEntry);
        switch (eventEntry.type) {
            case EventEntry::Type::KEY: {}
            case EventEntry::Type::MOTION: {}
            case EventEntry::Type::FOCUS: {}
            case EventEntry::Type::TOUCH_MODE_CHANGED: {}
            case EventEntry::Type::POINTER_CAPTURE_CHANGED: {}
            case EventEntry::Type::DRAG: {}
            case EventEntry::Type::CONFIGURATION_CHANGED:
            case EventEntry::Type::DEVICE_RESET:
            case EventEntry::Type::SENSOR: {
                return;
            }
        }

        // Re-enqueue the event on the wait queue.
        connection-&amp;gt;outboundQueue.erase(std::remove(connection-&amp;gt;outboundQueue.begin(),
                                                    connection-&amp;gt;outboundQueue.end(),
                                                    dispatchEntry));
        traceOutboundQueueLength(*connection);
        connection-&amp;gt;waitQueue.push_back(dispatchEntry);
        if (connection-&amp;gt;responsive) {
            mAnrTracker.insert(dispatchEntry-&amp;gt;timeoutTime,
                               connection-&amp;gt;inputChannel-&amp;gt;getConnectionToken());
        }
        traceWaitQueueLength(*connection);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;当收到应用侧finishInputEvent()回调后最终调用到doDispatchCycleFinishedCommand()方法，将DispatchEntry从waitQueue队列中移除。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void InputDispatcher::doDispatchCycleFinishedCommand(nsecs_t finishTime,
                                                     const sp&amp;lt;Connection&amp;gt;&amp;amp; connection, uint32_t seq,
                                                     bool handled, nsecs_t consumeTime) {
    ...
    dispatchEntryIt = connection-&amp;gt;findWaitQueueEntry(seq);
    if (dispatchEntryIt != connection-&amp;gt;waitQueue.end()) {
        dispatchEntry = *dispatchEntryIt;
        connection-&amp;gt;waitQueue.erase(dispatchEntryIt);
        const sp&amp;lt;IBinder&amp;gt;&amp;amp; connectionToken = connection-&amp;gt;inputChannel-&amp;gt;getConnectionToken();
        mAnrTracker.erase(dispatchEntry-&amp;gt;timeoutTime, connectionToken);
        ...
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;33-窗口收到input事件&quot;&gt;3.3 窗口收到Input事件&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/input/inputevent.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;InputStage采用责任链模式，依次由NativePreImeInputStage-&amp;gt;ViewPreImeInputStage-&amp;gt;ImeInputStage-&amp;gt;EarlyPostImeInputStage-&amp;gt;NativePostImeInputStage-&amp;gt;ViewPostImeInputStage-&amp;gt;SyntheticInputStage处理。&lt;/li&gt;
  &lt;li&gt;在ViewPostImeInputStage阶段分发给DecorView。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;34-view事件分发&quot;&gt;3.4 View事件分发&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// 事件分发到某个具体的 ViewGroup，会直接调用 dispatchTouchEvent() 方法
public boolean dispatchTouchEvent(MotionEvent ev) {
    //代表是否消费事件
    boolean consume = false;

    if (onInterceptTouchEvent(ev)) {
    // 如果 onInterceptTouchEvent() 返回 true 则代表当前 View 拦截了事件
    // 则该事件则会交给当前View进行处理
    // 即调用 onTouchEvent() 方法去处理事件
      consume = onTouchEvent (ev) ;
    } else {
      // 如果 onInterceptTouchEvent() 返回 false 则代表当前 View 不拦截事件
      // 则该事件则会继续传递给它的子元素
      // 子元素的 dispatchTouchEvent() 就会被调用，重复上述过程
      // 直到事件被最终处理为止
      consume = child.dispatchTouchEvent(ev); //遍历处理
    }
    return consume;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;4窗口anr&quot;&gt;4.窗口ANR&lt;/h1&gt;

&lt;p&gt;在dispatchOnce()方法中会调用processAnrsLocked()方法处理ANR：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void InputDispatcher::dispatchOnce() {
    nsecs_t nextWakeupTime = LONG_LONG_MAX;
    {
        AutoMutex _l(mLock);
        // 
        const nsecs_t nextAnrCheck = processAnrsLocked();
        nextWakeupTime = std::min(nextWakeupTime, nextAnrCheck);
    }
    nsecs_t currentTime = now();
    int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);
    mLooper-&amp;gt;pollOnce(timeoutMillis);
}

bool InputDispatcher::haveCommandsLocked() const {
    return !mCommandQueue.empty();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;41-无焦点窗口---does-not-have-a-focused-window&quot;&gt;4.1 无焦点窗口 - does not have a focused window&lt;/h2&gt;

&lt;p&gt;在findFocusedWindowTargetsLocked()方法中，如果没有找到焦点窗口时，会更新mNoFocusedWindowTimeoutTime，开启ANR计时。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;InputEventInjectionResult InputDispatcher::findFocusedWindowTargetsLocked(
        nsecs_t currentTime, const EventEntry&amp;amp; entry, std::vector&amp;lt;InputTarget&amp;gt;&amp;amp; inputTargets,
        nsecs_t* nextWakeupTime) {
    ...
    if (focusedWindowHandle == nullptr &amp;amp;&amp;amp; focusedApplicationHandle != nullptr) {
        if (!mNoFocusedWindowTimeoutTime.has_value()) {
            // We just discovered that there&apos;s no focused window. Start the ANR timer
            std::chrono::nanoseconds timeout = focusedApplicationHandle-&amp;gt;getDispatchingTimeout(
                    DEFAULT_INPUT_DISPATCHING_TIMEOUT);
            mNoFocusedWindowTimeoutTime = currentTime + timeout.count();
            mAwaitedFocusedApplication = focusedApplicationHandle;
            mAwaitedApplicationDisplayId = displayId;
            *nextWakeupTime = *mNoFocusedWindowTimeoutTime;
            return InputEventInjectionResult::PENDING;
        } else if (currentTime &amp;gt; *mNoFocusedWindowTimeoutTime) {
            // Already raised ANR. Drop the event
            return InputEventInjectionResult::FAILED;
        } else {
            // Still waiting for the focused window
            return InputEventInjectionResult::PENDING;
        }
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在processAnrsLocked()方法中，如果当前时间超过设置的mNoFocusedWindowTimeoutTime时间，则处理无焦点窗口ANR。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;nsecs_t InputDispatcher::processAnrsLocked() {
    const nsecs_t currentTime = now();
    nsecs_t nextAnrCheck = LONG_LONG_MAX;
    // Check if we are waiting for a focused window to appear. Raise ANR if waited too long
    if (mNoFocusedWindowTimeoutTime.has_value() &amp;amp;&amp;amp; mAwaitedFocusedApplication != nullptr) {
        if (currentTime &amp;gt;= *mNoFocusedWindowTimeoutTime) {
            processNoFocusedWindowAnrLocked();
            mAwaitedFocusedApplication.reset();
            mNoFocusedWindowTimeoutTime = std::nullopt;
            return LONG_LONG_MIN;
        } else {
            // Keep waiting. We will drop the event when mNoFocusedWindowTimeoutTime comes.
            nextAnrCheck = *mNoFocusedWindowTimeoutTime;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;42-窗口无响应---is-not-responding&quot;&gt;4.2 窗口无响应 - is not responding&lt;/h2&gt;

&lt;p&gt;在startDispatchCycleLocked()方法中，将Input时间发送到应用窗口后，会在mAnrTracker中插入超时时间。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime,
                                               const sp&amp;lt;Connection&amp;gt;&amp;amp; connection) {
    while (connection-&amp;gt;status == Connection::Status::NORMAL &amp;amp;&amp;amp; !connection-&amp;gt;outboundQueue.empty()) {
        DispatchEntry* dispatchEntry = connection-&amp;gt;outboundQueue.front();
        dispatchEntry-&amp;gt;deliveryTime = currentTime;
        const std::chrono::nanoseconds timeout = getDispatchingTimeoutLocked(connection);
        dispatchEntry-&amp;gt;timeoutTime = currentTime + timeout.count();
        
        // Publish the event.
        ...
        if (connection-&amp;gt;responsive) {
            mAnrTracker.insert(dispatchEntry-&amp;gt;timeoutTime,
                               connection-&amp;gt;inputChannel-&amp;gt;getConnectionToken());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在processAnrsLocked()方法中，如果当前时间超过超时时间，则处理窗口无响应ANR&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;nsecs_t InputDispatcher::processAnrsLocked() {
    const nsecs_t currentTime = now();
    nsecs_t nextAnrCheck = LONG_LONG_MAX;

    // Check if any connection ANRs are due
    nextAnrCheck = std::min(nextAnrCheck, mAnrTracker.firstTimeout());
    if (currentTime &amp;lt; nextAnrCheck) { // most likely scenario
        return nextAnrCheck;          // everything is normal. Let&apos;s check again at nextAnrCheck
    }

    // If we reached here, we have an unresponsive connection.
    sp&amp;lt;Connection&amp;gt; connection = getConnectionLocked(mAnrTracker.firstToken());
    if (connection == nullptr) {;
        return nextAnrCheck;
    }
    connection-&amp;gt;responsive = false;
    // Stop waking up for this unresponsive connection
    mAnrTracker.eraseToken(connection-&amp;gt;inputChannel-&amp;gt;getConnectionToken());
    onAnrLocked(connection);
    return LONG_LONG_MIN;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考文档：&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/jinzhuojun/article/details/41909159&quot;&gt;Android 5.0(Lollipop)事件输入系统(Input System)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.tencent.com/developer/article/1707657&quot;&gt;Android中窗口Input事件接收&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 30 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/30/Activity%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/30/Activity%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>Activity</category>
        
        <category>Input</category>
        
        
      </item>
    
      <item>
        <title>Activity显示流程</title>
        <description>&lt;p&gt;在 &lt;a href=&quot;https://dreamsunny.github.io/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/&quot;&gt;Activity启动流程&lt;/a&gt; 中，我们知道了系统侧响应 Activity 启动请求会创建 Task ；&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&quot;https://dreamsunny.github.io/2022/12/24/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/&quot;&gt;DisplayArea树层级结构&lt;/a&gt;中，我们了解了 Task 最终会添加到 DefaultTaskDisplayArea ；&lt;/p&gt;

&lt;p&gt;本文主要梳理下Activity显示流程。&lt;/p&gt;

&lt;h1 id=&quot;1task添加到defaulttaskdisplayarea&quot;&gt;1.Task添加到DefaultTaskDisplayArea&lt;/h1&gt;

&lt;p&gt;调用堆栈如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/trace1.png&quot; alt=&quot;trace1&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// TaskDisplayArea.java
Task getOrCreateRootTask(..) {
    ...
    return new Task.Builder(mAtmService)
            ...
            .setParent(this)
            ...
            .build();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 setParent(this) 传入的是 TaskDisplayArea 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Task.java
Task build() {
    ...
    final Task task = buildInner();
    ...
    if (mParent != null) {
        if (mParent instanceof Task) {
            final Task parentTask = (Task) mParent;
            parentTask.addChild(task, mOnTop ? POSITION_TOP : POSITION_BOTTOM,
                    (mActivityInfo.flags &amp;amp; FLAG_SHOW_FOR_ALL_USERS) != 0);
        } else {
            mParent.addChild(task, mOnTop ? POSITION_TOP : POSITION_BOTTOM);
        }
    }
    ...
    return task;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Task.Builder的build() 方法中，将创建的task添加到 TaskDisplayArea。&lt;/p&gt;

&lt;h1 id=&quot;2activityrecord添加到task&quot;&gt;2.ActivityRecord添加到Task&lt;/h1&gt;

&lt;p&gt;调用堆栈如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/trace2.png&quot; alt=&quot;trace2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1.创建ActivityRecord：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityStarter.java
private int executeRequest(Request request) {
    ...
    final ActivityRecord r = new ActivityRecord.Builder(mService)
            ...
            .build();
    ...
}
// ActivityRecord.java
private ActivityRecord(..) {
    super(_service.mWindowManager, new Token(), TYPE_APPLICATION, true,
            null /* displayContent */, false /* ownerCanManageAppTokens */);
    ((Token) token).mActivityRef = new WeakReference&amp;lt;&amp;gt;(this);
}

private static class Token extends Binder {
    @NonNull WeakReference&amp;lt;ActivityRecord&amp;gt; mActivityRef;

    @Override
    public String toString() {
        return &quot;Token{&quot; + Integer.toHexString(System.identityHashCode(this)) + &quot; &quot;
                + mActivityRef.get() + &quot;}&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.添加到 Task 中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityStarter.java
private void addOrReparentStartingActivity(@NonNull Task task, String reason) {
    ..
    TaskFragment newParent = task;
    ...
    if (mStartActivity.getTaskFragment() == null
            || mStartActivity.getTaskFragment() == newParent) {
        newParent.addChild(mStartActivity, POSITION_TOP);
    } else {
        mStartActivity.reparent(newParent, newParent.getChildCount() /* top */, reason);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.添加到 DisplayContent 的 mTokenMap 中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowToken.java
void onDisplayChanged(DisplayContent dc) {
    dc.reParentWindowToken(this);
    super.onDisplayChanged(dc);
}
// DisplayContent.java
void reParentWindowToken(WindowToken token) {
    ...
    addWindowToken(token.token, token);
    ...
}

void addWindowToken(IBinder binder, WindowToken token) {
    ...
    mTokenMap.put(binder, token);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3activity窗口添加到wms&quot;&gt;3.Activity窗口添加到WMS&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_show.png&quot; alt=&quot;act_show&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;31-activitysetcontentview&quot;&gt;3.1 Activity.setContentView(..)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Activity.java
public void setContentView(@LayoutRes int layoutResID) {
    getWindow().setContentView(layoutResID);
    initWindowDecorActionBar();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activity.setContentView(..) 中直接调用 PhoneWindow.setContentView(..) 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// PhoneWindow.java
public void setContentView(int layoutResID) {
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        ...
    }

    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        ...
    } else {
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
    ...
}

private void installDecor() {
    mForceDecorInstall = false;
    if (mDecor == null) {
        mDecor = generateDecor(-1);
        ...
    } else {
        mDecor.setWindow(this);
    }
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor);
        ...
    }
}

protected DecorView generateDecor(int featureId) {
    ...
    return new DecorView(context, featureId, this, getAttributes());
}

protected ViewGroup generateLayout(DecorView decor) {
    ...
    int layoutResource;
    int features = getLocalFeatures();
    if ((features &amp;amp; ((1 &amp;lt;&amp;lt; FEATURE_LEFT_ICON) | (1 &amp;lt;&amp;lt; FEATURE_RIGHT_ICON))) != 0) {
        ..
    } else if ((features &amp;amp; ((1 &amp;lt;&amp;lt; FEATURE_PROGRESS) | (1 &amp;lt;&amp;lt; FEATURE_INDETERMINATE_PROGRESS))) != 0
        &amp;amp;&amp;amp; (features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_ACTION_BAR)) == 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_CUSTOM_TITLE)) != 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_NO_TITLE)) == 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) {
        ..
    } else {
        layoutResource = R.layout.screen_simple;
    }
    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);
    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
    ...
    return contentParent;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PhoneWindow.setContentView(..) 方法主要做3件事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建DecorView。&lt;/li&gt;
  &lt;li&gt;inflate Activity 根布局。&lt;/li&gt;
  &lt;li&gt;inflate Activity 视图布局（setContentView()传入的layoutResID）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中系统预置 Activity 根布局有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;feature&lt;/th&gt;
      &lt;th&gt;布局&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_LEFT_ICON&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_RIGHT_ICON&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_title_icons.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_PROGRESS&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_INDETERMINATE_PROGRESS&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_ACTION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_progress.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_CUSTOM_TITLE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_custom_title.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_NO_TITLE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_title.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_ACTION_MODE_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_simple_overlay_action_mode.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;else&lt;/td&gt;
      &lt;td&gt;screen_simple.xml&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以 screen_simple.xml 为例查看其布局：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// screen_simple.xml
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;
    android:orientation=&quot;vertical&quot;&amp;gt;
    &amp;lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot;
              android:inflatedId=&quot;@+id/action_mode_bar&quot;
              android:layout=&quot;@layout/action_mode_bar&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;wrap_content&quot;
              android:theme=&quot;?attr/actionBarTheme&quot; /&amp;gt;
    &amp;lt;FrameLayout
         android:id=&quot;@android:id/content&quot;
         android:layout_width=&quot;match_parent&quot;
         android:layout_height=&quot;match_parent&quot;
         android:foregroundInsidePadding=&quot;false&quot;
         android:foregroundGravity=&quot;fill_horizontal|top&quot;
         android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&amp;gt;
&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应整个 Activity 视图为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/decor.png&quot; alt=&quot;decor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终，Activity.setContentView(..) 传入的布局会添加到 FrameLayout(id=ID_ANDROID_CONTENT) 。&lt;/p&gt;

&lt;h2 id=&quot;32-viewrootimplsetview&quot;&gt;3.2 ViewRootImpl.setView(..)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ViewRootImpl.java
public ViewRootImpl(Context context, Display display) {
    this(context, display, WindowManagerGlobal.getWindowSession(),
            false /* useSfChoreographer */);
}

public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session) {
    this(context, display, session, false /* useSfChoreographer */);
}

public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session,
        boolean useSfChoreographer) {
    mWindowSession = session;
    mWindow = new W(this);
    ...
}

public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,
        int userId, Bundle bundle) {
    synchronized (this) {
        if (mView == null) {
            ...
            try {
                res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,
                        getHostVisibility(), mDisplay.getDisplayId(), userId,
                        mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,
                        mTempControls);
            } catch (RemoteException e) {
            } finally {
            }
            ...
        }
    }
}
// WindowManagerGlobal.java
public static IWindowSession getWindowSession() {
    synchronized (WindowManagerGlobal.class) {
        if (sWindowSession == null) {
            try {
                IWindowManager windowManager = getWindowManagerService();
                sWindowSession = windowManager.openSession(
                        new IWindowSessionCallback.Stub() {
                            @Override
                            public void onAnimatorScaleChanged(float scale) {
                                ValueAnimator.setDurationScale(scale);
                            }
                        });
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        return sWindowSession;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ViewRootImpl 是 View视图 与 WindowManager 的纽带，mIWindowSession、mWindow 为 Binder 对象，用于 APP 端与 WMS 之间的相互通信。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/win_binder.png&quot; alt=&quot;win_binder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里通过 IWindowSession.addToDisplayAsUser(..) 接口，请求WMS添加新窗口。&lt;/p&gt;

&lt;p&gt;此外，ViewRootImpl 管理整个 View 视图的绘制和 Input 事件分发。&lt;/p&gt;

&lt;h1 id=&quot;4wms添加窗口&quot;&gt;4.WMS添加窗口&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(Session session, IWindow client, LayoutParams attrs, ..) {
    WindowState parentWindow = null;
    final int type = attrs.type;
    synchronized (mGlobalLock) {
        final DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token);
        
        if (type &amp;gt;= FIRST_SUB_WINDOW &amp;amp;&amp;amp; type &amp;lt;= LAST_SUB_WINDOW) {
            parentWindow = windowForClientLocked(null, attrs.token, false);
            ...
        }

        ActivityRecord activity = null;
        final boolean hasParent = parentWindow != null;
        WindowToken token = displayContent.getWindowToken(
                hasParent ? parentWindow.mAttrs.token : attrs.token);
        final int rootType = hasParent ? parentWindow.mAttrs.type : type;

        if (token == null) {
            ...
        } else if (rootType &amp;gt;= FIRST_APPLICATION_WINDOW
                &amp;amp;&amp;amp; rootType &amp;lt;= LAST_APPLICATION_WINDOW) {
            activity = token.asActivityRecord();
            ...
        } else if (rootType == TYPE_INPUT_METHOD) {
            ...
        } else if (rootType == TYPE_VOICE_INTERACTION) {
            ...
        } else if (rootType == TYPE_WALLPAPER) {
            ...
        } else if (rootType == TYPE_ACCESSIBILITY_OVERLAY) {
            ...
        } else if (type == TYPE_TOAST) {
            ...
        } else if (type == TYPE_QS_DIALOG) {
            ...
        } else if (token.asActivityRecord() != null) {
            ...
        }

        final WindowState win = new WindowState(this, session, client, token, parentWindow,
                appOp[0], attrs, viewVisibility, session.mUid, userId,
                session.mCanAddInternalSystemWindow);
        win.attach();
        mWindowMap.put(client.asBinder(), win);
        win.mToken.addWindow(win);

        if (type == TYPE_APPLICATION_STARTING &amp;amp;&amp;amp; activity != null) {
            activity.attachStartingWindow(win);
        } else if (type == TYPE_INPUT_METHOD
            ...
        } else if (type == TYPE_INPUT_METHOD_DIALOG) {
            ...
        } else {
            ...
        }
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;41-创建windowstate&quot;&gt;4.1 创建WindowState&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    WindowToken token = displayContent.getWindowToken(
            hasParent ? parentWindow.mAttrs.token : attrs.token);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里传入的 token 是在创建 ActivityRecord 时创建的 Binder 对象（见上文2），获取到的 WindowToken 为 ActivityRecord 对象。&lt;/p&gt;

&lt;p&gt;WMS每一个新窗口都会对应创建一个 WindowState 对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    final WindowState win = new WindowState(this, session, client, token, parentWindow,
            appOp[0], attrs, viewVisibility, session.mUid, userId,
            session.mCanAddInternalSystemWindow);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以 Activity 页面弹出一个Dialog对话框为例，WindowToken 与 WindowState 的关系为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/win_token.png&quot; alt=&quot;win_token&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;42-创建surfacesession&quot;&gt;4.2 创建SurfaceSession&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    synchronized (mGlobalLock) {
        ...
        final WindowState win = new WindowState(...);
        win.attach();
        ...
    }
    return res;
}

// WindowState.java
void attach() {
    mSession.windowAddedLocked();
}

// Session.java
void windowAddedLocked() {
    ...
    if (mSurfaceSession == null) {
        mSurfaceSession = new SurfaceSession();
        ...
    }
}

// SurfaceSession.java
/** Create a new connection with the surface flinger. */
@UnsupportedAppUsage
public SurfaceSession() {
    mNativeClient = nativeCreate();
}

// android_view_SurfaceSession.cpp
static jlong nativeCreate(JNIEnv* env, jclass clazz) {
    SurfaceComposerClient* client = new SurfaceComposerClient();
    client-&amp;gt;incStrong((void*)nativeCreate);
    return reinterpret_cast&amp;lt;jlong&amp;gt;(client);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SurfaceSession 构造方法中通过 nativeCreate() 方法返回了一个 SurfaceComposerClient 指针，它表示一个跟 SurfaceFlinger 的连接，当其第一次被使用时会调用 onFirstRef() 方法，创建一个实现 ISurfaceComposerClient 接口的 Client 对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// SurfaceComposerClient.cpp
void SurfaceComposerClient::onFirstRef() {
    sp&amp;lt;ISurfaceComposer&amp;gt; sf(ComposerService::getComposerService());
    if (sf != nullptr &amp;amp;&amp;amp; mStatus == NO_INIT) {
        sp&amp;lt;ISurfaceComposerClient&amp;gt; conn;
        conn = sf-&amp;gt;createConnection();
        if (conn != nullptr) {
            mClient = conn;
            mStatus = NO_ERROR;
        }
    }
}

// SurfaceFlinger.cpp
sp&amp;lt;ISurfaceComposerClient&amp;gt; SurfaceFlinger::createConnection() {
    const sp&amp;lt;Client&amp;gt; client = new Client(this);
    return client-&amp;gt;initCheck() == NO_ERROR ? client : nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WMS 创建了一个 WindowState 对象表示客户端的一个 Window，接着调用 WindowState.attach() 方法创建了一个 SurfaceSession 对象，SurfaceSession 表示一个跟 SurfaceFlinger 的连接，它创建了一个 SurfaceComposerClient 对象，然后 SurfaceFlinger 又创建了一个 Client 对象。&lt;/p&gt;

&lt;h2 id=&quot;43-windowstate添加到activityrecord&quot;&gt;4.3 WindowState添加到ActivityRecord&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    final WindowState win = new WindowState(.., token, ..);
    ...
    win.mToken.addWindow(win);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;5应用绘制&quot;&gt;5.应用绘制&lt;/h1&gt;

&lt;h2 id=&quot;51-创建surface&quot;&gt;5.1 创建Surface&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ViewRootImpl.java
public final Surface mSurface = new Surface();
private final SurfaceControl mSurfaceControl = new SurfaceControl();
private BLASTBufferQueue mBlastBufferQueue;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建 ViewRootImp 实例时，会创建一个空的 Surface 和 SurfaceControl 对象，其初始化流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ViewRootImpl$TraversalRunnable.run(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.doTraversal(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.performTraversals(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.relayoutWindow(..)&lt;/li&gt;
  &lt;li&gt;Session.relayout(.., mSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowManagerService.relayoutWindow(.., outSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowManagerService.createSurfaceControl(outSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowStateAnimator.createSurfaceLocked()&lt;/li&gt;
  &lt;li&gt;new WindowSurfaceController(..)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.Builder.build()&lt;/li&gt;
  &lt;li&gt;new SurfaceControl(..)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.nativeCreate(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// android_view_SurfaceControl.cpp
static jlong nativeCreate(..) {
    sp&amp;lt;SurfaceComposerClient&amp;gt; client;
    if (sessionObj != NULL) {
        client = android_view_SurfaceSession_getClient(env, sessionObj);
    } else {
        client = SurfaceComposerClient::getDefault();
    }

    sp&amp;lt;SurfaceControl&amp;gt; surface;
    status_t err = client-&amp;gt;createSurfaceChecked(String8(name.c_str()), w, h, format, &amp;amp;surface,
                                                flags, parentHandle, std::move(metadata));
    surface-&amp;gt;incStrong((void *)nativeCreate);
    return reinterpret_cast&amp;lt;jlong&amp;gt;(surface.get());
}

// SurfaceComposerClient.cpp 
status_t SurfaceComposerClient::createSurfaceChecked(..) {
    status_t err = mStatus;

    if (mStatus == NO_ERROR) {
        sp&amp;lt;IBinder&amp;gt; handle;
        sp&amp;lt;IGraphicBufferProducer&amp;gt; gbp;

        err = mClient-&amp;gt;createSurface(name, w, h, format, flags, parentHandle, std::move(metadata),
                                     &amp;amp;handle, &amp;amp;gbp, &amp;amp;id, &amp;amp;transformHint);

        if (err == NO_ERROR) {
            *outSurface =
                    new SurfaceControl(this, handle, gbp, id, w, h, format, transformHint, flags);
        }
    }
    return err;
}

// surfaceflinger/Client.cpp
status_t Client::createSurface(..) {
    LayerCreationArgs args(mFlinger.get(), this, name.c_str(), flags, std::move(metadata));
    return mFlinger-&amp;gt;createLayer(args, outHandle, parentHandle, outLayerId, nullptr,
                                 outTransformHint);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;WindowSurfaceController.getSurfaceControl(outSurfaceControl)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.copyFrom(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;outSurfaceControl.copyFrom(mSurfaceControl, &quot;WindowSurfaceController.getSurfaceControl&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;SurfaceControl.nativeCopyFromSurfaceControl(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.updateBlastSurfaceIfNeeded()&lt;/li&gt;
  &lt;li&gt;new BLASTBufferQueue(mTag, mSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;BLASTBufferQueue.createSurface()&lt;/li&gt;
  &lt;li&gt;BLASTBufferQueue.nativeGetSurface(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// android_graphics_BLASTBufferQueue.cpp
static jobject nativeGetSurface(JNIEnv* env, jclass clazz, jlong ptr,
                                jboolean includeSurfaceControlHandle) {
    sp&amp;lt;BLASTBufferQueue&amp;gt; queue = reinterpret_cast&amp;lt;BLASTBufferQueue*&amp;gt;(ptr);
    return android_view_Surface_createFromSurface(env,
                                                  queue-&amp;gt;getSurface(includeSurfaceControlHandle));
}

// BLASTBufferQueue.cpp
sp&amp;lt;Surface&amp;gt; BLASTBufferQueue::getSurface(bool includeSurfaceControlHandle) {
    std::unique_lock _lock{mMutex};
    sp&amp;lt;IBinder&amp;gt; scHandle = nullptr;
    if (includeSurfaceControlHandle &amp;amp;&amp;amp; mSurfaceControl) {
        scHandle = mSurfaceControl-&amp;gt;getHandle();
    }
    return new BBQSurface(mProducer, true, scHandle, this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;Surface.transferFrom(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;mSurface.transferFrom(blastSurface);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;Surface.setNativeObjectLocked(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 Java 层中 ViewRootImpl 实例中持有一个 Surface 对象，该 Surface 对象中的 mNativeObject 属性指向 native 层中创建的 Surface 对象，native 层的 Surface 对应 SurfaceFlinger 中的 Layer 对象，它持有 Layer 中的 BufferQueueProducer 生产者指针，在 Surface 上绘制的内容最终会交由 SurfaceFlinger 来合成渲染送到显示器显示。&lt;/p&gt;

&lt;h2 id=&quot;52-view绘制构建阶段&quot;&gt;5.2 View绘制：构建阶段&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw1.png&quot; alt=&quot;view_draw1&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Choreographer.java

private final class FrameDisplayEventReceiver extends DisplayEventReceiver
        implements Runnable {

    @Override
    public void onVsync(..) {
        try {
            ...
            Message msg = Message.obtain(mHandler, this);
            msg.setAsynchronous(true);
            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
        } finally {
        }
    }

    @Override
    public void run() {
        doFrame(mTimestampNanos, mFrame, mLastVsyncEventData);
    }
}

void doFrame(..) {
    try {
        ...
        doCallbacks(Choreographer.CALLBACK_INPUT, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameData, frameIntervalNanos);
    } finally {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Choreographer中收到Vsync信号后，向主线程MessageQueue发送一条异步Message，当异步Message执行后会调用其doFrame(..)方法，依次执行 INPUT、ANIMATION、INSETS_ANIMATION、TRAVERSAL、COMMIT 回调。&lt;/p&gt;

&lt;p&gt;在 TRAVERSAL 回调中会执行 mTraversalRunnable ，其 run() 方法中调用 doTraversal() 方法，执行 performTraversals() 方法，接着依次执行 View 的 measure、layout、draw 流程的代码。&lt;/p&gt;

&lt;h2 id=&quot;53-view绘制渲染阶段&quot;&gt;5.3 View绘制：渲染阶段&lt;/h2&gt;

&lt;p&gt;RenderThread线程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw2.png&quot; alt=&quot;view_draw2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;渲染方式：软件绘制（CPU） VS 硬件绘制（GPU）&lt;/p&gt;

&lt;p&gt;渲染引擎：OpenGL VS Vulkan&lt;/p&gt;

&lt;h2 id=&quot;54-surfaceflinger合成显示&quot;&gt;5.4 SurfaceFlinger：合成显示&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw3.png&quot; alt=&quot;view_draw3&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;6小结&quot;&gt;6.小结&lt;/h1&gt;

&lt;p&gt;应用侧 Window 是一个抽象概念，用来描述顶层视图的外观和行为，唯一的实现类是 PhoneWindow。&lt;/p&gt;

&lt;p&gt;在创建 Activity / Dialog 时，会创建 PhoneWindow ，同时会创建 DecorView 。&lt;/p&gt;

&lt;p&gt;应用侧向WMS请求添加视图时，会创建ViewRootImpl，同时会创建 Surface，视图绘制的数据会写入  Surface，由 SurfaceFlinger 合成显示。&lt;/p&gt;

&lt;p&gt;WMS添加应用侧视图时会创建 WindowState 用来对应一个 Window，同时维护 Window 的 Z-Order 。&lt;/p&gt;

&lt;h1 id=&quot;7参考文档&quot;&gt;7.参考文档&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.simowce.com/all-about-blastbbq/&quot;&gt;BLASTBufferQueue 详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/50a30fa6952e&quot;&gt;BBQ 机制介绍&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/cdc60627df90&quot;&gt;BBQ 原理解读&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/384a5cd2e304&quot;&gt;BBQ 运用场景&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/19/Activity%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/19/Activity%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>Activity</category>
        
        
      </item>
    
      <item>
        <title>Activity启动流程</title>
        <description>&lt;h1 id=&quot;1activity官方文档&quot;&gt;1.Activity官方文档&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/components/activities/intro-activities?hl=zh-cn&quot;&gt;Activity 简介&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle?hl=zh-cn&quot;&gt;Activity 生命周期&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/topics/manifest/activity-element?hl=zh-cn&quot;&gt;应用清单&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;2activity启动流程&quot;&gt;2.Activity启动流程&lt;/h1&gt;

&lt;p&gt;在桌面点击时钟图标打开闹钟应用，使用系统跟踪抓取 trace 文件，在 &lt;a href=&quot;https://ui.perfetto.dev/&quot;&gt;perfetto&lt;/a&gt; 打开查看：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/startActivity.perfetto-trace&quot;&gt;startActivity.perfetto-trace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_start.png&quot; alt=&quot;act_start&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了让整个过程可视化，对系统侧相关类做了代码插桩，在进入/退出方法处加上Trace日志：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/startActivityinjected.perfetto-trace&quot;&gt;startActivityinjected.perfetto-trace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在此基础上需要掌握调试安卓Framework源码 ，再结合trace来学习源码。&lt;/p&gt;

&lt;h2 id=&quot;21-点击应用图标&quot;&gt;2.1 点击应用图标&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;InputReader 负责从 EventHub 里面把 Input 事件读取出来，然后交给 InputDispatcher 进行事件分发。&lt;/li&gt;
  &lt;li&gt;InputDispatcher 在拿到 InputReader 获取的事件后对 Input 事件进行包装，然后寻找并分发到目标窗口。&lt;/li&gt;
  &lt;li&gt;InboundQueue（iq）队列中放着 InputDispatcher 从 InputReader 中拿到的 Input 事件。&lt;/li&gt;
  &lt;li&gt;OutboundQueue（oq）队列里面放的是即将要被派发给各个目标窗口的 Input 事件。&lt;/li&gt;
  &lt;li&gt;WaitQueue（wq）队列里面记录的是已经派发给目标窗口等待其处理完的 Input 事件。&lt;/li&gt;
  &lt;li&gt;PendingInputEventQueue（aq）队列中记录的是应用需要处理的 Input 事件。&lt;/li&gt;
  &lt;li&gt;deliverInputEvent 标识 App UI Thread 被 Input 事件唤醒。&lt;/li&gt;
  &lt;li&gt;App 响应处理 Input 事件，内部会在其界面 View 树中传递处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;22-启动闹钟应用&quot;&gt;2.2 启动闹钟应用&lt;/h2&gt;

&lt;h3 id=&quot;221-桌面请求启动闹钟应用&quot;&gt;2.2.1 桌面请求启动闹钟应用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Activity.startActivityForResult(..)&lt;/li&gt;
  &lt;li&gt;Instrumentation.execStartActivity(..)&lt;/li&gt;
  &lt;li&gt;ActivityTaskManager.&lt;em&gt;getService&lt;/em&gt;().startActivity(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private static final Singleton&amp;lt;IActivityTaskManager&amp;gt; IActivityTaskManagerSingleton =
        new Singleton&amp;lt;IActivityTaskManager&amp;gt;() {
            @Override
            protected IActivityTaskManager create() {
                final IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);
                return IActivityTaskManager.Stub.asInterface(b);
            }
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;222-系统侧处理请求&quot;&gt;2.2.2 系统侧处理请求&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/atms_start_act.png&quot; alt=&quot;atms_start_act&quot; /&gt;&lt;/p&gt;

&lt;p&gt;核心逻辑从ActivityStarter.execute()方法开始：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. ActivityStarter$Request.resolveActivity(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;解析 ResolveInfo 和 ActivityInfo，最终调用到 ComputerEngine.queryIntentActivitiesInternal(..)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/resolve_act.png&quot; alt=&quot;resolve_act&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有个细节是处理 显式启动 与 隐式启动 的区别：&lt;a href=&quot;https://developer.android.com/guide/components/intents-filters?hl=zh-cn&quot;&gt;Intent 和 Intent 过滤器&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;queryIntentActivitiesInternal(..) {
    ComponentName comp = intent.getComponent();
    if (comp != null) {
        getActivityInfo(..)
    } else {
        queryIntentActivitiesInternalBody(..)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. ActivityStarter.executeRequest()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.1 权限检查&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.1 启动权限检查：ActivityTaskSupervisor.checkStartAnyActivityPermission(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;应用AndroidManifest.xml配置项：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;android:exported&lt;/th&gt;
      &lt;th&gt;activity 是否可由其他应用的组件启动。&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;android:permission&lt;/td&gt;
      &lt;td&gt;启动 activity 或以其他方式使 activity 响应 intent 时，客户端必须具备的权限的名称。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;2.1.2 允许后台启动检查：ActivityStarter.shouldAbortBackgroundActivityStart(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;详见 &lt;a href=&quot;https://developer.android.com/guide/components/activities/background-starts?hl=zh-cn&quot;&gt;从后台启动 Activity 的限制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.2 创建ActivityRecord&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Activity 的实例是在应用侧创建的，系统侧会创建 ActivityRecord 与之对应，用来存储 Activity 的相关信息。&lt;/p&gt;

&lt;p&gt;相关文档：&lt;a href=&quot;http://gityuan.com/2017/06/11/activity_record/&quot;&gt;四大组件之ActivityRecord&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.3 ActivityStarter#startActivityUnchecked&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.1 ActivityTaskManagerService.deferWindowLayout(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;延迟当前进行的布局，因为页面即将要刷新，继续进行布局没有意义，与 continueWindowLayout() 成对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.2 ActivityStarter.startActivityInner(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这部分的核心逻辑围绕 &lt;a href=&quot;https://developer.android.com/guide/components/activities/tasks-and-back-stack?hl=zh-cn&quot;&gt;任务和返回堆栈 &lt;/a&gt;内容展开：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Task（任务）是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Task（任务）是一个整体单元，当用户开始一个新任务或通过主屏幕按钮进入主屏幕时，任务可移至“后台”。“后台”任务可重新返回到“前台”，以便用户可以从他们离开的地方继续操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了更直观地理解这部分内容，写了一个示例应用：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/activityLaunchMode.apk&quot;&gt;activityLaunchMode.apk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.ActivityStarter#setInitialState&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act1.png&quot; alt=&quot;act1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.ActivityStarter#computeLaunchingTaskFlags&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act2.png&quot; alt=&quot;act2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要判断是否添加 &lt;a href=&quot;https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_NEW_TASK&quot;&gt;FLAG_ACTIVITY_NEW_TASK&lt;/a&gt; 属性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.计算4个task&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Get top task at beginning because the order may be changed when reusing existing task.
final Task prevTopRootTask = mPreferredTaskDisplayArea.getFocusedRootTask();
final Task prevTopTask = prevTopRootTask != null ? prevTopRootTask.getTopLeafTask() : null;
final Task reusedTask = getReusableTask();
final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act3.png&quot; alt=&quot;act3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要逻辑是查找是否存在Activity可复用的Task。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.ActivityStarter#isAllowedToStart&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act4.png&quot; alt=&quot;act4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于 targetTask 再次判断 Activity 是否允许启动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.ActivityStarter#recycleTask&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final boolean newTask = targetTask == null;
final ActivityRecord targetTaskTop = newTask
        ? null : targetTask.getTopNonFinishingActivity();
if (targetTaskTop != null) {
    recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);
} else {
    mAddingToTask = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复用targetTask，从桌面点击应用图标启动应用，targetTask 为 null，不会走 recycleTask() 逻辑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.ActivityStarter#getOrCreateRootTask&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act5.png&quot; alt=&quot;act5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里会创建 RootTask（截图中选中位置）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.ActivityStarter#setNewTask&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (newTask) {
    final Task taskToAffiliate = (mLaunchTaskBehind &amp;amp;&amp;amp; mSourceRecord != null)
            ? mSourceRecord.getTask() : null;
    setNewTask(taskToAffiliate);
} else if (mAddingToTask) {
    addOrReparentStartingActivity(targetTask, &quot;adding to task&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act6.png&quot; alt=&quot;act6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;调用 Task.reuseOrCreateTask(..) 复用或者创建 Task（截图中选中位置），这里会复用刚才创建的 RootTask。&lt;/p&gt;

&lt;p&gt;这里还有一个逻辑是 ActivityStarter#addOrReparentStartingActivity ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (mStartActivity.getTaskFragment() == null
        || mStartActivity.getTaskFragment() == newParent) {
    newParent.addChild(mStartActivity, POSITION_TOP);
} else {
    mStartActivity.reparent(newParent, newParent.getChildCount() /* top */, reason);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mStartActivity 是 ActivityRecord，newParent 是 Task，将ActivityRecord添加到Task中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.Task#moveToFront&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act7.png&quot; alt=&quot;act7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里是将 mTargetRootTask 移至“前台”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.Task#startActivityLocked&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act8.png&quot; alt=&quot;act8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有个应用启动优化项：StartingWindow。&lt;/p&gt;

&lt;p&gt;相关介绍文档：&lt;a href=&quot;https://androidperformance.com/2018/05/20/zhihu-startingwindow/#/StartingWindow-对用户体验的影响&quot;&gt;知乎 救救你的 StartingWindow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10.RootWindowContainer#resumeFocusedTasksTopActivities&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act9.png&quot; alt=&quot;act9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前面已经把 mTargetRootTask 移至“前台”，这里是把 mStartActivity 移至“前台”，主要逻辑在TaskFragment#resumeTopActivity。&lt;/p&gt;

&lt;p&gt;在目标 Activity 显示出来之前，需要把 RootTask 中其他 Activities 暂停：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act10.png&quot; alt=&quot;act10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终会调用到 TaskFragment#schedulePauseActivity （截图中选中位置）通知桌面暂停Launcher，详见 2.2.3。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;void schedulePauseActivity(..) {
    mAtmService.getLifecycleManager().scheduleTransaction(prev.app.getThread(),
            prev.token, PauseActivityItem.obtain(..));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来会判断应用进程是否存在，如果不存在先创建应用进程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;boolean pausing = !deferPause &amp;amp;&amp;amp; taskDisplayArea.pauseBackTasks(next);
if (pausing) {
    if (next.attachedToProcess()) {
        //应用进程存在
        next.app.updateProcessInfo(..);
    } else if (!next.isProcessRunning()) {
        //应用进程不存在，创建进程
        mAtmService.startProcessAsync(..);
    }
} else if (mResumedActivity == next &amp;amp;&amp;amp; next.isState(RESUMED)
        &amp;amp;&amp;amp; taskDisplayArea.allResumedActivitiesComplete()) {
    //执行过渡动画
    executeAppTransition(options);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里闹钟进程不存在，会请求 Zygote 创建闹钟进程，详见 2.3。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.3 ActivityTaskManagerService.continueWindowLayout(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与上文 deferWindowLayout(..) 成对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.4 ActivityStarter.postStartActivityProcessing(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ActivityStartInterceptor 回调监听者 onActivityLaunched(..)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (ActivityManager.isStartResultSuccessful(result)) {
    mInterceptor.onActivityLaunched(targetTask.getTaskInfo(), r);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;223-桌面activitypause&quot;&gt;2.2.3 桌面activityPause&lt;/h3&gt;

&lt;p&gt;桌面收到系统侧 activityPause 通知，处理完后再通知系统侧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_pause1.png&quot; alt=&quot;act_pause1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统侧收到桌面 activityPause 通知：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_pause2.png&quot; alt=&quot;act_pause2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;startSpecificActivity(..) 有多个入口，当应用进程创建完执行 attachApplication 后，才会执行 realStartActivityLocked(..)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final WindowProcessController wpc = mService.getProcessController(..);
if (wpc != null &amp;amp;&amp;amp; wpc.hasThread()) {
    realStartActivityLocked(r, wpc, andResume, checkConfig);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 realStartActivityLocked(..) 中会通知应用侧执行 Activity 生命周期回调，详见 2.5：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final ClientTransaction clientTransaction = ClientTransaction.obtain(..);
clientTransaction.addCallback(LaunchActivityItem.obtain(..));
clientTransaction.setLifecycleStateRequest(ResumeActivityItem.obtain(..));
mService.getLifecycleManager().scheduleTransaction(clientTransaction);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;224-桌面activitystop&quot;&gt;2.2.4 桌面activityStop&lt;/h3&gt;

&lt;p&gt;上接 2.2.3，在显示出 Activity 前会执行 AppTransition 过渡动画：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_stop1.png&quot; alt=&quot;act_stop1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过渡动画执行完后，会通知桌面执行activityStop：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_stop2.png&quot; alt=&quot;act_stop2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结下两个应用 Activity 生命周期：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;桌面 Launcher 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onPause()&lt;/code&gt; 方法执行。&lt;/li&gt;
  &lt;li&gt;闹钟 DeskClockTabActivity 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStart()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onResume()&lt;/code&gt; 方法依次执行（闹钟 DeskClockTabActivity 现在具有用户焦点）。&lt;/li&gt;
  &lt;li&gt;桌面 Launcher 在屏幕上不再显示，其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStop()&lt;/code&gt; 方法执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;23-创建闹钟进程&quot;&gt;2.3 创建闹钟进程&lt;/h2&gt;

&lt;h3 id=&quot;231-系统侧请求创建闹钟进程&quot;&gt;2.3.1 系统侧请求创建闹钟进程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityManagerService.startProcess(..)&lt;/li&gt;
  &lt;li&gt;ActivityManagerService.startProcessLocked(..)&lt;/li&gt;
  &lt;li&gt;ProcessList.startProcessLocked(..)&lt;/li&gt;
  &lt;li&gt;ProcessList.startProcess(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (hostingRecord.usesWebviewZygote()) {
    WebViewZygote.getProcess().start(..)
} else if (hostingRecord.usesAppZygote()) {
    // see FLAG_USE_APP_ZYGOTE
    appZygote.getProcess().start(..)
} else {
    Process.start(..);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;ZYGOTE_PROCESS.start(..)&lt;/li&gt;
  &lt;li&gt;ZYGOTE_PROCESS.startViaZygote(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;static ZygoteState connect(@NonNull LocalSocketAddress zygoteSocketAddress,
        @Nullable LocalSocketAddress usapSocketAddress)
        throws IOException {

    final LocalSocket zygoteSessionSocket = new LocalSocket();

    try {
        zygoteSessionSocket.connect(zygoteSocketAddress);
    } catch (IOException ex) {
    }
    
    return new ZygoteState(..)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;ZYGOTE_PROCESS.zygoteSendArgsAndGetResult(..)&lt;/li&gt;
  &lt;li&gt;ZYGOTE_PROCESS.attemptZygoteSendArgsAndGetResult(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private Process.ProcessStartResult attemptZygoteSendArgsAndGetResult(
        ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx {
    try {
        final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;
        final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;

        zygoteWriter.write(msgStr);
        zygoteWriter.flush();

        // Always read the entire result from the input stream to avoid leaving
        // bytes in the stream for future process starts to accidentally stumble
        // upon.
        Process.ProcessStartResult result = new Process.ProcessStartResult();
        result.pid = zygoteInputStream.readInt();
        result.usingWrapper = zygoteInputStream.readBoolean();

        if (result.pid &amp;lt; 0) {
            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);
        }

        return result;
    } catch (IOException ex) {
        zygoteState.close();
        throw new ZygoteStartFailedEx(ex);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Q：这里为什么不采用Binder进行通信？&lt;/p&gt;

&lt;p&gt;A：fork机制限制，仅支持单线程，而binder会创建多线程。&lt;/p&gt;

&lt;h3 id=&quot;232-zygote创建闹钟进程&quot;&gt;2.3.2 Zygote创建闹钟进程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ZygoteServer.runSelectLoop(..)&lt;/li&gt;
  &lt;li&gt;ZygoteConnection.processCommand(..)&lt;/li&gt;
  &lt;li&gt;Zygote.forkAndSpecialize(..)&lt;/li&gt;
  &lt;li&gt;Zygote.nativeForkAndSpecialize(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;int pid = Zygote.forkAndSpecialize(..);
if (pid == 0) {
    // in child
    handleChildProc(..);
} else {
    // In the parent
    handleParentProc(..);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;24-闹钟主线程初始化&quot;&gt;2.4 闹钟主线程初始化&lt;/h2&gt;

&lt;h3 id=&quot;241-闹钟向系统侧请求attachapplication&quot;&gt;2.4.1 闹钟向系统侧请求attachApplication&lt;/h3&gt;

&lt;p&gt;闹钟进程创建完成后初始化，上接 2.3.2：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Zygote.handleChildProc(..)&lt;/li&gt;
  &lt;li&gt;ZygoteInit.zygoteInit(..)&lt;/li&gt;
  &lt;li&gt;RuntimeInit.applicationInit(..)&lt;/li&gt;
  &lt;li&gt;RuntimeInit.findStaticMain(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.main(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.attach(..)&lt;/li&gt;
  &lt;li&gt;ActivityManagerService.attachApplication(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/application1.png&quot; alt=&quot;application1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统侧收到闹钟 attachApplication 通知，上接 2.2.3，在此之后才会真正启动Activity：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/application2.png&quot; alt=&quot;application2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外，Looper 也是在 ActivityThread.main(..) 中初始化的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;Looper.prepareMainLooper();
Looper.loop();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;242-闹钟处理系统侧bindapplication请求&quot;&gt;2.4.2 闹钟处理系统侧bindApplication请求&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityThread$ApplicationThread.bindApplication(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.sendMessage(H.BIND_APPLICATION, data) // 第一条消息&lt;/li&gt;
  &lt;li&gt;ActivityThread.handleBindApplication(data)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
private void handleBindApplication(AppBindData data) {
    ...
    // JVMTI
    if (agent != null) {
        handleAttachAgent(agent, data.info);
    }

    // 1.创建ContextImpl
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);

    // 2.创建Instrumentation
    if (ii != null) {
        initInstrumentation(ii, data, appContext);
    } else {
        mInstrumentation = new Instrumentation();
        mInstrumentation.basicInit(this);
    }

    try {
        // 3.创建 Application
        app = data.info.makeApplicationInner(data.restrictedBackupMode, null);
        ...
        if (!data.restrictedBackupMode) {
            if (!ArrayUtils.isEmpty(data.providers)) {
                // 初始化ContentProvider
                installContentProviders(app, data.providers);
            }
        }
        ...
        try {
            // call Instrumentation.onCreate()
            mInstrumentation.onCreate(data.instrumentationArgs);
        }
        catch (Exception e) {
        }
        ...
        try {
            // call Application.onCreate()
            mInstrumentation.callApplicationOnCreate(app);
        } catch (Exception e) {
        }
    } finally {
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;25-闹钟activity生命周期&quot;&gt;2.5 闹钟Activity生命周期&lt;/h2&gt;

&lt;p&gt;上接 2.2.3，实例化Activity：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityThread$ApplicationThread.scheduleTransaction(..)&lt;/li&gt;
  &lt;li&gt;ClientTransactionHandler.scheduleTransaction(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread$H.handleMessage(..)&lt;/li&gt;
  &lt;li&gt;TransactionExecutor.execute(..)&lt;/li&gt;
  &lt;li&gt;LaunchActivityItem.execute(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.handleLaunchActivity(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.performLaunchActivity(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;try {
    java.lang.ClassLoader cl = appContext.getClassLoader();
    activity = mInstrumentation.newActivity(
            cl, component.getClassName(), r.intent);
} catch (Exception e) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activity创建后依次执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStart()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onResume()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_lifecycle.png&quot; alt=&quot;act_lifecycle&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;26-activity绘制及显示到屏幕&quot;&gt;2.6 Activity绘制及显示到屏幕&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_draw1.png&quot; alt=&quot;act_draw1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在VSYNC-app周期内：SurfaceFlinger的app线程唤醒home主线程，接下来执行Choreographer的doFrame流程，包括input，animation，traversal阶段，在traversal中执行draw绘制并将绘制的内容同步给RenderThread线程。RenderThread线程先从buffer队列中dequeueBuffer申请一个buffer，填充内容，然后queueBuffer将buffer加入队列，并通知SurfaceFlinger。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_draw2.png&quot; alt=&quot;act_draw2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在VSYNC-sf周期内：处理MessageQueue::INVALIDATE消息，从各Layer的BufferQueue拿到最新的缓冲数据，并根据内容更新脏区域；处理MessageQueue::REFRESH消息，通过HWC合成各Layer的buffer，发送至显示设备进行显示。&lt;/p&gt;

&lt;h1 id=&quot;3-小结&quot;&gt;3. 小结&lt;/h1&gt;

&lt;p&gt;本文以在桌面点击图标启动闹钟应用为例，结合trace简单介绍了Activity启动流程中的关键细节，主要包括：Framework侧处理Activity启动请求、任务和返回栈、Activity生命周期、应用进程创建及初始化及绘制流程等。&lt;/p&gt;

&lt;p&gt;可延伸的知识点包括：Context、Window、View事件分发、View绘制流程、Handler机制、Binder机制、类加载机制、fork机制、ServiceManager、SurfaceFlinger、代码插桩、插件化等。&lt;/p&gt;

&lt;h1 id=&quot;4-参考文档&quot;&gt;4. 参考文档：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/37370c1d17fc&quot;&gt;Android应用启动全流程分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/cf531a3af828&quot;&gt;Android卡顿掉帧问题分析之工具篇&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>Activity</category>
        
        
      </item>
    
      <item>
        <title>DisplayArea树层级结构</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/class_hierarchy.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;RootWindowContainer：最顶层的管理者，直接管理 DisplayContent 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DisplayContent：对应一个真实或者虚拟的显示设备。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TaskDisplayArea：是系统中所有应用任务的父节点，用于管理 Task 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Task：代表一个任务，可以包含多个 Activity 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ActivityRecord：对应一个 Activity 节点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;WindowState：对应一个窗口。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1window相关概念&quot;&gt;1.Window相关概念&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Window Type主要分为三大类：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Application windows（应用窗口）: 1~99&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sub-windows（子窗口）: 1000~1999&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;System windows（系统窗口）: 2000~2999&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Window Layer分为36层：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;default int getMaxWindowLayer() {
    return 36;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Z-Order计算：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;mBaseLayer = WindowLayer * 10000 + 1000;
mSubLayer = SubWindowLayer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Window Type与Window Layer对应关系如下：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Window Type&lt;/th&gt;
      &lt;th&gt;VALUE&lt;/th&gt;
      &lt;th&gt;Window Layer&lt;/th&gt;
      &lt;th&gt;Leaf Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BASE_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;APPLICATION_LAYER = 2&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;LEAF_TYPE_TASK_CONTAINERS = 1&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_STARTING&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DRAWN_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;LAST_APPLICATION_WINDOW&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;99&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1000&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_MEDIA&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1001&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;-2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_SUB_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1002&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_ATTACHED_DIALOG&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1003&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_MEDIA_OVERLAY&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1004&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_ABOVE_SUB_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1005&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SEARCH_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PHONE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_ALERT&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2003&lt;/td&gt;
      &lt;td&gt;12|9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_KEYGUARD&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2004&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_TOAST&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2005&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2006&lt;/td&gt;
      &lt;td&gt;23|20&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRIORITY_PHONE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2007&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2008&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_KEYGUARD_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2009&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_ERROR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2010&lt;/td&gt;
      &lt;td&gt;27|9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_METHOD&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2011&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;LEAF_TYPE_IME_CONTAINERS = 2&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_METHOD_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2012&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_WALLPAPER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2013&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2014&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SECURE_SYSTEM_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2015&lt;/td&gt;
      &lt;td&gt;33&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DRAG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2016&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_SUB_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2017&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_POINTER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2018&lt;/td&gt;
      &lt;td&gt;35&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NAVIGATION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2019&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOLUME_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2020&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BOOT_PROGRESS&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2021&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_CONSUMER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2022&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NAVIGATION_BAR_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2024&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DISPLAY_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2026&lt;/td&gt;
      &lt;td&gt;29&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_MAGNIFICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2027&lt;/td&gt;
      &lt;td&gt;28&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRIVATE_PRESENTATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2030&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOICE_INTERACTION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2031&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_ACCESSIBILITY_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2032&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOICE_INTERACTION_STARTING&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2033&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DOCK_DIVIDER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2034&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_QS_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2035&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SCREENSHOT&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2036&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRESENTATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2037&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2038&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2039&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NOTIFICATION_SHADE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2040&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_ADDITIONAL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2041&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_CARWITH_NAVIGATION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2998&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;常见Window及Window Type：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Window&lt;/th&gt;
      &lt;th&gt;Window Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Activity&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BASE_APPLICATION&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TaskSnapshotWindow&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_STARTING&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dialog&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PopupWindow&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_PANEL&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Toast&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_TOAST&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;2为什么要构建displayarea树&quot;&gt;2.为什么要构建DisplayArea树？&lt;/h1&gt;

&lt;h2 id=&quot;21-需求分析&quot;&gt;2.1 需求分析&lt;/h2&gt;

&lt;p&gt;手机系统有N个类型的Window，需要划分Layer维护Window显示Z-order；&lt;/p&gt;

&lt;p&gt;有N个Feature（功能），每个Feature能够影响N个Layer层；&lt;/p&gt;

&lt;p&gt;窗口类型是可增加的，Feature是可增删的；&lt;/p&gt;

&lt;h2 id=&quot;22-方案设计&quot;&gt;2.2 方案设计&lt;/h2&gt;

&lt;p&gt;构建DisplayArea树，创建Feature节点，支持动态增删Feature，叶子节点维护Layer层级。&lt;/p&gt;

&lt;p&gt;以 DefaultTaskDisplayArea 节点为例：&lt;/p&gt;

&lt;p&gt;其父节点为 5|0|12 -&amp;gt; 3|0|14 -&amp;gt; 6|0|14 -&amp;gt; 4|0|31 -&amp;gt; DisplayContent，其含义为该节点的所有子节点均支持 FullscreenMagnification|5、OneHanded|3、HideDisplayCutout|6、WindowedMagnification|4 功能（Feature）。&lt;/p&gt;

&lt;p&gt;同时 DefaultTaskDisplayArea 节点的子节点的层级范围为 2|2，即所有子节点均为应用窗口，其Layer值是固定的。&lt;/p&gt;

&lt;h1 id=&quot;3构建displayarea树流程&quot;&gt;3.构建DisplayArea树流程&lt;/h1&gt;

&lt;h2 id=&quot;31-创建rootwindowcontainer&quot;&gt;3.1 创建RootWindowContainer&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;SystemServer.main(..)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SystemServer.run()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SystemServer.startOtherServices(..)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;vm = WindowManagerService.main(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
private WindowManagerService(..) {
    mRoot = new RootWindowContainer(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;32-创建displaycontent&quot;&gt;3.2 创建DisplayContent&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityManagerService.setWindowManager(wm)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ActivityTaskManagerService.setWindowManager(wm)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;RootWindowContainer.setWindowManager(wm)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// RootWindowContainer.java
private final ImeContainer mImeWindowsContainer = new ImeContainer(mWmService);
void setWindowManager(WindowManagerService wm) {
    ..
    final Display[] displays = mDisplayManager.getDisplays();
    for (int displayNdx = 0; displayNdx &amp;lt; displays.length; ++displayNdx) {
        final Display display = displays[displayNdx];
        final DisplayContent displayContent = new DisplayContent(display, this);
        addChild(displayContent, POSITION_BOTTOM);
        if (displayContent.mDisplayId == DEFAULT_DISPLAY) {
            mDefaultDisplay = displayContent;
        }
    }
    ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;33-创建defaulttaskdisplayarea&quot;&gt;3.3 创建DefaultTaskDisplayArea&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DisplayContent.java
DisplayContent(Display display, RootWindowContainer root) {
    ..
    final Transaction pendingTransaction = getPendingTransaction();
    configureSurfaces(pendingTransaction);
    pendingTransaction.apply();
    ..
}

private void configureSurfaces(Transaction transaction) {
    ..
    if (mDisplayAreaPolicy == null) {
        // Setup the policy and build the display area hierarchy.
        // Build the hierarchy only after creating the surface so it is reparented correctly
        mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(
                mWmService, this /* content */, this /* root */,
                mImeWindowsContainer);
    }
    ..
}

//DisplayAreaPolicy.java
static final class DefaultProvider implements DisplayAreaPolicy.Provider {
    @Override
    public DisplayAreaPolicy instantiate(WindowManagerService wmService,
            DisplayContent content, RootDisplayArea root,
            DisplayArea.Tokens imeContainer) {
        final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,
                &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);
        final List&amp;lt;TaskDisplayArea&amp;gt; tdaList = new ArrayList&amp;lt;&amp;gt;();
        tdaList.add(defaultTaskDisplayArea);

        // Define the features that will be supported under the root of the whole logical
        // display. The policy will build the DisplayArea hierarchy based on this.
        final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root);
        // Set the essential containers (even if the display doesn&apos;t support IME).
        rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);
        if (content.isTrusted()) {
            // Only trusted display can have system decorations.
            configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);
        }

        // Instantiate the policy with the hierarchy defined above. This will create and attach
        // all the necessary DisplayAreas to the root.
        return new DisplayAreaPolicyBuilder().setRootHierarchy(rootHierarchy).build(wmService);
    }
    
    private void configureTrustedHierarchyBuilder(HierarchyBuilder rootHierarchy,
            WindowManagerService wmService, DisplayContent content) {
        rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;WindowedMagnification&quot;,
                FEATURE_WINDOWED_MAGNIFICATION)
                .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                .setNewDisplayAreaSupplier(DisplayArea.Dimmable::new)
                .build());
        if (content.isDefaultDisplay) {
            rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;HideDisplayCutout&quot;,
                    FEATURE_HIDE_DISPLAY_CUTOUT)
                    .all()
                    .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL, TYPE_STATUS_BAR,
                            TYPE_NOTIFICATION_SHADE)
                    .build())
                    .addFeature(new Feature.Builder(wmService.mPolicy, &quot;OneHanded&quot;,
                            FEATURE_ONE_HANDED)
                            .all()
                            .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL,
                                    TYPE_SECURE_SYSTEM_OVERLAY)
                            .build());
        }
        rootHierarchy
                .addFeature(new Feature.Builder(wmService.mPolicy, &quot;FullscreenMagnification&quot;,
                        FEATURE_FULLSCREEN_MAGNIFICATION)
                        .all()
                        .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY, TYPE_INPUT_METHOD,
                                TYPE_INPUT_METHOD_DIALOG, TYPE_MAGNIFICATION_OVERLAY,
                                TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL)
                        .build())
                .addFeature(new Feature.Builder(wmService.mPolicy, &quot;ImePlaceholder&quot;,
                        FEATURE_IME_PLACEHOLDER)
                        .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG)
                        .build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 configureTrustedHierarchyBuilder(..) 方法中配置Feature及其能够影响到的Layer层：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Feature名&lt;/th&gt;
      &lt;th&gt;Feature ID&lt;/th&gt;
      &lt;th&gt;对应功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;WindowedMagnification&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;窗口放大镜功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HideDisplayCutout&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;隐藏刘海功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OneHanded&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;单手模式。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FullscreenMagnification&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;屏幕放大镜功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ImePlaceholder&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;特殊情况下用来放置输入法的节点。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在Feature类中使用一个长度为 getMaxWindowLayer() + 1 的boolean数组，用来标识该Feature能够影响到的Layer层：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;34-displayareapolicy构建过程&quot;&gt;3.4 DisplayAreaPolicy构建过程&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DisplayAreaPolicyBuilder.java
private void build(@Nullable List&amp;lt;HierarchyBuilder&amp;gt; displayAreaGroupHierarchyBuilders) {
    final WindowManagerPolicy policy = mRoot.mWmService.mPolicy;
    final int maxWindowLayerCount = policy.getMaxWindowLayer() + 1;
    final DisplayArea.Tokens[] displayAreaForLayer =
            new DisplayArea.Tokens[maxWindowLayerCount];
    final Map&amp;lt;Feature, List&amp;lt;DisplayArea&amp;lt;WindowContainer&amp;gt;&amp;gt;&amp;gt; featureAreas =
            new ArrayMap&amp;lt;&amp;gt;(mFeatures.size());
    for (int i = 0; i &amp;lt; mFeatures.size(); i++) {
        featureAreas.put(mFeatures.get(i), new ArrayList&amp;lt;&amp;gt;());
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;341-构建root节点&quot;&gt;3.4.1 构建root节点：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;PendingArea[] areaForLayer = new PendingArea[maxWindowLayerCount];
final PendingArea root = new PendingArea(null, 0, null);
Arrays.fill(areaForLayer, root);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;342-构建featurearea&quot;&gt;3.4.2 构建featureArea：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Create DisplayAreas to cover all defined features.
final int size = mFeatures.size();
for (int i = 0; i &amp;lt; size; i++) {
    final Feature feature = mFeatures.get(i);
    PendingArea featureArea = null;
    for (int layer = 0; layer &amp;lt; maxWindowLayerCount; layer++) {
        if (feature.mWindowLayers[layer]) {
            if (featureArea == null || featureArea.mParent != areaForLayer[layer]) {
                featureArea = new PendingArea(feature, layer, areaForLayer[layer]);
                areaForLayer[layer].mChildren.add(featureArea);
            }
            areaForLayer[layer] = featureArea;
        } else {
            featureArea = null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;黄色部分与上图是相对应的，创建的PendingArea显示格式为：Feature ID|minLayer&lt;/p&gt;

&lt;p&gt;构建出如下一棵树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/tree1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;343-构建-leafarea&quot;&gt;3.4.3 构建 leafArea：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Create Tokens as leaf for every layer.
PendingArea leafArea = null;
int leafType = LEAF_TYPE_TOKENS;
for (int layer = 0; layer &amp;lt; maxWindowLayerCount; layer++) {
    int type = typeOfLayer(policy, layer);
    if (leafArea == null || leafArea.mParent != areaForLayer[layer]
            || type != leafType) {
        leafArea = new PendingArea(null /* feature */, layer, areaForLayer[layer]);
        areaForLayer[layer].mChildren.add(leafArea);
        leafType = type;
        if (leafType == LEAF_TYPE_TASK_CONTAINERS) {
            addTaskDisplayAreasToApplicationLayer(areaForLayer[layer]);
            addDisplayAreaGroupsToApplicationLayer(areaForLayer[layer],
                    displayAreaGroupHierarchyBuilders);
            leafArea.mSkipTokens = true;
        } else if (leafType == LEAF_TYPE_IME_CONTAINERS) {
            leafArea.mExisting = mImeContainer;
            leafArea.mSkipTokens = true;
        }
    }
    leafArea.mMaxLayer = layer;
}

private static int typeOfLayer(WindowManagerPolicy policy, int layer) {
    if (layer == APPLICATION_LAYER) {
        return LEAF_TYPE_TASK_CONTAINERS; // 容纳App窗口的TaskDisplayArea
    } else if (layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD)
            || layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD_DIALOG)) {
        return LEAF_TYPE_IME_CONTAINERS; // 容纳输入法窗口的ImeContainer
    } else {
        return LEAF_TYPE_TOKENS; // 容纳其他非App类型窗口的DisplayArea.Tokens
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;黄色部分表示复用同一个leafArea，更新其mMaxLayer值，这里创建的PendingArea显示格式为：minLayer|maxLayer&lt;/p&gt;

&lt;h3 id=&quot;344-更新整棵树所有节点的maxlayer&quot;&gt;3.4.4 更新整棵树所有节点的maxLayer&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;int computeMaxLayer() {
    for (int i = 0; i &amp;lt; mChildren.size(); i++) {
        mMaxLayer = Math.max(mMaxLayer, mChildren.get(i).computeMaxLayer());
    }
    return mMaxLayer;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;345-构建整棵树&quot;&gt;3.4.5 构建整棵树&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;void instantiateChildren(DisplayArea&amp;lt;DisplayArea&amp;gt; parent, DisplayArea.Tokens[] areaForLayer,
        int level, Map&amp;lt;Feature, List&amp;lt;DisplayArea&amp;lt;WindowContainer&amp;gt;&amp;gt;&amp;gt; areas) {
    mChildren.sort(Comparator.comparingInt(pendingArea -&amp;gt; pendingArea.mMinLayer));
    for (int i = 0; i &amp;lt; mChildren.size(); i++) {
        final PendingArea child = mChildren.get(i);
        final DisplayArea area = child.createArea(parent, areaForLayer);
        if (area == null) {
            // TaskDisplayArea and ImeContainer can be set at different hierarchy, so it can
            // be null.
            continue;
        }
        parent.addChild(area, WindowContainer.POSITION_TOP);
        if (child.mFeature != null) {
            areas.get(child.mFeature).add(area);
        }
        child.instantiateChildren(area, areaForLayer, level + 1, areas);
    }
}

private DisplayArea createArea(DisplayArea&amp;lt;DisplayArea&amp;gt; parent,
        DisplayArea.Tokens[] areaForLayer) {
    if (mExisting != null) {
        // LEAF_TYPE_TASK_CONTAINERS
        // LEAF_TYPE_IME_CONTAINERS
        if (mExisting.asTokens() != null) {
            // Store the WindowToken container for layers
            fillAreaForLayers(mExisting.asTokens(), areaForLayer);
        }
        return mExisting;
    }
    if (mSkipTokens) {
        // LEAF_TYPE_TASK_CONTAINERS
        // LEAF_TYPE_IME_CONTAINERS
        return null;
    }
    DisplayArea.Type type;
    if (mMinLayer &amp;gt; APPLICATION_LAYER) {
        type = DisplayArea.Type.ABOVE_TASKS; // 位于App窗口之下的非App窗口
    } else if (mMaxLayer &amp;lt; APPLICATION_LAYER) {
        type = DisplayArea.Type.BELOW_TASKS; // 位于App窗口之上的非App窗口
    } else {
        type = DisplayArea.Type.ANY; // App窗口
    }
    if (mFeature == null) {
        final DisplayArea.Tokens leaf = new DisplayArea.Tokens(parent.mWmService, type,
                &quot;Leaf:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer);
        fillAreaForLayers(leaf, areaForLayer);
        return leaf;
    } else {
        return mFeature.mNewDisplayAreaSupplier.create(parent.mWmService, type,
                mFeature.mName + &quot;:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer, mFeature.mId);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整棵树的根节点是 DisplayContent，这里创建的DisplayArea显示格式为：Feature ID|minLayer|maxLayer；叶子节点的显示格式为：minLayer|maxLayer&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/tree2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;执行命令：adb shell dumpsys activity containers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;ACTIVITY MANAGER CONTAINERS (dumpsys activity containers)
ROOT 
  #0 Display 0 name=&quot;内置屏幕&quot;
   #2 Leaf:36:36 
    #1 WindowToken{7fb09c2 type=2024 android.os.BinderProxy@da9960d} 
     #0 e873d3 RoundCornerBottom 
    #0 WindowToken{2c592ae type=2024 android.os.BinderProxy@5ce3f29} 
     #0 164a84f RoundCornerTop 
   #1 HideDisplayCutout:32:35 
    #2 OneHanded:34:35 
     #0 FullscreenMagnification:34:35 
      #0 Leaf:34:35 
    #1 FullscreenMagnification:33:33 
     #0 Leaf:33:33 
    #0 OneHanded:32:32 
     #0 Leaf:32:32 
   #0 WindowedMagnification:0:31 
    #6 HideDisplayCutout:26:31 
     #0 OneHanded:26:31 
      #2 FullscreenMagnification:29:31 
       #0 Leaf:29:31 
      #1 Leaf:28:28 
       #1 WindowToken{6cffb72 type=2027 android.os.BinderProxy@9b9807d} 
        #0 e90cc40 GestureStubRight 
       #0 WindowToken{288fa0d type=2027 android.os.BinderProxy@3713ca4} 
        #0 1d77f10 GestureStubLeft 
      #0 FullscreenMagnification:26:27 
       #0 Leaf:26:27 
    #5 Leaf:24:25 
     #3 WindowToken{2cfd75e type=2024 android.os.BinderProxy@a18e899} 
      #0 6d1873f GestureStubHome 
     #2 WindowToken{4a05ae3 type=2024 android.os.BinderProxy@b34e312} 
      #0 28a0ce0 SecondaryHomeHandle0 
     #1 WindowToken{6986f7 type=2024 android.os.BinderProxy@f7da2f6} 
      #0 e17e964 pip-dismiss-overlay 
     #0 WindowToken{dfc6ab6 type=2019 android.os.BinderProxy@e0bfb78} 
      #0 bc113b7 NavigationBar0 
    #4 HideDisplayCutout:18:23 
     #0 OneHanded:18:23 
      #0 FullscreenMagnification:18:23 
       #0 Leaf:18:23 
        #1 WindowToken{2ecacd2 type=2017 android.os.BinderProxy@63e9b5d} 
         #0 7d9c1a3 control_center 
        #0 WindowToken{7960200 type=2017 android.os.BinderProxy@7c7083} 
         #0 b7b0a39 NotificationModalWindowManager 
    #3 OneHanded:17:17 
     #0 FullscreenMagnification:17:17 
      #0 Leaf:17:17 
       #0 WindowToken{37bf169 type=2040 android.os.BinderProxy@80f5833} 
        #0 f89f7ee NotificationShade 
    #2 HideDisplayCutout:16:16 
     #0 OneHanded:16:16 
      #0 FullscreenMagnification:16:16 
       #0 Leaf:16:16 
    #1 OneHanded:15:15 
     #0 FullscreenMagnification:15:15 
      #0 Leaf:15:15 
       #0 WindowToken{ac189b4 type=2000 android.os.BinderProxy@75516c6} 
        #0 194a9dd StatusBar 
    #0 HideDisplayCutout:0:14 
     #0 OneHanded:0:14 
      #1 ImePlaceholder:13:14 
       #0 ImeContainer 
        #0 WindowToken{720aa04 type=2011 android.os.Binder@d506617} 
         #0 f966473 InputMethod 
      #0 FullscreenMagnification:0:12 
       #2 Leaf:3:12 
        #0 WindowToken{ec3f545 type=2038 android.os.BinderProxy@fd8013a} 
         #0 329a9af ShellDropTarget 
       #1 DefaultTaskDisplayArea 
        #2 Task=18 
         #0 Task=19 
          #0 ActivityRecord{296e207 u0 com.miui.home/.launcher.Launcher} t19} 
           #0 9eb98f2 com.miui.home/com.miui.home.launcher.Launcher 
        #1 Task=4 
        #0 Task=5 
         #1 Task=7 
         #0 Task=6 
       #0 Leaf:0:1 
        #1 WallpaperWindowToken{d4d41d3 token=android.os.BinderProxy@2da4fc2} 
         #0 d44d722 com.miui.miwallpaper.wallpaperservice.MiuiKeyguardPictorialWallpaper 
        #0 WallpaperWindowToken{22dbaad token=android.os.Binder@fe41bc4} 
         #0 8db5a66 com.miui.miwallpaper.wallpaperservice.ImageWallpaper 
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到Activity是在DefaultTaskDisplayArea节点下，其他新创建的Window会根据Layer值插入到对应Leaf节点上。&lt;/p&gt;

&lt;h1 id=&quot;4参考资料&quot;&gt;4.参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7140289958085935141&quot;&gt;DisplayArea层级结构（一） —— DisplayArea层级结构的生成&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/7140289685879783432&quot;&gt;DisplayArea层级结构（二） —— 向DisplayArea层级结构添加窗口&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/7140289813516648456&quot;&gt;DisplayArea层级结构（三） —— 总结&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/shensky711/article/details/121530510&quot;&gt;WMS 层级结构 &amp;amp;&amp;amp; DisplayAreaGroup 引入&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/jieliaoyuan8279/article/details/123157937&quot;&gt;窗口层次: DisplayArea树&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/04/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/04/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</guid>
        
        <category>Android</category>
        
        
      </item>
    
  </channel>
</rss>
