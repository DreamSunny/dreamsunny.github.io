<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android学习笔记</title>
    <description>Android学习笔记</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 16 Aug 2023 13:11:35 +0800</pubDate>
    <lastBuildDate>Wed, 16 Aug 2023 13:11:35 +0800</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>DisplayArea树层级结构</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/class_hierarchy.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;RootWindowContainer：最顶层的管理者，直接管理 DisplayContent 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DisplayContent：对应一个真实或者虚拟的显示设备。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TaskDisplayArea：是系统中所有应用任务的父节点，用于管理 Task 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Task：代表一个任务，可以包含多个 Activity 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ActivityRecord：对应一个 Activity 节点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;WindowState：对应一个窗口。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1window相关概念&quot;&gt;1.Window相关概念&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Window Type主要分为三大类：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Application windows（应用窗口）: 1~99&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sub-windows（子窗口）: 1000~1999&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;System windows（系统窗口）: 2000~2999&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Window Layer分为36层：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;default int getMaxWindowLayer() {
    return 36;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Z-Order计算：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;mBaseLayer = WindowLayer * 10000 + 1000;
mSubLayer = SubWindowLayer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Window Type与Window Layer对应关系如下：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Window Type&lt;/th&gt;
      &lt;th&gt;VALUE&lt;/th&gt;
      &lt;th&gt;Window Layer&lt;/th&gt;
      &lt;th&gt;Leaf Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BASE_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;APPLICATION_LAYER = 2&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;LEAF_TYPE_TASK_CONTAINERS = 1&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_STARTING&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DRAWN_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;LAST_APPLICATION_WINDOW&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;99&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1000&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_MEDIA&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1001&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;-2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_SUB_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1002&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_ATTACHED_DIALOG&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1003&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_MEDIA_OVERLAY&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1004&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_ABOVE_SUB_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1005&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SEARCH_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PHONE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_ALERT&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2003&lt;/td&gt;
      &lt;td&gt;12|9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_KEYGUARD&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2004&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_TOAST&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2005&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2006&lt;/td&gt;
      &lt;td&gt;23|20&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRIORITY_PHONE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2007&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2008&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_KEYGUARD_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2009&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_ERROR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2010&lt;/td&gt;
      &lt;td&gt;27|9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_METHOD&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2011&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;LEAF_TYPE_IME_CONTAINERS = 2&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_METHOD_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2012&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_WALLPAPER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2013&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2014&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SECURE_SYSTEM_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2015&lt;/td&gt;
      &lt;td&gt;33&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DRAG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2016&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_SUB_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2017&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_POINTER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2018&lt;/td&gt;
      &lt;td&gt;35&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NAVIGATION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2019&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOLUME_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2020&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BOOT_PROGRESS&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2021&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_CONSUMER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2022&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NAVIGATION_BAR_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2024&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DISPLAY_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2026&lt;/td&gt;
      &lt;td&gt;29&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_MAGNIFICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2027&lt;/td&gt;
      &lt;td&gt;28&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRIVATE_PRESENTATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2030&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOICE_INTERACTION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2031&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_ACCESSIBILITY_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2032&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOICE_INTERACTION_STARTING&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2033&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DOCK_DIVIDER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2034&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_QS_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2035&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SCREENSHOT&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2036&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRESENTATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2037&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2038&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2039&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NOTIFICATION_SHADE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2040&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_ADDITIONAL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2041&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_CARWITH_NAVIGATION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2998&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;常见Window及Window Type：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Window&lt;/th&gt;
      &lt;th&gt;Window Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Activity&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BASE_APPLICATION&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TaskSnapshotWindow&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_STARTING&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dialog&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PopupWindow&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_PANEL&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Toast&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_TOAST&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;2为什么要构建displayarea树&quot;&gt;2.为什么要构建DisplayArea树？&lt;/h1&gt;

&lt;h2 id=&quot;21-需求分析&quot;&gt;2.1 需求分析&lt;/h2&gt;

&lt;p&gt;手机系统有N个类型的Window，需要划分Layer维护Window显示Z-order；&lt;/p&gt;

&lt;p&gt;有N个Feature（功能），每个Feature能够影响N个Layer层；&lt;/p&gt;

&lt;p&gt;窗口类型是可增加的，Feature是可增删的；&lt;/p&gt;

&lt;h2 id=&quot;22-方案设计&quot;&gt;2.2 方案设计&lt;/h2&gt;

&lt;p&gt;构建DisplayArea树，创建Feature节点，支持动态增删Feature，叶子节点维护Layer层级。&lt;/p&gt;

&lt;p&gt;以 DefaultTaskDisplayArea 节点为例：&lt;/p&gt;

&lt;p&gt;其父节点为 5|0|12 -&amp;gt; 3|0|14 -&amp;gt; 6|0|14 -&amp;gt; 4|0|31 -&amp;gt; DisplayContent，其含义为该节点的所有子节点均支持 FullscreenMagnification|5、OneHanded|3、HideDisplayCutout|6、WindowedMagnification|4 功能（Feature）。&lt;/p&gt;

&lt;p&gt;同时 DefaultTaskDisplayArea 节点的子节点的层级范围为 2|2，即所有子节点均为应用窗口，其Layer值是固定的。&lt;/p&gt;

&lt;h1 id=&quot;3构建displayarea树流程&quot;&gt;3.构建DisplayArea树流程&lt;/h1&gt;

&lt;h2 id=&quot;31-创建rootwindowcontainer&quot;&gt;3.1 创建RootWindowContainer&lt;/h2&gt;

&lt;p&gt;1.SystemServer.main(..)&lt;/p&gt;

&lt;p&gt;2.SystemServer.run()&lt;/p&gt;

&lt;p&gt;3.SystemServer.startOtherServices(..)&lt;/p&gt;

&lt;p&gt;4.vm = WindowManagerService.main(..)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
private WindowManagerService(..) {
    mRoot = new RootWindowContainer(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;32-创建displaycontent&quot;&gt;3.2 创建DisplayContent&lt;/h2&gt;

&lt;p&gt;5.ActivityManagerService.setWindowManager(wm)&lt;/p&gt;

&lt;p&gt;6.ActivityTaskManagerService.setWindowManager(wm)&lt;/p&gt;

&lt;p&gt;7.RootWindowContainer.setWindowManager(wm)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// RootWindowContainer.java
private final ImeContainer mImeWindowsContainer = new ImeContainer(mWmService);
void setWindowManager(WindowManagerService wm) {
    ..
    final Display[] displays = mDisplayManager.getDisplays();
    for (int displayNdx = 0; displayNdx &amp;lt; displays.length; ++displayNdx) {
        final Display display = displays[displayNdx];
        final DisplayContent displayContent = new DisplayContent(display, this);
        addChild(displayContent, POSITION_BOTTOM);
        if (displayContent.mDisplayId == DEFAULT_DISPLAY) {
            mDefaultDisplay = displayContent;
        }
    }
    ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;33-创建defaulttaskdisplayarea&quot;&gt;3.3 创建DefaultTaskDisplayArea&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DisplayContent.java
DisplayContent(Display display, RootWindowContainer root) {
    ..
    final Transaction pendingTransaction = getPendingTransaction();
    configureSurfaces(pendingTransaction);
    pendingTransaction.apply();
    ..
}

private void configureSurfaces(Transaction transaction) {
    ..
    if (mDisplayAreaPolicy == null) {
        // Setup the policy and build the display area hierarchy.
        // Build the hierarchy only after creating the surface so it is reparented correctly
        mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(
                mWmService, this /* content */, this /* root */,
                mImeWindowsContainer);
    }
    ..
}

//DisplayAreaPolicy.java
static final class DefaultProvider implements DisplayAreaPolicy.Provider {
    @Override
    public DisplayAreaPolicy instantiate(WindowManagerService wmService,
            DisplayContent content, RootDisplayArea root,
            DisplayArea.Tokens imeContainer) {
        final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,
                &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);
        final List&amp;lt;TaskDisplayArea&amp;gt; tdaList = new ArrayList&amp;lt;&amp;gt;();
        tdaList.add(defaultTaskDisplayArea);

        // Define the features that will be supported under the root of the whole logical
        // display. The policy will build the DisplayArea hierarchy based on this.
        final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root);
        // Set the essential containers (even if the display doesn&apos;t support IME).
        rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);
        if (content.isTrusted()) {
            // Only trusted display can have system decorations.
            configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);
        }

        // Instantiate the policy with the hierarchy defined above. This will create and attach
        // all the necessary DisplayAreas to the root.
        return new DisplayAreaPolicyBuilder().setRootHierarchy(rootHierarchy).build(wmService);
    }
    
    private void configureTrustedHierarchyBuilder(HierarchyBuilder rootHierarchy,
            WindowManagerService wmService, DisplayContent content) {
        rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;WindowedMagnification&quot;,
                FEATURE_WINDOWED_MAGNIFICATION)
                .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                .setNewDisplayAreaSupplier(DisplayArea.Dimmable::new)
                .build());
        if (content.isDefaultDisplay) {
            rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;HideDisplayCutout&quot;,
                    FEATURE_HIDE_DISPLAY_CUTOUT)
                    .all()
                    .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL, TYPE_STATUS_BAR,
                            TYPE_NOTIFICATION_SHADE)
                    .build())
                    .addFeature(new Feature.Builder(wmService.mPolicy, &quot;OneHanded&quot;,
                            FEATURE_ONE_HANDED)
                            .all()
                            .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL,
                                    TYPE_SECURE_SYSTEM_OVERLAY)
                            .build());
        }
        rootHierarchy
                .addFeature(new Feature.Builder(wmService.mPolicy, &quot;FullscreenMagnification&quot;,
                        FEATURE_FULLSCREEN_MAGNIFICATION)
                        .all()
                        .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY, TYPE_INPUT_METHOD,
                                TYPE_INPUT_METHOD_DIALOG, TYPE_MAGNIFICATION_OVERLAY,
                                TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL)
                        .build())
                .addFeature(new Feature.Builder(wmService.mPolicy, &quot;ImePlaceholder&quot;,
                        FEATURE_IME_PLACEHOLDER)
                        .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG)
                        .build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 configureTrustedHierarchyBuilder(..) 方法中配置Feature及其能够影响到的Layer层：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Feature名&lt;/th&gt;
      &lt;th&gt;Feature ID&lt;/th&gt;
      &lt;th&gt;对应功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;WindowedMagnification&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;窗口放大镜功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HideDisplayCutout&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;隐藏刘海功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OneHanded&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;单手模式。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FullscreenMagnification&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;屏幕放大镜功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ImePlaceholder&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;特殊情况下用来放置输入法的节点。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在Feature类中使用一个长度为 getMaxWindowLayer() + 1 的boolean数组，用来标识该Feature能够影响到的Layer层：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;34-displayareapolicy构建过程&quot;&gt;3.4 DisplayAreaPolicy构建过程&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DisplayAreaPolicyBuilder.java
private void build(@Nullable List&amp;lt;HierarchyBuilder&amp;gt; displayAreaGroupHierarchyBuilders) {
    final WindowManagerPolicy policy = mRoot.mWmService.mPolicy;
    final int maxWindowLayerCount = policy.getMaxWindowLayer() + 1;
    final DisplayArea.Tokens[] displayAreaForLayer =
            new DisplayArea.Tokens[maxWindowLayerCount];
    final Map&amp;lt;Feature, List&amp;lt;DisplayArea&amp;lt;WindowContainer&amp;gt;&amp;gt;&amp;gt; featureAreas =
            new ArrayMap&amp;lt;&amp;gt;(mFeatures.size());
    for (int i = 0; i &amp;lt; mFeatures.size(); i++) {
        featureAreas.put(mFeatures.get(i), new ArrayList&amp;lt;&amp;gt;());
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;341-构建root节点&quot;&gt;3.4.1 构建root节点：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;PendingArea[] areaForLayer = new PendingArea[maxWindowLayerCount];
final PendingArea root = new PendingArea(null, 0, null);
Arrays.fill(areaForLayer, root);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;342-构建featurearea&quot;&gt;3.4.2 构建featureArea：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Create DisplayAreas to cover all defined features.
final int size = mFeatures.size();
for (int i = 0; i &amp;lt; size; i++) {
    final Feature feature = mFeatures.get(i);
    PendingArea featureArea = null;
    for (int layer = 0; layer &amp;lt; maxWindowLayerCount; layer++) {
        if (feature.mWindowLayers[layer]) {
            if (featureArea == null || featureArea.mParent != areaForLayer[layer]) {
                featureArea = new PendingArea(feature, layer, areaForLayer[layer]);
                areaForLayer[layer].mChildren.add(featureArea);
            }
            areaForLayer[layer] = featureArea;
        } else {
            featureArea = null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;黄色部分与上图是相对应的，创建的PendingArea显示格式为：Feature ID|minLayer&lt;/p&gt;

&lt;p&gt;构建出如下一棵树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/tree1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;343-构建-leafarea&quot;&gt;3.4.3 构建 leafArea：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Create Tokens as leaf for every layer.
PendingArea leafArea = null;
int leafType = LEAF_TYPE_TOKENS;
for (int layer = 0; layer &amp;lt; maxWindowLayerCount; layer++) {
    int type = typeOfLayer(policy, layer);
    if (leafArea == null || leafArea.mParent != areaForLayer[layer]
            || type != leafType) {
        leafArea = new PendingArea(null /* feature */, layer, areaForLayer[layer]);
        areaForLayer[layer].mChildren.add(leafArea);
        leafType = type;
        if (leafType == LEAF_TYPE_TASK_CONTAINERS) {
            addTaskDisplayAreasToApplicationLayer(areaForLayer[layer]);
            addDisplayAreaGroupsToApplicationLayer(areaForLayer[layer],
                    displayAreaGroupHierarchyBuilders);
            leafArea.mSkipTokens = true;
        } else if (leafType == LEAF_TYPE_IME_CONTAINERS) {
            leafArea.mExisting = mImeContainer;
            leafArea.mSkipTokens = true;
        }
    }
    leafArea.mMaxLayer = layer;
}

private static int typeOfLayer(WindowManagerPolicy policy, int layer) {
    if (layer == APPLICATION_LAYER) {
        return LEAF_TYPE_TASK_CONTAINERS; // 容纳App窗口的TaskDisplayArea
    } else if (layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD)
            || layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD_DIALOG)) {
        return LEAF_TYPE_IME_CONTAINERS; // 容纳输入法窗口的ImeContainer
    } else {
        return LEAF_TYPE_TOKENS; // 容纳其他非App类型窗口的DisplayArea.Tokens
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;黄色部分表示复用同一个leafArea，更新其mMaxLayer值，这里创建的PendingArea显示格式为：minLayer|maxLayer&lt;/p&gt;

&lt;h3 id=&quot;344-更新整棵树所有节点的maxlayer&quot;&gt;3.4.4 更新整棵树所有节点的maxLayer&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;int computeMaxLayer() {
    for (int i = 0; i &amp;lt; mChildren.size(); i++) {
        mMaxLayer = Math.max(mMaxLayer, mChildren.get(i).computeMaxLayer());
    }
    return mMaxLayer;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;345-构建整棵树&quot;&gt;3.4.5 构建整棵树&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;void instantiateChildren(DisplayArea&amp;lt;DisplayArea&amp;gt; parent, DisplayArea.Tokens[] areaForLayer,
        int level, Map&amp;lt;Feature, List&amp;lt;DisplayArea&amp;lt;WindowContainer&amp;gt;&amp;gt;&amp;gt; areas) {
    mChildren.sort(Comparator.comparingInt(pendingArea -&amp;gt; pendingArea.mMinLayer));
    for (int i = 0; i &amp;lt; mChildren.size(); i++) {
        final PendingArea child = mChildren.get(i);
        final DisplayArea area = child.createArea(parent, areaForLayer);
        if (area == null) {
            // TaskDisplayArea and ImeContainer can be set at different hierarchy, so it can
            // be null.
            continue;
        }
        parent.addChild(area, WindowContainer.POSITION_TOP);
        if (child.mFeature != null) {
            areas.get(child.mFeature).add(area);
        }
        child.instantiateChildren(area, areaForLayer, level + 1, areas);
    }
}

private DisplayArea createArea(DisplayArea&amp;lt;DisplayArea&amp;gt; parent,
        DisplayArea.Tokens[] areaForLayer) {
    if (mExisting != null) {
        // LEAF_TYPE_TASK_CONTAINERS
        // LEAF_TYPE_IME_CONTAINERS
        if (mExisting.asTokens() != null) {
            // Store the WindowToken container for layers
            fillAreaForLayers(mExisting.asTokens(), areaForLayer);
        }
        return mExisting;
    }
    if (mSkipTokens) {
        // LEAF_TYPE_TASK_CONTAINERS
        // LEAF_TYPE_IME_CONTAINERS
        return null;
    }
    DisplayArea.Type type;
    if (mMinLayer &amp;gt; APPLICATION_LAYER) {
        type = DisplayArea.Type.ABOVE_TASKS; // 位于App窗口之下的非App窗口
    } else if (mMaxLayer &amp;lt; APPLICATION_LAYER) {
        type = DisplayArea.Type.BELOW_TASKS; // 位于App窗口之上的非App窗口
    } else {
        type = DisplayArea.Type.ANY; // App窗口
    }
    if (mFeature == null) {
        final DisplayArea.Tokens leaf = new DisplayArea.Tokens(parent.mWmService, type,
                &quot;Leaf:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer);
        fillAreaForLayers(leaf, areaForLayer);
        return leaf;
    } else {
        return mFeature.mNewDisplayAreaSupplier.create(parent.mWmService, type,
                mFeature.mName + &quot;:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer, mFeature.mId);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整棵树的根节点是 DisplayContent，这里创建的DisplayArea显示格式为：Feature ID|minLayer|maxLayer；叶子节点的显示格式为：minLayer|maxLayer&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/tree2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;执行命令：adb shell dumpsys activity containers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;ACTIVITY MANAGER CONTAINERS (dumpsys activity containers)
ROOT 
  #0 Display 0 name=&quot;内置屏幕&quot;
   #2 Leaf:36:36 
    #1 WindowToken{7fb09c2 type=2024 android.os.BinderProxy@da9960d} 
     #0 e873d3 RoundCornerBottom 
    #0 WindowToken{2c592ae type=2024 android.os.BinderProxy@5ce3f29} 
     #0 164a84f RoundCornerTop 
   #1 HideDisplayCutout:32:35 
    #2 OneHanded:34:35 
     #0 FullscreenMagnification:34:35 
      #0 Leaf:34:35 
    #1 FullscreenMagnification:33:33 
     #0 Leaf:33:33 
    #0 OneHanded:32:32 
     #0 Leaf:32:32 
   #0 WindowedMagnification:0:31 
    #6 HideDisplayCutout:26:31 
     #0 OneHanded:26:31 
      #2 FullscreenMagnification:29:31 
       #0 Leaf:29:31 
      #1 Leaf:28:28 
       #1 WindowToken{6cffb72 type=2027 android.os.BinderProxy@9b9807d} 
        #0 e90cc40 GestureStubRight 
       #0 WindowToken{288fa0d type=2027 android.os.BinderProxy@3713ca4} 
        #0 1d77f10 GestureStubLeft 
      #0 FullscreenMagnification:26:27 
       #0 Leaf:26:27 
    #5 Leaf:24:25 
     #3 WindowToken{2cfd75e type=2024 android.os.BinderProxy@a18e899} 
      #0 6d1873f GestureStubHome 
     #2 WindowToken{4a05ae3 type=2024 android.os.BinderProxy@b34e312} 
      #0 28a0ce0 SecondaryHomeHandle0 
     #1 WindowToken{6986f7 type=2024 android.os.BinderProxy@f7da2f6} 
      #0 e17e964 pip-dismiss-overlay 
     #0 WindowToken{dfc6ab6 type=2019 android.os.BinderProxy@e0bfb78} 
      #0 bc113b7 NavigationBar0 
    #4 HideDisplayCutout:18:23 
     #0 OneHanded:18:23 
      #0 FullscreenMagnification:18:23 
       #0 Leaf:18:23 
        #1 WindowToken{2ecacd2 type=2017 android.os.BinderProxy@63e9b5d} 
         #0 7d9c1a3 control_center 
        #0 WindowToken{7960200 type=2017 android.os.BinderProxy@7c7083} 
         #0 b7b0a39 NotificationModalWindowManager 
    #3 OneHanded:17:17 
     #0 FullscreenMagnification:17:17 
      #0 Leaf:17:17 
       #0 WindowToken{37bf169 type=2040 android.os.BinderProxy@80f5833} 
        #0 f89f7ee NotificationShade 
    #2 HideDisplayCutout:16:16 
     #0 OneHanded:16:16 
      #0 FullscreenMagnification:16:16 
       #0 Leaf:16:16 
    #1 OneHanded:15:15 
     #0 FullscreenMagnification:15:15 
      #0 Leaf:15:15 
       #0 WindowToken{ac189b4 type=2000 android.os.BinderProxy@75516c6} 
        #0 194a9dd StatusBar 
    #0 HideDisplayCutout:0:14 
     #0 OneHanded:0:14 
      #1 ImePlaceholder:13:14 
       #0 ImeContainer 
        #0 WindowToken{720aa04 type=2011 android.os.Binder@d506617} 
         #0 f966473 InputMethod 
      #0 FullscreenMagnification:0:12 
       #2 Leaf:3:12 
        #0 WindowToken{ec3f545 type=2038 android.os.BinderProxy@fd8013a} 
         #0 329a9af ShellDropTarget 
       #1 DefaultTaskDisplayArea 
        #2 Task=18 
         #0 Task=19 
          #0 ActivityRecord{296e207 u0 com.miui.home/.launcher.Launcher} t19} 
           #0 9eb98f2 com.miui.home/com.miui.home.launcher.Launcher 
        #1 Task=4 
        #0 Task=5 
         #1 Task=7 
         #0 Task=6 
       #0 Leaf:0:1 
        #1 WallpaperWindowToken{d4d41d3 token=android.os.BinderProxy@2da4fc2} 
         #0 d44d722 com.miui.miwallpaper.wallpaperservice.MiuiKeyguardPictorialWallpaper 
        #0 WallpaperWindowToken{22dbaad token=android.os.Binder@fe41bc4} 
         #0 8db5a66 com.miui.miwallpaper.wallpaperservice.ImageWallpaper 
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到Activity是在DefaultTaskDisplayArea节点下，其他新创建的Window会根据Layer值插入到对应Leaf节点上。&lt;/p&gt;

&lt;h1 id=&quot;4参考资料&quot;&gt;4.参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7140289958085935141&quot;&gt;DisplayArea层级结构（一） —— DisplayArea层级结构的生成&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/7140289685879783432&quot;&gt;DisplayArea层级结构（二） —— 向DisplayArea层级结构添加窗口&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/7140289813516648456&quot;&gt;DisplayArea层级结构（三） —— 总结&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/shensky711/article/details/121530510&quot;&gt;WMS 层级结构 &amp;amp;&amp;amp; DisplayAreaGroup 引入&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/jieliaoyuan8279/article/details/123157937&quot;&gt;窗口层次: DisplayArea树&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 24 Dec 2022 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/12/24/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/12/24/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</guid>
        
        <category>Android</category>
        
        
      </item>
    
  </channel>
</rss>
