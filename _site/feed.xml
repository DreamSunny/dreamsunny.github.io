<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android学习笔记</title>
    <description>Android学习笔记</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 24 Aug 2023 22:31:24 +0800</pubDate>
    <lastBuildDate>Thu, 24 Aug 2023 22:31:24 +0800</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>抖音Android基础技术大揭秘</title>
        <description>&lt;h1 id=&quot;1抖音android基础技术大揭秘-vol01&quot;&gt;1.抖音Android基础技术大揭秘 Vol.01&lt;/h1&gt;

&lt;p&gt;掘金：&lt;a href=&quot;https://live.juejin.cn/4354/6654710&quot;&gt;字节跳动技术沙龙（第10期）&lt;/a&gt;&lt;br /&gt;
B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1eh4y1s7kR&quot;&gt;字节跳动技术沙龙（第10期）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin1.png&quot; alt=&quot;douyin1&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2抖音android基础技术大揭秘-vol02&quot;&gt;2.抖音Android基础技术大揭秘 Vol.02&lt;/h1&gt;

&lt;p&gt;掘金：&lt;a href=&quot;https://live.juejin.cn/4354/9932368&quot;&gt;字节跳动技术沙龙（第12期）&lt;/a&gt;&lt;br /&gt;
B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1bc411V7tE&quot;&gt;字节跳动技术沙龙（第12期）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin2.png&quot; alt=&quot;douyin2&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3抖音android基础技术大揭秘-vol03&quot;&gt;3.抖音Android基础技术大揭秘 Vol.03&lt;/h1&gt;

&lt;p&gt;掘金：&lt;a href=&quot;https://live.byteoc.com/9281/2307433&quot;&gt;抖音Android基础技术大揭秘第三期&lt;/a&gt;&lt;br /&gt;
B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1Fh4y1X71b&quot;&gt;抖音Android基础技术大揭秘第三期&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin3.png&quot; alt=&quot;douyin3&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4抖音android基础技术大揭秘-vol04&quot;&gt;4.抖音Android基础技术大揭秘 Vol.04&lt;/h1&gt;

&lt;p&gt;B站：&lt;a href=&quot;https://www.bilibili.com/video/BV1zu4y1o74x/&quot;&gt;抖音Android基础技术大揭秘第四期&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/douyin/douyin4.png&quot; alt=&quot;douyin4&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 29 May 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/05/29/%E6%8A%96%E9%9F%B3Android%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E5%A4%A7%E6%8F%AD%E7%A7%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/05/29/%E6%8A%96%E9%9F%B3Android%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E5%A4%A7%E6%8F%AD%E7%A7%98/</guid>
        
        <category>Android</category>
        
        <category>Performance</category>
        
        <category>Stability</category>
        
        
      </item>
    
      <item>
        <title>Activity显示流程</title>
        <description>&lt;p&gt;在 &lt;a href=&quot;https://dreamsunny.github.io/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/&quot;&gt;Activity启动流程&lt;/a&gt; 中，我们知道了系统侧响应 Activity 启动请求会创建 Task ；&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&quot;https://dreamsunny.github.io/2022/12/24/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/&quot;&gt;DisplayArea树层级结构&lt;/a&gt;中，我们了解了 Task 最终会添加到 DefaultTaskDisplayArea ；&lt;/p&gt;

&lt;p&gt;本文主要梳理下Activity显示流程。&lt;/p&gt;

&lt;h1 id=&quot;1task添加到defaulttaskdisplayarea&quot;&gt;1.Task添加到DefaultTaskDisplayArea&lt;/h1&gt;

&lt;p&gt;调用堆栈如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/trace1.png&quot; alt=&quot;trace1&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// TaskDisplayArea.java
Task getOrCreateRootTask(..) {
    ...
    return new Task.Builder(mAtmService)
            ...
            .setParent(this)
            ...
            .build();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 setParent(this) 传入的是 TaskDisplayArea 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Task.java
Task build() {
    ...
    final Task task = buildInner();
    ...
    if (mParent != null) {
        if (mParent instanceof Task) {
            final Task parentTask = (Task) mParent;
            parentTask.addChild(task, mOnTop ? POSITION_TOP : POSITION_BOTTOM,
                    (mActivityInfo.flags &amp;amp; FLAG_SHOW_FOR_ALL_USERS) != 0);
        } else {
            mParent.addChild(task, mOnTop ? POSITION_TOP : POSITION_BOTTOM);
        }
    }
    ...
    return task;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Task.Builder的build() 方法中，将创建的task添加到 TaskDisplayArea。&lt;/p&gt;

&lt;h1 id=&quot;2activityrecord添加到task&quot;&gt;2.ActivityRecord添加到Task&lt;/h1&gt;

&lt;p&gt;调用堆栈如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/trace2.png&quot; alt=&quot;trace2&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建ActivityRecord：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityStarter.java
private int executeRequest(Request request) {
    ...
    final ActivityRecord r = new ActivityRecord.Builder(mService)
            ...
            .build();
    ...
}
// ActivityRecord.java
private ActivityRecord(..) {
    super(_service.mWindowManager, new Token(), TYPE_APPLICATION, true,
            null /* displayContent */, false /* ownerCanManageAppTokens */);
    ((Token) token).mActivityRef = new WeakReference&amp;lt;&amp;gt;(this);
}

private static class Token extends Binder {
    @NonNull WeakReference&amp;lt;ActivityRecord&amp;gt; mActivityRef;

    @Override
    public String toString() {
        return &quot;Token{&quot; + Integer.toHexString(System.identityHashCode(this)) + &quot; &quot;
                + mActivityRef.get() + &quot;}&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;添加到 Task 中：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityStarter.java
private void addOrReparentStartingActivity(@NonNull Task task, String reason) {
    ..
    TaskFragment newParent = task;
    ...
    if (mStartActivity.getTaskFragment() == null
            || mStartActivity.getTaskFragment() == newParent) {
        newParent.addChild(mStartActivity, POSITION_TOP);
    } else {
        mStartActivity.reparent(newParent, newParent.getChildCount() /* top */, reason);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;添加到 DisplayContent 的 mTokenMap 中：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowToken.java
void onDisplayChanged(DisplayContent dc) {
    dc.reParentWindowToken(this);
    super.onDisplayChanged(dc);
}
// DisplayContent.java
void reParentWindowToken(WindowToken token) {
    ...
    addWindowToken(token.token, token);
    ...
}

void addWindowToken(IBinder binder, WindowToken token) {
    ...
    mTokenMap.put(binder, token);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3activity窗口添加到wms&quot;&gt;3.Activity窗口添加到WMS&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_show.png&quot; alt=&quot;act_show&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;31-activitysetcontentview&quot;&gt;3.1 Activity.setContentView(..)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Activity.java
public void setContentView(@LayoutRes int layoutResID) {
    getWindow().setContentView(layoutResID);
    initWindowDecorActionBar();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activity.setContentView(..) 中直接调用 PhoneWindow.setContentView(..) 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// PhoneWindow.java
public void setContentView(int layoutResID) {
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        ...
    }

    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        ...
    } else {
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
    ...
}

private void installDecor() {
    mForceDecorInstall = false;
    if (mDecor == null) {
        mDecor = generateDecor(-1);
        ...
    } else {
        mDecor.setWindow(this);
    }
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor);
        ...
    }
}

protected DecorView generateDecor(int featureId) {
    ...
    return new DecorView(context, featureId, this, getAttributes());
}

protected ViewGroup generateLayout(DecorView decor) {
    ...
    int layoutResource;
    int features = getLocalFeatures();
    if ((features &amp;amp; ((1 &amp;lt;&amp;lt; FEATURE_LEFT_ICON) | (1 &amp;lt;&amp;lt; FEATURE_RIGHT_ICON))) != 0) {
        ..
    } else if ((features &amp;amp; ((1 &amp;lt;&amp;lt; FEATURE_PROGRESS) | (1 &amp;lt;&amp;lt; FEATURE_INDETERMINATE_PROGRESS))) != 0
        &amp;amp;&amp;amp; (features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_ACTION_BAR)) == 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_CUSTOM_TITLE)) != 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_NO_TITLE)) == 0) {
        ..
    } else if ((features &amp;amp; (1 &amp;lt;&amp;lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) {
        ..
    } else {
        layoutResource = R.layout.screen_simple;
    }
    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);
    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
    ...
    return contentParent;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PhoneWindow.setContentView(..) 方法主要做3件事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建DecorView。&lt;/li&gt;
  &lt;li&gt;inflate Activity 根布局。&lt;/li&gt;
  &lt;li&gt;inflate Activity 视图布局（setContentView()传入的layoutResID）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中系统预置 Activity 根布局有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;feature&lt;/th&gt;
      &lt;th&gt;布局&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_LEFT_ICON&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_RIGHT_ICON&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_title_icons.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_PROGRESS&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_INDETERMINATE_PROGRESS&lt;/em&gt; &lt;br /&gt; &lt;em&gt;FEATURE_ACTION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_progress.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_CUSTOM_TITLE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_custom_title.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_NO_TITLE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_title.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;FEATURE_ACTION_MODE_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;screen_simple_overlay_action_mode.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;else&lt;/td&gt;
      &lt;td&gt;screen_simple.xml&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以 screen_simple.xml 为例查看其布局：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// screen_simple.xml
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;
    android:orientation=&quot;vertical&quot;&amp;gt;
    &amp;lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot;
              android:inflatedId=&quot;@+id/action_mode_bar&quot;
              android:layout=&quot;@layout/action_mode_bar&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;wrap_content&quot;
              android:theme=&quot;?attr/actionBarTheme&quot; /&amp;gt;
    &amp;lt;FrameLayout
         android:id=&quot;@android:id/content&quot;
         android:layout_width=&quot;match_parent&quot;
         android:layout_height=&quot;match_parent&quot;
         android:foregroundInsidePadding=&quot;false&quot;
         android:foregroundGravity=&quot;fill_horizontal|top&quot;
         android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&amp;gt;
&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应整个 Activity 视图为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/decor.png&quot; alt=&quot;decor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终，Activity.setContentView(..) 传入的布局会添加到 FrameLayout(id=ID_ANDROID_CONTENT) 。&lt;/p&gt;

&lt;h2 id=&quot;32-viewrootimplsetview&quot;&gt;3.2 ViewRootImpl.setView(..)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ViewRootImpl.java
public ViewRootImpl(Context context, Display display) {
    this(context, display, WindowManagerGlobal.getWindowSession(),
            false /* useSfChoreographer */);
}

public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session) {
    this(context, display, session, false /* useSfChoreographer */);
}

public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session,
        boolean useSfChoreographer) {
    mWindowSession = session;
    mWindow = new W(this);
    ...
}

public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,
        int userId, Bundle bundle) {
    synchronized (this) {
        if (mView == null) {
            ...
            try {
                res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,
                        getHostVisibility(), mDisplay.getDisplayId(), userId,
                        mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,
                        mTempControls);
            } catch (RemoteException e) {
            } finally {
            }
            ...
        }
    }
}
// WindowManagerGlobal.java
public static IWindowSession getWindowSession() {
    synchronized (WindowManagerGlobal.class) {
        if (sWindowSession == null) {
            try {
                IWindowManager windowManager = getWindowManagerService();
                sWindowSession = windowManager.openSession(
                        new IWindowSessionCallback.Stub() {
                            @Override
                            public void onAnimatorScaleChanged(float scale) {
                                ValueAnimator.setDurationScale(scale);
                            }
                        });
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        return sWindowSession;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ViewRootImpl 是 View视图 与 WindowManager 的纽带，mIWindowSession、mWindow 为 Binder 对象，用于 APP 端与 WMS 之间的相互通信。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/win_binder.png&quot; alt=&quot;win_binder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里通过 IWindowSession.addToDisplayAsUser(..) 接口，请求WMS添加新窗口。&lt;/p&gt;

&lt;p&gt;此外，ViewRootImpl 管理整个 View 视图的绘制和 Input 事件分发。&lt;/p&gt;

&lt;h1 id=&quot;4wms添加窗口&quot;&gt;4.WMS添加窗口&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(Session session, IWindow client, LayoutParams attrs, ..) {
    WindowState parentWindow = null;
    final int type = attrs.type;
    synchronized (mGlobalLock) {
        final DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token);
        
        if (type &amp;gt;= FIRST_SUB_WINDOW &amp;amp;&amp;amp; type &amp;lt;= LAST_SUB_WINDOW) {
            parentWindow = windowForClientLocked(null, attrs.token, false);
            ...
        }

        ActivityRecord activity = null;
        final boolean hasParent = parentWindow != null;
        WindowToken token = displayContent.getWindowToken(
                hasParent ? parentWindow.mAttrs.token : attrs.token);
        final int rootType = hasParent ? parentWindow.mAttrs.type : type;

        if (token == null) {
            ...
        } else if (rootType &amp;gt;= FIRST_APPLICATION_WINDOW
                &amp;amp;&amp;amp; rootType &amp;lt;= LAST_APPLICATION_WINDOW) {
            activity = token.asActivityRecord();
            ...
        } else if (rootType == TYPE_INPUT_METHOD) {
            ...
        } else if (rootType == TYPE_VOICE_INTERACTION) {
            ...
        } else if (rootType == TYPE_WALLPAPER) {
            ...
        } else if (rootType == TYPE_ACCESSIBILITY_OVERLAY) {
            ...
        } else if (type == TYPE_TOAST) {
            ...
        } else if (type == TYPE_QS_DIALOG) {
            ...
        } else if (token.asActivityRecord() != null) {
            ...
        }

        final WindowState win = new WindowState(this, session, client, token, parentWindow,
                appOp[0], attrs, viewVisibility, session.mUid, userId,
                session.mCanAddInternalSystemWindow);
        win.attach();
        mWindowMap.put(client.asBinder(), win);
        win.mToken.addWindow(win);

        if (type == TYPE_APPLICATION_STARTING &amp;amp;&amp;amp; activity != null) {
            activity.attachStartingWindow(win);
        } else if (type == TYPE_INPUT_METHOD
            ...
        } else if (type == TYPE_INPUT_METHOD_DIALOG) {
            ...
        } else {
            ...
        }
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;41-创建windowstate&quot;&gt;4.1 创建WindowState&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    WindowToken token = displayContent.getWindowToken(
            hasParent ? parentWindow.mAttrs.token : attrs.token);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里传入的 token 是在创建 ActivityRecord 时创建的 Binder 对象（见上文2），获取到的 WindowToken 为 ActivityRecord 对象。&lt;/p&gt;

&lt;p&gt;WMS每一个新窗口都会对应创建一个 WindowState 对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    final WindowState win = new WindowState(this, session, client, token, parentWindow,
            appOp[0], attrs, viewVisibility, session.mUid, userId,
            session.mCanAddInternalSystemWindow);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以 Activity 页面弹出一个Dialog对话框为例，WindowToken 与 WindowState 的关系为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/win_token.png&quot; alt=&quot;win_token&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;42-创建surfacesession&quot;&gt;4.2 创建SurfaceSession&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    synchronized (mGlobalLock) {
        ...
        final WindowState win = new WindowState(...);
        win.attach();
        ...
    }
    return res;
}

// WindowState.java
void attach() {
    mSession.windowAddedLocked();
}

// Session.java
void windowAddedLocked() {
    ...
    if (mSurfaceSession == null) {
        mSurfaceSession = new SurfaceSession();
        ...
    }
}

// SurfaceSession.java
/** Create a new connection with the surface flinger. */
@UnsupportedAppUsage
public SurfaceSession() {
    mNativeClient = nativeCreate();
}

// android_view_SurfaceSession.cpp
static jlong nativeCreate(JNIEnv* env, jclass clazz) {
    SurfaceComposerClient* client = new SurfaceComposerClient();
    client-&amp;gt;incStrong((void*)nativeCreate);
    return reinterpret_cast&amp;lt;jlong&amp;gt;(client);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SurfaceSession 构造方法中通过 nativeCreate() 方法返回了一个 SurfaceComposerClient 指针，它表示一个跟 SurfaceFlinger 的连接，当其第一次被使用时会调用 onFirstRef() 方法，创建一个实现 ISurfaceComposerClient 接口的 Client 对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// SurfaceComposerClient.cpp
void SurfaceComposerClient::onFirstRef() {
    sp&amp;lt;ISurfaceComposer&amp;gt; sf(ComposerService::getComposerService());
    if (sf != nullptr &amp;amp;&amp;amp; mStatus == NO_INIT) {
        sp&amp;lt;ISurfaceComposerClient&amp;gt; conn;
        conn = sf-&amp;gt;createConnection();
        if (conn != nullptr) {
            mClient = conn;
            mStatus = NO_ERROR;
        }
    }
}

// SurfaceFlinger.cpp
sp&amp;lt;ISurfaceComposerClient&amp;gt; SurfaceFlinger::createConnection() {
    const sp&amp;lt;Client&amp;gt; client = new Client(this);
    return client-&amp;gt;initCheck() == NO_ERROR ? client : nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WMS 创建了一个 WindowState 对象表示客户端的一个 Window，接着调用 WindowState.attach() 方法创建了一个 SurfaceSession 对象，SurfaceSession 表示一个跟 SurfaceFlinger 的连接，它创建了一个 SurfaceComposerClient 对象，然后 SurfaceFlinger 又创建了一个 Client 对象。&lt;/p&gt;

&lt;h2 id=&quot;43-windowstate添加到activityrecord&quot;&gt;4.3 WindowState添加到ActivityRecord&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
public int addWindow(...) {
    ...
    final WindowState win = new WindowState(.., token, ..);
    ...
    win.mToken.addWindow(win);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;5应用绘制&quot;&gt;5.应用绘制&lt;/h1&gt;

&lt;h2 id=&quot;51-创建surface&quot;&gt;5.1 创建Surface&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ViewRootImpl.java
public final Surface mSurface = new Surface();
private final SurfaceControl mSurfaceControl = new SurfaceControl();
private BLASTBufferQueue mBlastBufferQueue;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建 ViewRootImp 实例时，会创建一个空的 Surface 和 SurfaceControl 对象，其初始化流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ViewRootImpl$TraversalRunnable.run(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.doTraversal(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.performTraversals(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.relayoutWindow(..)&lt;/li&gt;
  &lt;li&gt;Session.relayout(.., mSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowManagerService.relayoutWindow(.., outSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowManagerService.createSurfaceControl(outSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;WindowStateAnimator.createSurfaceLocked()&lt;/li&gt;
  &lt;li&gt;new WindowSurfaceController(..)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.Builder.build()&lt;/li&gt;
  &lt;li&gt;new SurfaceControl(..)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.nativeCreate(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// android_view_SurfaceControl.cpp
static jlong nativeCreate(..) {
    sp&amp;lt;SurfaceComposerClient&amp;gt; client;
    if (sessionObj != NULL) {
        client = android_view_SurfaceSession_getClient(env, sessionObj);
    } else {
        client = SurfaceComposerClient::getDefault();
    }

    sp&amp;lt;SurfaceControl&amp;gt; surface;
    status_t err = client-&amp;gt;createSurfaceChecked(String8(name.c_str()), w, h, format, &amp;amp;surface,
                                                flags, parentHandle, std::move(metadata));
    surface-&amp;gt;incStrong((void *)nativeCreate);
    return reinterpret_cast&amp;lt;jlong&amp;gt;(surface.get());
}

// SurfaceComposerClient.cpp 
status_t SurfaceComposerClient::createSurfaceChecked(..) {
    status_t err = mStatus;

    if (mStatus == NO_ERROR) {
        sp&amp;lt;IBinder&amp;gt; handle;
        sp&amp;lt;IGraphicBufferProducer&amp;gt; gbp;

        err = mClient-&amp;gt;createSurface(name, w, h, format, flags, parentHandle, std::move(metadata),
                                     &amp;amp;handle, &amp;amp;gbp, &amp;amp;id, &amp;amp;transformHint);

        if (err == NO_ERROR) {
            *outSurface =
                    new SurfaceControl(this, handle, gbp, id, w, h, format, transformHint, flags);
        }
    }
    return err;
}

// surfaceflinger/Client.cpp
status_t Client::createSurface(..) {
    LayerCreationArgs args(mFlinger.get(), this, name.c_str(), flags, std::move(metadata));
    return mFlinger-&amp;gt;createLayer(args, outHandle, parentHandle, outLayerId, nullptr,
                                 outTransformHint);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;WindowSurfaceController.getSurfaceControl(outSurfaceControl)&lt;/li&gt;
  &lt;li&gt;SurfaceControl.copyFrom(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;outSurfaceControl.copyFrom(mSurfaceControl, &quot;WindowSurfaceController.getSurfaceControl&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;SurfaceControl.nativeCopyFromSurfaceControl(..)&lt;/li&gt;
  &lt;li&gt;ViewRootImpl.updateBlastSurfaceIfNeeded()&lt;/li&gt;
  &lt;li&gt;new BLASTBufferQueue(mTag, mSurfaceControl, ..)&lt;/li&gt;
  &lt;li&gt;BLASTBufferQueue.createSurface()&lt;/li&gt;
  &lt;li&gt;BLASTBufferQueue.nativeGetSurface(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// android_graphics_BLASTBufferQueue.cpp
static jobject nativeGetSurface(JNIEnv* env, jclass clazz, jlong ptr,
                                jboolean includeSurfaceControlHandle) {
    sp&amp;lt;BLASTBufferQueue&amp;gt; queue = reinterpret_cast&amp;lt;BLASTBufferQueue*&amp;gt;(ptr);
    return android_view_Surface_createFromSurface(env,
                                                  queue-&amp;gt;getSurface(includeSurfaceControlHandle));
}

// BLASTBufferQueue.cpp
sp&amp;lt;Surface&amp;gt; BLASTBufferQueue::getSurface(bool includeSurfaceControlHandle) {
    std::unique_lock _lock{mMutex};
    sp&amp;lt;IBinder&amp;gt; scHandle = nullptr;
    if (includeSurfaceControlHandle &amp;amp;&amp;amp; mSurfaceControl) {
        scHandle = mSurfaceControl-&amp;gt;getHandle();
    }
    return new BBQSurface(mProducer, true, scHandle, this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;Surface.transferFrom(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;mSurface.transferFrom(blastSurface);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;Surface.setNativeObjectLocked(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 Java 层中 ViewRootImpl 实例中持有一个 Surface 对象，该 Surface 对象中的 mNativeObject 属性指向 native 层中创建的 Surface 对象，native 层的 Surface 对应 SurfaceFlinger 中的 Layer 对象，它持有 Layer 中的 BufferQueueProducer 生产者指针，在 Surface 上绘制的内容最终会交由 SurfaceFlinger 来合成渲染送到显示器显示。&lt;/p&gt;

&lt;h2 id=&quot;52-view绘制构建阶段&quot;&gt;5.2 View绘制：构建阶段&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw1.png&quot; alt=&quot;view_draw1&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Choreographer.java

private final class FrameDisplayEventReceiver extends DisplayEventReceiver
        implements Runnable {

    @Override
    public void onVsync(..) {
        try {
            ...
            Message msg = Message.obtain(mHandler, this);
            msg.setAsynchronous(true);
            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
        } finally {
        }
    }

    @Override
    public void run() {
        doFrame(mTimestampNanos, mFrame, mLastVsyncEventData);
    }
}

void doFrame(..) {
    try {
        ...
        doCallbacks(Choreographer.CALLBACK_INPUT, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameData, frameIntervalNanos);
    } finally {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Choreographer中收到Vsync信号后，向主线程MessageQueue发送一条异步Message，当异步Message执行后会调用其doFrame(..)方法，依次执行 INPUT、ANIMATION、INSETS_ANIMATION、TRAVERSAL、COMMIT 回调。&lt;/p&gt;

&lt;p&gt;在 TRAVERSAL 回调中会执行 mTraversalRunnable ，其 run() 方法中调用 doTraversal() 方法，执行 performTraversals() 方法，接着依次执行 View 的 measure、layout、draw 流程的代码。&lt;/p&gt;

&lt;h2 id=&quot;53-view绘制渲染阶段&quot;&gt;5.3 View绘制：渲染阶段&lt;/h2&gt;

&lt;p&gt;RenderThread线程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw2.png&quot; alt=&quot;view_draw2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;渲染方式：软件绘制（CPU） VS 硬件绘制（GPU）&lt;/p&gt;

&lt;p&gt;渲染引擎：OpenGL VS Vulkan&lt;/p&gt;

&lt;h2 id=&quot;54-surfaceflinger合成显示&quot;&gt;5.4 SurfaceFlinger：合成显示&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/view_draw3.png&quot; alt=&quot;view_draw3&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;6小结&quot;&gt;6.小结&lt;/h1&gt;

&lt;p&gt;应用侧 Window 是一个抽象概念，用来描述顶层视图的外观和行为，唯一的实现类是 PhoneWindow。&lt;/p&gt;

&lt;p&gt;在创建 Activity / Dialog 时，会创建 PhoneWindow ，同时会创建 DecorView 。&lt;/p&gt;

&lt;p&gt;应用侧向WMS请求添加视图时，会创建ViewRootImpl，同时会创建 Surface，视图绘制的数据会写入  Surface，由 SurfaceFlinger 合成显示。&lt;/p&gt;

&lt;p&gt;WMS添加应用侧视图时会创建 WindowState 用来对应一个 Window，同时维护 Window 的 Z-Order 。&lt;/p&gt;

&lt;h1 id=&quot;7参考文档&quot;&gt;7.参考文档&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.simowce.com/all-about-blastbbq/&quot;&gt;BLASTBufferQueue 详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/50a30fa6952e&quot;&gt;BBQ 机制介绍&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/cdc60627df90&quot;&gt;BBQ 原理解读&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/384a5cd2e304&quot;&gt;BBQ 运用场景&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/19/Activity%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/19/Activity%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>Activity</category>
        
        
      </item>
    
      <item>
        <title>Activity启动流程</title>
        <description>&lt;h1 id=&quot;1activity官方文档&quot;&gt;1.Activity官方文档&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/components/activities/intro-activities?hl=zh-cn&quot;&gt;Activity 简介&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle?hl=zh-cn&quot;&gt;Activity 生命周期&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/guide/topics/manifest/activity-element?hl=zh-cn&quot;&gt;应用清单&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;2activity启动流程&quot;&gt;2.Activity启动流程&lt;/h1&gt;

&lt;p&gt;在桌面点击时钟图标打开闹钟应用，使用系统跟踪抓取 trace 文件，在 &lt;a href=&quot;https://ui.perfetto.dev/&quot;&gt;perfetto&lt;/a&gt; 打开查看：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/startActivity.perfetto-trace&quot;&gt;startActivity.perfetto-trace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_start.png&quot; alt=&quot;act_start&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了让整个过程可视化，对系统侧相关类做了代码插桩，在进入/退出方法处加上Trace日志：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/startActivityinjected.perfetto-trace&quot;&gt;startActivityinjected.perfetto-trace&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在此基础上需要掌握调试安卓Framework源码 ，再结合trace来学习源码。&lt;/p&gt;

&lt;h2 id=&quot;21-点击应用图标&quot;&gt;2.1 点击应用图标&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;InputReader 负责从 EventHub 里面把 Input 事件读取出来，然后交给 InputDispatcher 进行事件分发。&lt;/li&gt;
  &lt;li&gt;InputDispatcher 在拿到 InputReader 获取的事件后对 Input 事件进行包装，然后寻找并分发到目标窗口。&lt;/li&gt;
  &lt;li&gt;InboundQueue（iq）队列中放着 InputDispatcher 从 InputReader 中拿到的 Input 事件。&lt;/li&gt;
  &lt;li&gt;OutboundQueue（oq）队列里面放的是即将要被派发给各个目标窗口的 Input 事件。&lt;/li&gt;
  &lt;li&gt;WaitQueue（wq）队列里面记录的是已经派发给目标窗口等待其处理完的 Input 事件。&lt;/li&gt;
  &lt;li&gt;PendingInputEventQueue（aq）队列中记录的是应用需要处理的 Input 事件。&lt;/li&gt;
  &lt;li&gt;deliverInputEvent 标识 App UI Thread 被 Input 事件唤醒。&lt;/li&gt;
  &lt;li&gt;App 响应处理 Input 事件，内部会在其界面 View 树中传递处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;22-启动闹钟应用&quot;&gt;2.2 启动闹钟应用&lt;/h2&gt;

&lt;h3 id=&quot;221-桌面请求启动闹钟应用&quot;&gt;2.2.1 桌面请求启动闹钟应用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Activity.startActivityForResult(..)&lt;/li&gt;
  &lt;li&gt;Instrumentation.execStartActivity(..)&lt;/li&gt;
  &lt;li&gt;ActivityTaskManager.&lt;em&gt;getService&lt;/em&gt;().startActivity(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private static final Singleton&amp;lt;IActivityTaskManager&amp;gt; IActivityTaskManagerSingleton =
        new Singleton&amp;lt;IActivityTaskManager&amp;gt;() {
            @Override
            protected IActivityTaskManager create() {
                final IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);
                return IActivityTaskManager.Stub.asInterface(b);
            }
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;222-系统侧处理请求&quot;&gt;2.2.2 系统侧处理请求&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/atms_start_act.png&quot; alt=&quot;atms_start_act&quot; /&gt;&lt;/p&gt;

&lt;p&gt;核心逻辑从ActivityStarter.execute()方法开始：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. ActivityStarter$Request.resolveActivity(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;解析 ResolveInfo 和 ActivityInfo，最终调用到 ComputerEngine.queryIntentActivitiesInternal(..)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/resolve_act.png&quot; alt=&quot;resolve_act&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有个细节是处理 显式启动 与 隐式启动 的区别：&lt;a href=&quot;https://developer.android.com/guide/components/intents-filters?hl=zh-cn&quot;&gt;Intent 和 Intent 过滤器&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;queryIntentActivitiesInternal(..) {
    ComponentName comp = intent.getComponent();
    if (comp != null) {
        getActivityInfo(..)
    } else {
        queryIntentActivitiesInternalBody(..)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. ActivityStarter.executeRequest()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.1 权限检查&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.1 启动权限检查：ActivityTaskSupervisor.checkStartAnyActivityPermission(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;应用AndroidManifest.xml配置项：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;android:exported&lt;/th&gt;
      &lt;th&gt;activity 是否可由其他应用的组件启动。&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;android:permission&lt;/td&gt;
      &lt;td&gt;启动 activity 或以其他方式使 activity 响应 intent 时，客户端必须具备的权限的名称。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;2.1.2 允许后台启动检查：ActivityStarter.shouldAbortBackgroundActivityStart(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;详见 &lt;a href=&quot;https://developer.android.com/guide/components/activities/background-starts?hl=zh-cn&quot;&gt;从后台启动 Activity 的限制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.2 创建ActivityRecord&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Activity 的实例是在应用侧创建的，系统侧会创建 ActivityRecord 与之对应，用来存储 Activity 的相关信息。&lt;/p&gt;

&lt;p&gt;相关文档：&lt;a href=&quot;http://gityuan.com/2017/06/11/activity_record/&quot;&gt;四大组件之ActivityRecord&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.3 ActivityStarter#startActivityUnchecked&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.1 ActivityTaskManagerService.deferWindowLayout(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;延迟当前进行的布局，因为页面即将要刷新，继续进行布局没有意义，与 continueWindowLayout() 成对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.2 ActivityStarter.startActivityInner(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这部分的核心逻辑围绕 &lt;a href=&quot;https://developer.android.com/guide/components/activities/tasks-and-back-stack?hl=zh-cn&quot;&gt;任务和返回堆栈 &lt;/a&gt;内容展开：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Task（任务）是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Task（任务）是一个整体单元，当用户开始一个新任务或通过主屏幕按钮进入主屏幕时，任务可移至“后台”。“后台”任务可重新返回到“前台”，以便用户可以从他们离开的地方继续操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了更直观地理解这部分内容，写了一个示例应用：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/activityLaunchMode.apk&quot;&gt;activityLaunchMode.apk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.ActivityStarter#setInitialState&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act1.png&quot; alt=&quot;act1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.ActivityStarter#computeLaunchingTaskFlags&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act2.png&quot; alt=&quot;act2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要判断是否添加 &lt;a href=&quot;https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_NEW_TASK&quot;&gt;FLAG_ACTIVITY_NEW_TASK&lt;/a&gt; 属性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.计算4个task&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Get top task at beginning because the order may be changed when reusing existing task.
final Task prevTopRootTask = mPreferredTaskDisplayArea.getFocusedRootTask();
final Task prevTopTask = prevTopRootTask != null ? prevTopRootTask.getTopLeafTask() : null;
final Task reusedTask = getReusableTask();
final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act3.png&quot; alt=&quot;act3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要逻辑是查找是否存在Activity可复用的Task。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.ActivityStarter#isAllowedToStart&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act4.png&quot; alt=&quot;act4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于 targetTask 再次判断 Activity 是否允许启动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.ActivityStarter#recycleTask&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final boolean newTask = targetTask == null;
final ActivityRecord targetTaskTop = newTask
        ? null : targetTask.getTopNonFinishingActivity();
if (targetTaskTop != null) {
    recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);
} else {
    mAddingToTask = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复用targetTask，从桌面点击应用图标启动应用，targetTask 为 null，不会走 recycleTask() 逻辑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.ActivityStarter#getOrCreateRootTask&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act5.png&quot; alt=&quot;act5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里会创建 RootTask（截图中选中位置）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.ActivityStarter#setNewTask&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (newTask) {
    final Task taskToAffiliate = (mLaunchTaskBehind &amp;amp;&amp;amp; mSourceRecord != null)
            ? mSourceRecord.getTask() : null;
    setNewTask(taskToAffiliate);
} else if (mAddingToTask) {
    addOrReparentStartingActivity(targetTask, &quot;adding to task&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act6.png&quot; alt=&quot;act6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;调用 Task.reuseOrCreateTask(..) 复用或者创建 Task（截图中选中位置），这里会复用刚才创建的 RootTask。&lt;/p&gt;

&lt;p&gt;这里还有一个逻辑是 ActivityStarter#addOrReparentStartingActivity ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (mStartActivity.getTaskFragment() == null
        || mStartActivity.getTaskFragment() == newParent) {
    newParent.addChild(mStartActivity, POSITION_TOP);
} else {
    mStartActivity.reparent(newParent, newParent.getChildCount() /* top */, reason);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mStartActivity 是 ActivityRecord，newParent 是 Task，将ActivityRecord添加到Task中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.Task#moveToFront&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act7.png&quot; alt=&quot;act7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里是将 mTargetRootTask 移至“前台”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.Task#startActivityLocked&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act8.png&quot; alt=&quot;act8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有个应用启动优化项：StartingWindow。&lt;/p&gt;

&lt;p&gt;相关介绍文档：&lt;a href=&quot;https://androidperformance.com/2018/05/20/zhihu-startingwindow/#/StartingWindow-对用户体验的影响&quot;&gt;知乎 救救你的 StartingWindow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10.RootWindowContainer#resumeFocusedTasksTopActivities&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act9.png&quot; alt=&quot;act9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前面已经把 mTargetRootTask 移至“前台”，这里是把 mStartActivity 移至“前台”，主要逻辑在TaskFragment#resumeTopActivity。&lt;/p&gt;

&lt;p&gt;在目标 Activity 显示出来之前，需要把 RootTask 中其他 Activities 暂停：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act10.png&quot; alt=&quot;act10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终会调用到 TaskFragment#schedulePauseActivity （截图中选中位置）通知桌面暂停Launcher，详见 2.2.3。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;void schedulePauseActivity(..) {
    mAtmService.getLifecycleManager().scheduleTransaction(prev.app.getThread(),
            prev.token, PauseActivityItem.obtain(..));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来会判断应用进程是否存在，如果不存在先创建应用进程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;boolean pausing = !deferPause &amp;amp;&amp;amp; taskDisplayArea.pauseBackTasks(next);
if (pausing) {
    if (next.attachedToProcess()) {
        //应用进程存在
        next.app.updateProcessInfo(..);
    } else if (!next.isProcessRunning()) {
        //应用进程不存在，创建进程
        mAtmService.startProcessAsync(..);
    }
} else if (mResumedActivity == next &amp;amp;&amp;amp; next.isState(RESUMED)
        &amp;amp;&amp;amp; taskDisplayArea.allResumedActivitiesComplete()) {
    //执行过渡动画
    executeAppTransition(options);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里闹钟进程不存在，会请求 Zygote 创建闹钟进程，详见 2.3。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.3 ActivityTaskManagerService.continueWindowLayout(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与上文 deferWindowLayout(..) 成对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.4 ActivityStarter.postStartActivityProcessing(..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ActivityStartInterceptor 回调监听者 onActivityLaunched(..)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (ActivityManager.isStartResultSuccessful(result)) {
    mInterceptor.onActivityLaunched(targetTask.getTaskInfo(), r);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;223-桌面activitypause&quot;&gt;2.2.3 桌面activityPause&lt;/h3&gt;

&lt;p&gt;桌面收到系统侧 activityPause 通知，处理完后再通知系统侧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_pause1.png&quot; alt=&quot;act_pause1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统侧收到桌面 activityPause 通知：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_pause2.png&quot; alt=&quot;act_pause2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;startSpecificActivity(..) 有多个入口，当应用进程创建完执行 attachApplication 后，才会执行 realStartActivityLocked(..)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final WindowProcessController wpc = mService.getProcessController(..);
if (wpc != null &amp;amp;&amp;amp; wpc.hasThread()) {
    realStartActivityLocked(r, wpc, andResume, checkConfig);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 realStartActivityLocked(..) 中会通知应用侧执行 Activity 生命周期回调，详见 2.5：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;final ClientTransaction clientTransaction = ClientTransaction.obtain(..);
clientTransaction.addCallback(LaunchActivityItem.obtain(..));
clientTransaction.setLifecycleStateRequest(ResumeActivityItem.obtain(..));
mService.getLifecycleManager().scheduleTransaction(clientTransaction);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;224-桌面activitystop&quot;&gt;2.2.4 桌面activityStop&lt;/h3&gt;

&lt;p&gt;上接 2.2.3，在显示出 Activity 前会执行 AppTransition 过渡动画：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_stop1.png&quot; alt=&quot;act_stop1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过渡动画执行完后，会通知桌面执行activityStop：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_stop2.png&quot; alt=&quot;act_stop2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结下两个应用 Activity 生命周期：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;桌面 Launcher 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onPause()&lt;/code&gt; 方法执行。&lt;/li&gt;
  &lt;li&gt;闹钟 DeskClockTabActivity 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStart()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onResume()&lt;/code&gt; 方法依次执行（闹钟 DeskClockTabActivity 现在具有用户焦点）。&lt;/li&gt;
  &lt;li&gt;桌面 Launcher 在屏幕上不再显示，其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStop()&lt;/code&gt; 方法执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;23-创建闹钟进程&quot;&gt;2.3 创建闹钟进程&lt;/h2&gt;

&lt;h3 id=&quot;231-系统侧请求创建闹钟进程&quot;&gt;2.3.1 系统侧请求创建闹钟进程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityManagerService.startProcess(..)&lt;/li&gt;
  &lt;li&gt;ActivityManagerService.startProcessLocked(..)&lt;/li&gt;
  &lt;li&gt;ProcessList.startProcessLocked(..)&lt;/li&gt;
  &lt;li&gt;ProcessList.startProcess(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;if (hostingRecord.usesWebviewZygote()) {
    WebViewZygote.getProcess().start(..)
} else if (hostingRecord.usesAppZygote()) {
    // see FLAG_USE_APP_ZYGOTE
    appZygote.getProcess().start(..)
} else {
    Process.start(..);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;ZYGOTE_PROCESS.start(..)&lt;/li&gt;
  &lt;li&gt;ZYGOTE_PROCESS.startViaZygote(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;static ZygoteState connect(@NonNull LocalSocketAddress zygoteSocketAddress,
        @Nullable LocalSocketAddress usapSocketAddress)
        throws IOException {

    final LocalSocket zygoteSessionSocket = new LocalSocket();

    try {
        zygoteSessionSocket.connect(zygoteSocketAddress);
    } catch (IOException ex) {
    }
    
    return new ZygoteState(..)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;ZYGOTE_PROCESS.zygoteSendArgsAndGetResult(..)&lt;/li&gt;
  &lt;li&gt;ZYGOTE_PROCESS.attemptZygoteSendArgsAndGetResult(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;private Process.ProcessStartResult attemptZygoteSendArgsAndGetResult(
        ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx {
    try {
        final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;
        final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;

        zygoteWriter.write(msgStr);
        zygoteWriter.flush();

        // Always read the entire result from the input stream to avoid leaving
        // bytes in the stream for future process starts to accidentally stumble
        // upon.
        Process.ProcessStartResult result = new Process.ProcessStartResult();
        result.pid = zygoteInputStream.readInt();
        result.usingWrapper = zygoteInputStream.readBoolean();

        if (result.pid &amp;lt; 0) {
            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);
        }

        return result;
    } catch (IOException ex) {
        zygoteState.close();
        throw new ZygoteStartFailedEx(ex);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Q：这里为什么不采用Binder进行通信？&lt;/p&gt;

&lt;p&gt;A：fork机制限制，仅支持单线程，而binder会创建多线程。&lt;/p&gt;

&lt;h3 id=&quot;232-zygote创建闹钟进程&quot;&gt;2.3.2 Zygote创建闹钟进程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ZygoteServer.runSelectLoop(..)&lt;/li&gt;
  &lt;li&gt;ZygoteConnection.processCommand(..)&lt;/li&gt;
  &lt;li&gt;Zygote.forkAndSpecialize(..)&lt;/li&gt;
  &lt;li&gt;Zygote.nativeForkAndSpecialize(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;int pid = Zygote.forkAndSpecialize(..);
if (pid == 0) {
    // in child
    handleChildProc(..);
} else {
    // In the parent
    handleParentProc(..);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;24-闹钟主线程初始化&quot;&gt;2.4 闹钟主线程初始化&lt;/h2&gt;

&lt;h3 id=&quot;241-闹钟向系统侧请求attachapplication&quot;&gt;2.4.1 闹钟向系统侧请求attachApplication&lt;/h3&gt;

&lt;p&gt;闹钟进程创建完成后初始化，上接 2.3.2：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Zygote.handleChildProc(..)&lt;/li&gt;
  &lt;li&gt;ZygoteInit.zygoteInit(..)&lt;/li&gt;
  &lt;li&gt;RuntimeInit.applicationInit(..)&lt;/li&gt;
  &lt;li&gt;RuntimeInit.findStaticMain(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.main(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.attach(..)&lt;/li&gt;
  &lt;li&gt;ActivityManagerService.attachApplication(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/application1.png&quot; alt=&quot;application1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统侧收到闹钟 attachApplication 通知，上接 2.2.3，在此之后才会真正启动Activity：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/application2.png&quot; alt=&quot;application2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外，Looper 也是在 ActivityThread.main(..) 中初始化的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;Looper.prepareMainLooper();
Looper.loop();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;242-闹钟处理系统侧bindapplication请求&quot;&gt;2.4.2 闹钟处理系统侧bindApplication请求&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityThread$ApplicationThread.bindApplication(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.sendMessage(H.BIND_APPLICATION, data) // 第一条消息&lt;/li&gt;
  &lt;li&gt;ActivityThread.handleBindApplication(data)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
private void handleBindApplication(AppBindData data) {
    ...
    // JVMTI
    if (agent != null) {
        handleAttachAgent(agent, data.info);
    }

    // 1.创建ContextImpl
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);

    // 2.创建Instrumentation
    if (ii != null) {
        initInstrumentation(ii, data, appContext);
    } else {
        mInstrumentation = new Instrumentation();
        mInstrumentation.basicInit(this);
    }

    try {
        // 3.创建 Application
        app = data.info.makeApplicationInner(data.restrictedBackupMode, null);
        ...
        if (!data.restrictedBackupMode) {
            if (!ArrayUtils.isEmpty(data.providers)) {
                // 初始化ContentProvider
                installContentProviders(app, data.providers);
            }
        }
        ...
        try {
            // call Instrumentation.onCreate()
            mInstrumentation.onCreate(data.instrumentationArgs);
        }
        catch (Exception e) {
        }
        ...
        try {
            // call Application.onCreate()
            mInstrumentation.callApplicationOnCreate(app);
        } catch (Exception e) {
        }
    } finally {
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;25-闹钟activity生命周期&quot;&gt;2.5 闹钟Activity生命周期&lt;/h2&gt;

&lt;p&gt;上接 2.2.3，实例化Activity：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityThread$ApplicationThread.scheduleTransaction(..)&lt;/li&gt;
  &lt;li&gt;ClientTransactionHandler.scheduleTransaction(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread$H.handleMessage(..)&lt;/li&gt;
  &lt;li&gt;TransactionExecutor.execute(..)&lt;/li&gt;
  &lt;li&gt;LaunchActivityItem.execute(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.handleLaunchActivity(..)&lt;/li&gt;
  &lt;li&gt;ActivityThread.performLaunchActivity(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;try {
    java.lang.ClassLoader cl = appContext.getClassLoader();
    activity = mInstrumentation.newActivity(
            cl, component.getClassName(), r.intent);
} catch (Exception e) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activity创建后依次执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onStart()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onResume()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_lifecycle.png&quot; alt=&quot;act_lifecycle&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;26-activity绘制及显示到屏幕&quot;&gt;2.6 Activity绘制及显示到屏幕&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_draw1.png&quot; alt=&quot;act_draw1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在VSYNC-app周期内：SurfaceFlinger的app线程唤醒home主线程，接下来执行Choreographer的doFrame流程，包括input，animation，traversal阶段，在traversal中执行draw绘制并将绘制的内容同步给RenderThread线程。RenderThread线程先从buffer队列中dequeueBuffer申请一个buffer，填充内容，然后queueBuffer将buffer加入队列，并通知SurfaceFlinger。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Activity/act_draw2.png&quot; alt=&quot;act_draw2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在VSYNC-sf周期内：处理MessageQueue::INVALIDATE消息，从各Layer的BufferQueue拿到最新的缓冲数据，并根据内容更新脏区域；处理MessageQueue::REFRESH消息，通过HWC合成各Layer的buffer，发送至显示设备进行显示。&lt;/p&gt;

&lt;h1 id=&quot;3-小结&quot;&gt;3. 小结&lt;/h1&gt;

&lt;p&gt;本文以在桌面点击图标启动闹钟应用为例，结合trace简单介绍了Activity启动流程中的关键细节，主要包括：Framework侧处理Activity启动请求、任务和返回栈、Activity生命周期、应用进程创建及初始化及绘制流程等。&lt;/p&gt;

&lt;p&gt;可延伸的知识点包括：Context、Window、View事件分发、View绘制流程、Handler机制、Binder机制、类加载机制、fork机制、ServiceManager、SurfaceFlinger、代码插桩、插件化等。&lt;/p&gt;

&lt;h1 id=&quot;4-参考文档&quot;&gt;4. 参考文档：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/37370c1d17fc&quot;&gt;Android应用启动全流程分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/cf531a3af828&quot;&gt;Android卡顿掉帧问题分析之工具篇&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jan 2023 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/01/09/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>Activity</category>
        
        
      </item>
    
      <item>
        <title>DisplayArea树层级结构</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/class_hierarchy.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;RootWindowContainer：最顶层的管理者，直接管理 DisplayContent 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DisplayContent：对应一个真实或者虚拟的显示设备。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TaskDisplayArea：是系统中所有应用任务的父节点，用于管理 Task 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Task：代表一个任务，可以包含多个 Activity 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ActivityRecord：对应一个 Activity 节点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;WindowState：对应一个窗口。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1window相关概念&quot;&gt;1.Window相关概念&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Window Type主要分为三大类：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Application windows（应用窗口）: 1~99&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sub-windows（子窗口）: 1000~1999&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;System windows（系统窗口）: 2000~2999&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Window Layer分为36层：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;default int getMaxWindowLayer() {
    return 36;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Z-Order计算：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;mBaseLayer = WindowLayer * 10000 + 1000;
mSubLayer = SubWindowLayer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Window Type与Window Layer对应关系如下：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Window Type&lt;/th&gt;
      &lt;th&gt;VALUE&lt;/th&gt;
      &lt;th&gt;Window Layer&lt;/th&gt;
      &lt;th&gt;Leaf Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BASE_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;APPLICATION_LAYER = 2&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;LEAF_TYPE_TASK_CONTAINERS = 1&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_STARTING&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DRAWN_APPLICATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;LAST_APPLICATION_WINDOW&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;99&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1000&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_MEDIA&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1001&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;-2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_SUB_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1002&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_ATTACHED_DIALOG&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1003&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_MEDIA_OVERLAY&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1004&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;&lt;em&gt;TYPE_APPLICATION_ABOVE_SUB_PANEL&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1005&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SEARCH_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2001&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PHONE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2002&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_ALERT&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2003&lt;/td&gt;
      &lt;td&gt;12|9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_KEYGUARD&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2004&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_TOAST&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2005&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2006&lt;/td&gt;
      &lt;td&gt;23|20&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRIORITY_PHONE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2007&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2008&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_KEYGUARD_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2009&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SYSTEM_ERROR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2010&lt;/td&gt;
      &lt;td&gt;27|9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_METHOD&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2011&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;LEAF_TYPE_IME_CONTAINERS = 2&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_METHOD_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2012&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_WALLPAPER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2013&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2014&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SECURE_SYSTEM_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2015&lt;/td&gt;
      &lt;td&gt;33&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DRAG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2016&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_SUB_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2017&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_POINTER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2018&lt;/td&gt;
      &lt;td&gt;35&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NAVIGATION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2019&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOLUME_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2020&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BOOT_PROGRESS&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2021&lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_INPUT_CONSUMER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2022&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NAVIGATION_BAR_PANEL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2024&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DISPLAY_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2026&lt;/td&gt;
      &lt;td&gt;29&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_MAGNIFICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2027&lt;/td&gt;
      &lt;td&gt;28&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRIVATE_PRESENTATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2030&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOICE_INTERACTION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2031&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_ACCESSIBILITY_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2032&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_VOICE_INTERACTION_STARTING&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2033&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_DOCK_DIVIDER&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2034&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_QS_DIALOG&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2035&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_SCREENSHOT&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2036&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_PRESENTATION&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2037&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2038&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2039&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_NOTIFICATION_SHADE&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2040&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_STATUS_BAR_ADDITIONAL&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2041&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;TYPE_CARWITH_NAVIGATION_BAR&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2998&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;常见Window及Window Type：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Window&lt;/th&gt;
      &lt;th&gt;Window Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Activity&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_BASE_APPLICATION&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TaskSnapshotWindow&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_STARTING&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Dialog&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PopupWindow&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_APPLICATION_PANEL&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Toast&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;TYPE_TOAST&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;2为什么要构建displayarea树&quot;&gt;2.为什么要构建DisplayArea树？&lt;/h1&gt;

&lt;h2 id=&quot;21-需求分析&quot;&gt;2.1 需求分析&lt;/h2&gt;

&lt;p&gt;手机系统有N个类型的Window，需要划分Layer维护Window显示Z-order；&lt;/p&gt;

&lt;p&gt;有N个Feature（功能），每个Feature能够影响N个Layer层；&lt;/p&gt;

&lt;p&gt;窗口类型是可增加的，Feature是可增删的；&lt;/p&gt;

&lt;h2 id=&quot;22-方案设计&quot;&gt;2.2 方案设计&lt;/h2&gt;

&lt;p&gt;构建DisplayArea树，创建Feature节点，支持动态增删Feature，叶子节点维护Layer层级。&lt;/p&gt;

&lt;p&gt;以 DefaultTaskDisplayArea 节点为例：&lt;/p&gt;

&lt;p&gt;其父节点为 5|0|12 -&amp;gt; 3|0|14 -&amp;gt; 6|0|14 -&amp;gt; 4|0|31 -&amp;gt; DisplayContent，其含义为该节点的所有子节点均支持 FullscreenMagnification|5、OneHanded|3、HideDisplayCutout|6、WindowedMagnification|4 功能（Feature）。&lt;/p&gt;

&lt;p&gt;同时 DefaultTaskDisplayArea 节点的子节点的层级范围为 2|2，即所有子节点均为应用窗口，其Layer值是固定的。&lt;/p&gt;

&lt;h1 id=&quot;3构建displayarea树流程&quot;&gt;3.构建DisplayArea树流程&lt;/h1&gt;

&lt;h2 id=&quot;31-创建rootwindowcontainer&quot;&gt;3.1 创建RootWindowContainer&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;SystemServer.main(..)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SystemServer.run()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SystemServer.startOtherServices(..)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;vm = WindowManagerService.main(..)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// WindowManagerService.java
private WindowManagerService(..) {
    mRoot = new RootWindowContainer(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;32-创建displaycontent&quot;&gt;3.2 创建DisplayContent&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;ActivityManagerService.setWindowManager(wm)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ActivityTaskManagerService.setWindowManager(wm)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;RootWindowContainer.setWindowManager(wm)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// RootWindowContainer.java
private final ImeContainer mImeWindowsContainer = new ImeContainer(mWmService);
void setWindowManager(WindowManagerService wm) {
    ..
    final Display[] displays = mDisplayManager.getDisplays();
    for (int displayNdx = 0; displayNdx &amp;lt; displays.length; ++displayNdx) {
        final Display display = displays[displayNdx];
        final DisplayContent displayContent = new DisplayContent(display, this);
        addChild(displayContent, POSITION_BOTTOM);
        if (displayContent.mDisplayId == DEFAULT_DISPLAY) {
            mDefaultDisplay = displayContent;
        }
    }
    ..
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;33-创建defaulttaskdisplayarea&quot;&gt;3.3 创建DefaultTaskDisplayArea&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DisplayContent.java
DisplayContent(Display display, RootWindowContainer root) {
    ..
    final Transaction pendingTransaction = getPendingTransaction();
    configureSurfaces(pendingTransaction);
    pendingTransaction.apply();
    ..
}

private void configureSurfaces(Transaction transaction) {
    ..
    if (mDisplayAreaPolicy == null) {
        // Setup the policy and build the display area hierarchy.
        // Build the hierarchy only after creating the surface so it is reparented correctly
        mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(
                mWmService, this /* content */, this /* root */,
                mImeWindowsContainer);
    }
    ..
}

//DisplayAreaPolicy.java
static final class DefaultProvider implements DisplayAreaPolicy.Provider {
    @Override
    public DisplayAreaPolicy instantiate(WindowManagerService wmService,
            DisplayContent content, RootDisplayArea root,
            DisplayArea.Tokens imeContainer) {
        final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService,
                &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER);
        final List&amp;lt;TaskDisplayArea&amp;gt; tdaList = new ArrayList&amp;lt;&amp;gt;();
        tdaList.add(defaultTaskDisplayArea);

        // Define the features that will be supported under the root of the whole logical
        // display. The policy will build the DisplayArea hierarchy based on this.
        final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root);
        // Set the essential containers (even if the display doesn&apos;t support IME).
        rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);
        if (content.isTrusted()) {
            // Only trusted display can have system decorations.
            configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);
        }

        // Instantiate the policy with the hierarchy defined above. This will create and attach
        // all the necessary DisplayAreas to the root.
        return new DisplayAreaPolicyBuilder().setRootHierarchy(rootHierarchy).build(wmService);
    }
    
    private void configureTrustedHierarchyBuilder(HierarchyBuilder rootHierarchy,
            WindowManagerService wmService, DisplayContent content) {
        rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;WindowedMagnification&quot;,
                FEATURE_WINDOWED_MAGNIFICATION)
                .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)
                .setNewDisplayAreaSupplier(DisplayArea.Dimmable::new)
                .build());
        if (content.isDefaultDisplay) {
            rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;HideDisplayCutout&quot;,
                    FEATURE_HIDE_DISPLAY_CUTOUT)
                    .all()
                    .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL, TYPE_STATUS_BAR,
                            TYPE_NOTIFICATION_SHADE)
                    .build())
                    .addFeature(new Feature.Builder(wmService.mPolicy, &quot;OneHanded&quot;,
                            FEATURE_ONE_HANDED)
                            .all()
                            .except(TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL,
                                    TYPE_SECURE_SYSTEM_OVERLAY)
                            .build());
        }
        rootHierarchy
                .addFeature(new Feature.Builder(wmService.mPolicy, &quot;FullscreenMagnification&quot;,
                        FEATURE_FULLSCREEN_MAGNIFICATION)
                        .all()
                        .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY, TYPE_INPUT_METHOD,
                                TYPE_INPUT_METHOD_DIALOG, TYPE_MAGNIFICATION_OVERLAY,
                                TYPE_NAVIGATION_BAR, TYPE_NAVIGATION_BAR_PANEL)
                        .build())
                .addFeature(new Feature.Builder(wmService.mPolicy, &quot;ImePlaceholder&quot;,
                        FEATURE_IME_PLACEHOLDER)
                        .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG)
                        .build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 configureTrustedHierarchyBuilder(..) 方法中配置Feature及其能够影响到的Layer层：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Feature名&lt;/th&gt;
      &lt;th&gt;Feature ID&lt;/th&gt;
      &lt;th&gt;对应功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;WindowedMagnification&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;窗口放大镜功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HideDisplayCutout&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;隐藏刘海功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OneHanded&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;单手模式。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FullscreenMagnification&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;屏幕放大镜功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ImePlaceholder&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;特殊情况下用来放置输入法的节点。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在Feature类中使用一个长度为 getMaxWindowLayer() + 1 的boolean数组，用来标识该Feature能够影响到的Layer层：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;34-displayareapolicy构建过程&quot;&gt;3.4 DisplayAreaPolicy构建过程&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DisplayAreaPolicyBuilder.java
private void build(@Nullable List&amp;lt;HierarchyBuilder&amp;gt; displayAreaGroupHierarchyBuilders) {
    final WindowManagerPolicy policy = mRoot.mWmService.mPolicy;
    final int maxWindowLayerCount = policy.getMaxWindowLayer() + 1;
    final DisplayArea.Tokens[] displayAreaForLayer =
            new DisplayArea.Tokens[maxWindowLayerCount];
    final Map&amp;lt;Feature, List&amp;lt;DisplayArea&amp;lt;WindowContainer&amp;gt;&amp;gt;&amp;gt; featureAreas =
            new ArrayMap&amp;lt;&amp;gt;(mFeatures.size());
    for (int i = 0; i &amp;lt; mFeatures.size(); i++) {
        featureAreas.put(mFeatures.get(i), new ArrayList&amp;lt;&amp;gt;());
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;341-构建root节点&quot;&gt;3.4.1 构建root节点：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;PendingArea[] areaForLayer = new PendingArea[maxWindowLayerCount];
final PendingArea root = new PendingArea(null, 0, null);
Arrays.fill(areaForLayer, root);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;342-构建featurearea&quot;&gt;3.4.2 构建featureArea：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Create DisplayAreas to cover all defined features.
final int size = mFeatures.size();
for (int i = 0; i &amp;lt; size; i++) {
    final Feature feature = mFeatures.get(i);
    PendingArea featureArea = null;
    for (int layer = 0; layer &amp;lt; maxWindowLayerCount; layer++) {
        if (feature.mWindowLayers[layer]) {
            if (featureArea == null || featureArea.mParent != areaForLayer[layer]) {
                featureArea = new PendingArea(feature, layer, areaForLayer[layer]);
                areaForLayer[layer].mChildren.add(featureArea);
            }
            areaForLayer[layer] = featureArea;
        } else {
            featureArea = null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;黄色部分与上图是相对应的，创建的PendingArea显示格式为：Feature ID|minLayer&lt;/p&gt;

&lt;p&gt;构建出如下一棵树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/tree1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;343-构建-leafarea&quot;&gt;3.4.3 构建 leafArea：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Create Tokens as leaf for every layer.
PendingArea leafArea = null;
int leafType = LEAF_TYPE_TOKENS;
for (int layer = 0; layer &amp;lt; maxWindowLayerCount; layer++) {
    int type = typeOfLayer(policy, layer);
    if (leafArea == null || leafArea.mParent != areaForLayer[layer]
            || type != leafType) {
        leafArea = new PendingArea(null /* feature */, layer, areaForLayer[layer]);
        areaForLayer[layer].mChildren.add(leafArea);
        leafType = type;
        if (leafType == LEAF_TYPE_TASK_CONTAINERS) {
            addTaskDisplayAreasToApplicationLayer(areaForLayer[layer]);
            addDisplayAreaGroupsToApplicationLayer(areaForLayer[layer],
                    displayAreaGroupHierarchyBuilders);
            leafArea.mSkipTokens = true;
        } else if (leafType == LEAF_TYPE_IME_CONTAINERS) {
            leafArea.mExisting = mImeContainer;
            leafArea.mSkipTokens = true;
        }
    }
    leafArea.mMaxLayer = layer;
}

private static int typeOfLayer(WindowManagerPolicy policy, int layer) {
    if (layer == APPLICATION_LAYER) {
        return LEAF_TYPE_TASK_CONTAINERS; // 容纳App窗口的TaskDisplayArea
    } else if (layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD)
            || layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD_DIALOG)) {
        return LEAF_TYPE_IME_CONTAINERS; // 容纳输入法窗口的ImeContainer
    } else {
        return LEAF_TYPE_TOKENS; // 容纳其他非App类型窗口的DisplayArea.Tokens
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/array3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;黄色部分表示复用同一个leafArea，更新其mMaxLayer值，这里创建的PendingArea显示格式为：minLayer|maxLayer&lt;/p&gt;

&lt;h3 id=&quot;344-更新整棵树所有节点的maxlayer&quot;&gt;3.4.4 更新整棵树所有节点的maxLayer&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;int computeMaxLayer() {
    for (int i = 0; i &amp;lt; mChildren.size(); i++) {
        mMaxLayer = Math.max(mMaxLayer, mChildren.get(i).computeMaxLayer());
    }
    return mMaxLayer;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;345-构建整棵树&quot;&gt;3.4.5 构建整棵树&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;void instantiateChildren(DisplayArea&amp;lt;DisplayArea&amp;gt; parent, DisplayArea.Tokens[] areaForLayer,
        int level, Map&amp;lt;Feature, List&amp;lt;DisplayArea&amp;lt;WindowContainer&amp;gt;&amp;gt;&amp;gt; areas) {
    mChildren.sort(Comparator.comparingInt(pendingArea -&amp;gt; pendingArea.mMinLayer));
    for (int i = 0; i &amp;lt; mChildren.size(); i++) {
        final PendingArea child = mChildren.get(i);
        final DisplayArea area = child.createArea(parent, areaForLayer);
        if (area == null) {
            // TaskDisplayArea and ImeContainer can be set at different hierarchy, so it can
            // be null.
            continue;
        }
        parent.addChild(area, WindowContainer.POSITION_TOP);
        if (child.mFeature != null) {
            areas.get(child.mFeature).add(area);
        }
        child.instantiateChildren(area, areaForLayer, level + 1, areas);
    }
}

private DisplayArea createArea(DisplayArea&amp;lt;DisplayArea&amp;gt; parent,
        DisplayArea.Tokens[] areaForLayer) {
    if (mExisting != null) {
        // LEAF_TYPE_TASK_CONTAINERS
        // LEAF_TYPE_IME_CONTAINERS
        if (mExisting.asTokens() != null) {
            // Store the WindowToken container for layers
            fillAreaForLayers(mExisting.asTokens(), areaForLayer);
        }
        return mExisting;
    }
    if (mSkipTokens) {
        // LEAF_TYPE_TASK_CONTAINERS
        // LEAF_TYPE_IME_CONTAINERS
        return null;
    }
    DisplayArea.Type type;
    if (mMinLayer &amp;gt; APPLICATION_LAYER) {
        type = DisplayArea.Type.ABOVE_TASKS; // 位于App窗口之下的非App窗口
    } else if (mMaxLayer &amp;lt; APPLICATION_LAYER) {
        type = DisplayArea.Type.BELOW_TASKS; // 位于App窗口之上的非App窗口
    } else {
        type = DisplayArea.Type.ANY; // App窗口
    }
    if (mFeature == null) {
        final DisplayArea.Tokens leaf = new DisplayArea.Tokens(parent.mWmService, type,
                &quot;Leaf:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer);
        fillAreaForLayers(leaf, areaForLayer);
        return leaf;
    } else {
        return mFeature.mNewDisplayAreaSupplier.create(parent.mWmService, type,
                mFeature.mName + &quot;:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer, mFeature.mId);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整棵树的根节点是 DisplayContent，这里创建的DisplayArea显示格式为：Feature ID|minLayer|maxLayer；叶子节点的显示格式为：minLayer|maxLayer&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DisplayArea/tree2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;执行命令：adb shell dumpsys activity containers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;ACTIVITY MANAGER CONTAINERS (dumpsys activity containers)
ROOT 
  #0 Display 0 name=&quot;内置屏幕&quot;
   #2 Leaf:36:36 
    #1 WindowToken{7fb09c2 type=2024 android.os.BinderProxy@da9960d} 
     #0 e873d3 RoundCornerBottom 
    #0 WindowToken{2c592ae type=2024 android.os.BinderProxy@5ce3f29} 
     #0 164a84f RoundCornerTop 
   #1 HideDisplayCutout:32:35 
    #2 OneHanded:34:35 
     #0 FullscreenMagnification:34:35 
      #0 Leaf:34:35 
    #1 FullscreenMagnification:33:33 
     #0 Leaf:33:33 
    #0 OneHanded:32:32 
     #0 Leaf:32:32 
   #0 WindowedMagnification:0:31 
    #6 HideDisplayCutout:26:31 
     #0 OneHanded:26:31 
      #2 FullscreenMagnification:29:31 
       #0 Leaf:29:31 
      #1 Leaf:28:28 
       #1 WindowToken{6cffb72 type=2027 android.os.BinderProxy@9b9807d} 
        #0 e90cc40 GestureStubRight 
       #0 WindowToken{288fa0d type=2027 android.os.BinderProxy@3713ca4} 
        #0 1d77f10 GestureStubLeft 
      #0 FullscreenMagnification:26:27 
       #0 Leaf:26:27 
    #5 Leaf:24:25 
     #3 WindowToken{2cfd75e type=2024 android.os.BinderProxy@a18e899} 
      #0 6d1873f GestureStubHome 
     #2 WindowToken{4a05ae3 type=2024 android.os.BinderProxy@b34e312} 
      #0 28a0ce0 SecondaryHomeHandle0 
     #1 WindowToken{6986f7 type=2024 android.os.BinderProxy@f7da2f6} 
      #0 e17e964 pip-dismiss-overlay 
     #0 WindowToken{dfc6ab6 type=2019 android.os.BinderProxy@e0bfb78} 
      #0 bc113b7 NavigationBar0 
    #4 HideDisplayCutout:18:23 
     #0 OneHanded:18:23 
      #0 FullscreenMagnification:18:23 
       #0 Leaf:18:23 
        #1 WindowToken{2ecacd2 type=2017 android.os.BinderProxy@63e9b5d} 
         #0 7d9c1a3 control_center 
        #0 WindowToken{7960200 type=2017 android.os.BinderProxy@7c7083} 
         #0 b7b0a39 NotificationModalWindowManager 
    #3 OneHanded:17:17 
     #0 FullscreenMagnification:17:17 
      #0 Leaf:17:17 
       #0 WindowToken{37bf169 type=2040 android.os.BinderProxy@80f5833} 
        #0 f89f7ee NotificationShade 
    #2 HideDisplayCutout:16:16 
     #0 OneHanded:16:16 
      #0 FullscreenMagnification:16:16 
       #0 Leaf:16:16 
    #1 OneHanded:15:15 
     #0 FullscreenMagnification:15:15 
      #0 Leaf:15:15 
       #0 WindowToken{ac189b4 type=2000 android.os.BinderProxy@75516c6} 
        #0 194a9dd StatusBar 
    #0 HideDisplayCutout:0:14 
     #0 OneHanded:0:14 
      #1 ImePlaceholder:13:14 
       #0 ImeContainer 
        #0 WindowToken{720aa04 type=2011 android.os.Binder@d506617} 
         #0 f966473 InputMethod 
      #0 FullscreenMagnification:0:12 
       #2 Leaf:3:12 
        #0 WindowToken{ec3f545 type=2038 android.os.BinderProxy@fd8013a} 
         #0 329a9af ShellDropTarget 
       #1 DefaultTaskDisplayArea 
        #2 Task=18 
         #0 Task=19 
          #0 ActivityRecord{296e207 u0 com.miui.home/.launcher.Launcher} t19} 
           #0 9eb98f2 com.miui.home/com.miui.home.launcher.Launcher 
        #1 Task=4 
        #0 Task=5 
         #1 Task=7 
         #0 Task=6 
       #0 Leaf:0:1 
        #1 WallpaperWindowToken{d4d41d3 token=android.os.BinderProxy@2da4fc2} 
         #0 d44d722 com.miui.miwallpaper.wallpaperservice.MiuiKeyguardPictorialWallpaper 
        #0 WallpaperWindowToken{22dbaad token=android.os.Binder@fe41bc4} 
         #0 8db5a66 com.miui.miwallpaper.wallpaperservice.ImageWallpaper 
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到Activity是在DefaultTaskDisplayArea节点下，其他新创建的Window会根据Layer值插入到对应Leaf节点上。&lt;/p&gt;

&lt;h1 id=&quot;4参考资料&quot;&gt;4.参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7140289958085935141&quot;&gt;DisplayArea层级结构（一） —— DisplayArea层级结构的生成&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/7140289685879783432&quot;&gt;DisplayArea层级结构（二） —— 向DisplayArea层级结构添加窗口&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.cn/post/7140289813516648456&quot;&gt;DisplayArea层级结构（三） —— 总结&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/shensky711/article/details/121530510&quot;&gt;WMS 层级结构 &amp;amp;&amp;amp; DisplayAreaGroup 引入&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/jieliaoyuan8279/article/details/123157937&quot;&gt;窗口层次: DisplayArea树&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 24 Dec 2022 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/12/24/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/12/24/DisplayArea%E6%A0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>Android类加载流程</title>
        <description>&lt;h1 id=&quot;1基本概念&quot;&gt;1.基本概念&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;1.1 类加载器的作用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;类的加载需要类加载器完成，在JVM中，一个类的唯一性是需要这个类本身和类加载器一起才能确定的，每个类加载器都有一个独立的命名空间。&lt;/p&gt;

&lt;p&gt;不同的类加载器，即使是同一个类字节码文件，最后再JVM里的类对象也不是同一个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 双亲委派模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，&lt;/p&gt;

&lt;p&gt;因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    // 交给父类加载器尝试加载
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                // 父类加载器无法加载时自身尝试加载
                c = findClass(name);

                // this is the defining class loader; record the stats
                PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。&lt;/p&gt;

&lt;p&gt;例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，&lt;/p&gt;

&lt;p&gt;因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，&lt;/p&gt;

&lt;p&gt;并放在程序的Class Path中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3 Java与Android类加载器比较&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JVM加载的是class文件，ART加载的是dex文件。&lt;/p&gt;

&lt;p&gt;Java中四种类加载器：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ClassLoader/java.png&quot; alt=&quot;java&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Android中类加载器：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ClassLoader/android.png&quot; alt=&quot;android&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2android类加载器&quot;&gt;2.Android类加载器&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;ClassLoader：&lt;/strong&gt;对Java的ClassLoader代码做了精简，其中loadClass()核心逻辑不变，仍采用双亲委派模型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BootClassLoader&lt;/strong&gt;：继承于ClassLoader，是ClassLoader的内部类。是SystemClassLoader的父加载器，同时也是Android中所有ClassLoader的最终parent。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ClassLoader.java 
private static ClassLoader createSystemClassLoader() {
    String classPath = System.getProperty(&quot;java.class.path&quot;, &quot;.&quot;);
    String librarySearchPath = System.getProperty(&quot;java.library.path&quot;, &quot;&quot;);
    return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());
}

public ClassLoader getClassLoader() {
    return (classLoader == null) ? BootClassLoader.getInstance() : classLoader;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;BaseDexClassLoader&lt;/strong&gt;：继承于ClassLoader，是PathClassLoader和DexClassLoader的父类。&lt;/p&gt;

&lt;p&gt;BaseDexClassLoader重写了ClassLoader的findClass()方法，核心在于维护了DexPathList这个类对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// BaseDexClassLoader.java 
private final DexPathList pathList;

public BaseDexClassLoader(String dexPath,
        String librarySearchPath, ClassLoader parent, ClassLoader[] sharedLibraryLoaders,
        ClassLoader[] sharedLibraryLoadersAfter,
        boolean isTrusted) {
    super(parent);
    ...
    this.pathList = new DexPathList(this, dexPath, librarySearchPath, null, isTrusted);
    ...
}
 
@Override
protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
    ...
    Class c = pathList.findClass(name, suppressedExceptions);
    if (c != null) {
        return c;
    }
    ...
    return c;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;PathClassLoader&lt;/strong&gt;：继承于BaseDexClassLoader，用来加载系统类和apk中的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DexClassLoader&lt;/strong&gt;：继承于BaseDexClassLoader，可以用来加载外置的dex文件或者apk，jar等。&lt;/p&gt;

&lt;p&gt;在Android8.1之后，optimizedDirectory参数已废弃，默认传入null。也就是说Android8.1版本及以后，PathClassLoader和DexClassLoader没有区别。&lt;/p&gt;

&lt;h1 id=&quot;3dexpathlist&quot;&gt;3.DexPathList&lt;/h1&gt;

&lt;p&gt;DexPathList核心功能是维护dexElements数组，用来记录dex文件集合。在BaseDexClassLoader构造函数中将dexPath传入，在DexPathList的splitDexPath()方法解析文件路径，在makeDexElements()方法添加到dexElements数组中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DexPathList.java
private Element[] dexElements;
 
DexPathList(ClassLoader definingContext, String dexPath,
        String librarySearchPath, File optimizedDirectory, boolean isTrusted) {
    ...
    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,
                                       suppressedExceptions, definingContext, isTrusted);
    ...
}

// 生成dexElements数组
private static Element[] makeDexElements(List&amp;lt;File&amp;gt; files, File optimizedDirectory,
        List&amp;lt;IOException&amp;gt; suppressedExceptions, ClassLoader loader, boolean isTrusted) {
  Element[] elements = new Element[files.size()];
  int elementsPos = 0;
  for (File file : files) {
      if (file.isDirectory()) {
              ...
      } else if (file.isFile()) {
          String name = file.getName();

          DexFile dex = null;
          if (name.endsWith(DEX_SUFFIX)) {
              // Raw dex file (not inside a zip/jar).
              try {
                  dex = loadDexFile(file, optimizedDirectory, loader, elements);
                  if (dex != null) {
                      elements[elementsPos++] = new Element(dex, null);
                  }
              } catch (IOException suppressed) {
                  ...
              }
          } else {
              ...
          }
          if (dex != null &amp;amp;&amp;amp; isTrusted) {
            dex.setTrusted();
          }
      } else {
          System.logW(&quot;ClassLoader referenced unknown path: &quot; + file);
      }
  }
  if (elementsPos != elements.length) {
      elements = Arrays.copyOf(elements, elementsPos);
  }
  return elements;
}

// 加载dex文件，创建DexFile对象
private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader,
                                   Element[] elements)
        throws IOException {
    if (optimizedDirectory == null) {
        return new DexFile(file, loader, elements);
    } else {
        String optimizedPath = optimizedPathFor(file, optimizedDirectory);
        return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);
    }
}

static class Element {
    private final File path;
    private final Boolean pathIsDirectory;
    private final DexFile dexFile;
 
    public Class&amp;lt;?&amp;gt; findClass(String name, ClassLoader definingContext,List&amp;lt;Throwable&amp;gt; suppressed) {
        return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed) : null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上文提到BaseDexClassLoader重写了ClassLoader的findClass()方法，其实现是直接调用DexPathList的findClass()方法，其核心逻辑是遍历所有dex文件，调用DexFile的loadClassBinaryName()方法加载类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// DexPathList.java
public Class&amp;lt;?&amp;gt; findClass(String name, List&amp;lt;Throwable&amp;gt; suppressed) {
    for (Element element : dexElements) {
        Class&amp;lt;?&amp;gt; clazz = element.findClass(name, definingContext, suppressed);
        if (clazz != null) {
            return clazz;
        }
    }
    ...
    return null;
}

// DexFile.java 
public Class loadClassBinaryName(String name, ClassLoader loader, List&amp;lt;Throwable&amp;gt; suppressed) {
    return defineClass(name, loader, mCookie, this, suppressed);
}

private static Class defineClass(String name, ClassLoader loader, Object cookie,
                                 DexFile dexFile, List&amp;lt;Throwable&amp;gt; suppressed) {
    Class result = null;
    try {
        result = defineClassNative(name, loader, cookie, dexFile);
    } catch (NoClassDefFoundError e) {
        ...
    } catch (ClassNotFoundException e) {
        ...
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从DexPathList的findClass()方法我们可以看到，在尝试加载一个类的时候，会遍历所有dex文件，只要找到就会直接返回，不会再继续遍历dexElements。&lt;/p&gt;

&lt;p&gt;也就是说当两个类不同的dex中出现，会优先处理排在前面的dex文件，这便是热修复的核心精髓，将需要修复的类所打包的dex文件插入到dexElements前面。&lt;/p&gt;

&lt;h1 id=&quot;4类加载流程&quot;&gt;4.类加载流程&lt;/h1&gt;

&lt;p&gt;在启动应用创建进程后，会调用ActivityThread.main()方法，在main()方法中ActivityThread与AMS建立交互，&lt;/p&gt;

&lt;p&gt;然后AMS调用ApplicationThread.bindApplication()方法，在bindApplication()方法中发送BIND_APPLICATION消息，执行handleBindApplication()方法，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
public static void main(String[] args) {
    ...
    ActivityThread thread = new ActivityThread();
    thread.attach(false, startSeq);
    ...
}
 
private void attach(boolean system, long startSeq) {
    ...
    final IActivityManager mgr = ActivityManager.getService();
    try {
        mgr.attachApplication(mAppThread, startSeq);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
    ...
}
 
private class ApplicationThread extends IApplicationThread.Stub {
    public final void bindApplication(String processName, ApplicationInfo appInfo,
        ...
        sendMessage(H.BIND_APPLICATION, data);
    }
}
 
private void handleBindApplication(AppBindData data) {
    ...
    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo, isSdkSandbox);
    ...
    Application app = data.info.makeApplication(data.restrictedBackupMode, null);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在handleBindApplication()方法中会调用getPackageInfoNoCheck()方法，其过程中会创建LoadedApk对象，这里需要注意的是构建LoadedApk传入的baseLoader为null，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ActivityThread.java
public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,
        CompatibilityInfo compatInfo) {
    return getPackageInfo(ai, compatInfo, null, false, true, false, isSdkSandbox);
}
 
private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,
        ClassLoader baseLoader, boolean securityViolation, boolean includeCode,
        boolean registerPackage, boolean isSdkSandbox) {
        ...
        packageInfo =
                new LoadedApk(this, aInfo, compatInfo, baseLoader,
                        securityViolation, includeCode
                        &amp;amp;&amp;amp; (aInfo.flags &amp;amp; ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);
        ...
        return packageInfo;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，LoadedApk对象已经创建，其mBaseClassLoader为null。接下来继续makeApplication()的逻辑，&lt;/p&gt;

&lt;p&gt;这里会调用getClassLoader()方法，此时mClassLoader为null，调用createOrUpdateClassLoaderLocked()方法，&lt;/p&gt;

&lt;p&gt;此时mDefaultClassLoader也为null，调用ApplicationLoaders创建DefaultClassLoader，&lt;/p&gt;

&lt;p&gt;最后初始化mClassLoader，这里mDefaultClassLoader==mClassLoader，两者是相同的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// LoadedApk.java
public Application makeApplication(boolean forceDefaultAppClass,
        Instrumentation instrumentation) {
    return makeApplicationInner(forceDefaultAppClass, instrumentation,
            /* allowDuplicateInstances= */ true);
}

private Application makeApplicationInner(boolean forceDefaultAppClass,
        Instrumentation instrumentation, boolean allowDuplicateInstances) {
    ...
    final String myProcessName = Process.myProcessName();
    String appClass = mApplicationInfo.getCustomApplicationClassNameForProcess(
            myProcessName);
    if (forceDefaultAppClass || (appClass == null)) {
        appClass = &quot;android.app.Application&quot;;
    }

    try {
        final java.lang.ClassLoader cl = getClassLoader();
        ...
        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
        ...
        app = mActivityThread.mInstrumentation.newApplication(
                cl, appClass, appContext);
        appContext.setOuterContext(app);
    } catch (Exception e) {
        ...
    } 
    ...
    return app;
}
 
public ClassLoader getClassLoader() {
    synchronized (this) {
        if (mClassLoader == null) {
            createOrUpdateClassLoaderLocked(null /*addedPaths*/);
        }
        return mClassLoader;
    }
}
 
private void createOrUpdateClassLoaderLocked(List&amp;lt;String&amp;gt; addedPaths) {
    ...
    final List&amp;lt;String&amp;gt; zipPaths = new ArrayList&amp;lt;&amp;gt;(10);
    final List&amp;lt;String&amp;gt; libPaths = new ArrayList&amp;lt;&amp;gt;(10);
    ...
    makePaths(mActivityThread, isBundledApp, mApplicationInfo, zipPaths, libPaths);
    ...
    final String zip = (zipPaths.size() == 1) ? zipPaths.get(0) :
        TextUtils.join(File.pathSeparator, zipPaths);
    if (mDefaultClassLoader == null) {
        ...
        mDefaultClassLoader = ApplicationLoaders.getDefault().getClassLoaderWithSharedLibraries(
                zip, mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath,
                libraryPermittedPath, mBaseClassLoader,
                mApplicationInfo.classLoaderName, sharedLibraries.first, nativeSharedLibraries,
                sharedLibraries.second);
        mAppComponentFactory = createAppFactory(mApplicationInfo, mDefaultClassLoader);
        ...
    }
    if (!libPaths.isEmpty()) {
        ...
        try {
            ApplicationLoaders.getDefault().addNative(mDefaultClassLoader, libPaths);
        } finally {
            ...
        }
    }
    if (addedPaths != null &amp;amp;&amp;amp; addedPaths.size() &amp;gt; 0) {
        final String add = TextUtils.join(File.pathSeparator, addedPaths);
        ApplicationLoaders.getDefault().addPath(mDefaultClassLoader, add);
        ...
    }
    ...
    if (mClassLoader == null) {
        mClassLoader = mAppComponentFactory.instantiateClassLoader(mDefaultClassLoader,
                new ApplicationInfo(mApplicationInfo));
    }
}

public static void makePaths(ActivityThread activityThread,
                             boolean isBundledApp,
                             ApplicationInfo aInfo,
                             List&amp;lt;String&amp;gt; outZipPaths,
                             List&amp;lt;String&amp;gt; outLibPaths) {
    final String appDir = aInfo.sourceDir; // Full path to the base APK for this application.
    final String libDir = aInfo.nativeLibraryDir; // Full path to the directory where native JNI libraries are stored.

    outZipPaths.clear();
    outZipPaths.add(appDir); // data/app/**/base.apk
    ...
    if (outLibPaths != null) {
        if (outLibPaths.isEmpty()) {
            outLibPaths.add(libDir); 
        }

        if (aInfo.primaryCpuAbi != null) {
            ...
            for (String apk : outZipPaths) {
                outLibPaths.add(apk + &quot;!/lib/&quot; + aInfo.primaryCpuAbi);
            }
        }
        ...
    }
    ...
    appendSharedLibrariesLibPathsIfNeeded(
            aInfo.sharedLibraryInfos, aInfo, outSeenPaths, outLibPaths);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来看ApplicationLoaders里的逻辑，在getClassLoaderWithSharedLibraries()方法中会调用getClassLoader()方法，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ApplicationLoaders.java
ClassLoader getClassLoaderWithSharedLibraries(
        String zip, int targetSdkVersion, boolean isBundled,
        String librarySearchPath, String libraryPermittedPath,
        ClassLoader parent, String classLoaderName,
        List&amp;lt;ClassLoader&amp;gt; sharedLibraries, List&amp;lt;String&amp;gt; nativeSharedLibraries,
        List&amp;lt;ClassLoader&amp;gt; sharedLibrariesLoadedAfterApp) {
    // For normal usage the cache key used is the same as the zip path.
    return getClassLoader(zip, targetSdkVersion, isBundled, librarySearchPath,
                          libraryPermittedPath, parent, zip, classLoaderName, sharedLibraries,
                          nativeSharedLibraries, sharedLibrariesLoadedAfterApp);
}

// 这里传入的parent==null
private ClassLoader getClassLoader(String zip, int targetSdkVersion, boolean isBundled,
                                  String librarySearchPath, String libraryPermittedPath,
                                  ClassLoader parent, String cacheKey,
                                  String classLoaderName, List&amp;lt;ClassLoader&amp;gt; sharedLibraries,
                                  List&amp;lt;String&amp;gt; nativeSharedLibraries,
                                  List&amp;lt;ClassLoader&amp;gt; sharedLibrariesLoadedAfterApp) {
    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent(); // java.lang.BootClassLoader

    synchronized (mLoaders) {
        if (parent == null) {
            parent = baseParent;
        }

        if (parent == baseParent) {
            ...
            ClassLoader classloader = ClassLoaderFactory.createClassLoader(
                    zip,  librarySearchPath, libraryPermittedPath, parent,
                    targetSdkVersion, isBundled, classLoaderName, sharedLibraries,
                    nativeSharedLibraries, sharedLibrariesLoadedAfterApp);
            ...
            return classloader;
        }

        ClassLoader loader = ClassLoaderFactory.createClassLoader(
                zip, null, parent, classLoaderName, sharedLibraries,
                null /*sharedLibrariesLoadedAfterApp*/);

        return loader;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着看ClassLoaderFactory的逻辑，这里classloaderName为null，因此创建的是PathClassLoader。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// ClassLoaderFactory.java
public static ClassLoader createClassLoader(String dexPath,
       String librarySearchPath, ClassLoader parent, String classloaderName,
       List&amp;lt;ClassLoader&amp;gt; sharedLibraries, List&amp;lt;ClassLoader&amp;gt; sharedLibrariesLoadedAfter) {
   ...
   if (isPathClassLoaderName(classloaderName)) {
       return new PathClassLoader(dexPath, librarySearchPath, parent, arrayOfSharedLibraries,
               arrayOfSharedLibrariesLoadedAfterApp);
   } else if (isDelegateLastClassLoaderName(classloaderName)) {
       return new DelegateLastClassLoader(dexPath, librarySearchPath, parent,
               arrayOfSharedLibraries, arrayOfSharedLibrariesLoadedAfterApp);
   }

    throw new AssertionError(&quot;Invalid classLoaderName: &quot; + classloaderName);
}
 
public static boolean isPathClassLoaderName(String name) {
    return name == null || PATH_CLASS_LOADER_NAME.equals(name) ||
            DEX_CLASS_LOADER_NAME.equals(name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回到LoadedApk.makeApplication()的逻辑，接下来会创建Application，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// Instrumentation.java 
public Application newApplication(ClassLoader cl, String className, Context context)
        throws InstantiationException, IllegalAccessException,
        ClassNotFoundException {
    Application app = getFactory(context.getPackageName())
            .instantiateApplication(cl, className);
    app.attach(context);
    return app;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的className默认是android.app.Application，cl是之前创建的PathClassLoader。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;// instantiateApplication.java
public @NonNull Application instantiateApplication(@NonNull ClassLoader cl,
        @NonNull String className)
        throws InstantiationException, IllegalAccessException, ClassNotFoundException {
    return (Application) cl.loadClass(className).newInstance();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是应用PathClassLoader的创建流程以及应用代码是如何被加载的。需要注意的是基于双亲委派模型，最终加载android.app.Application类的classloader是BootClassLoader。&lt;/p&gt;

&lt;h1 id=&quot;5delegatelastclassloader&quot;&gt;5.DelegateLastClassLoader&lt;/h1&gt;

&lt;p&gt;在上文分析创建PathClassLoader代码中，还有一种类加载器DelegateLastClassLoader，继承于PathClassLoader，其加载class核心逻辑如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;@Override
protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // First, check whether the class has already been loaded. Return it if that&apos;s the
    // case.
    Class&amp;lt;?&amp;gt; cl = findLoadedClass(name);
    if (cl != null) {
        return cl;
    }
 
    // Next, check whether the class in question is present in the boot classpath.
    try {
        return Object.class.getClassLoader().loadClass(name);
    } catch (ClassNotFoundException ignored) {
    }
 
    // Next, check whether the class in question is present in the dexPath that this classloader
    // operates on, or its shared libraries.
    ClassNotFoundException fromSuper = null;
    try {
        return findClass(name);
    } catch (ClassNotFoundException ex) {
        fromSuper = ex;
    }
 
    // Finally, check whether the class in question is present in the parent classloader.
    try {
        return getParent().loadClass(name);
    } catch (ClassNotFoundException cnfe) {
        // The exception we&apos;re catching here is the CNFE thrown by the parent of this
        // classloader. However, we would like to throw a CNFE that provides details about
        // the class path / list of dex files associated with *this* classloader, so we choose
        // to throw the exception thrown from that lookup.
        throw fromSuper;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，判断该类是否已经被加载，如果已加载直接返回。&lt;/p&gt;

&lt;p&gt;然后，尝试由BootClassLoader加载。&lt;/p&gt;

&lt;p&gt;接着，尝试由DelegateLastClassLoader自身加载。&lt;/p&gt;

&lt;p&gt;最后，尝试由DelegateLastClassLoader的父加载器加载。&lt;/p&gt;

&lt;p&gt;可以看到DelegateLastClassLoader打破了双亲委派模型，先尝试自身加载，在交由parent加载。&lt;/p&gt;

&lt;h1 id=&quot;6replugin&quot;&gt;6.RePlugin&lt;/h1&gt;

&lt;p&gt;项目地址：https://github.com/Qihoo360/RePlugin&lt;/p&gt;

&lt;p&gt;其核心是在应用Application创建的时候，通过hook替换掉应用Context中的mPackageInfo中的mClassLoader，在自定义的DexClassLoader中优先加载插件类。&lt;/p&gt;

&lt;p&gt;RePluginClassLoader：用于替换Context中的mPackageInfo中的mClassLoader。&lt;/p&gt;

&lt;p&gt;PluginDexClassLoader：处理类加载逻辑，优先加载插件类。&lt;/p&gt;

&lt;p&gt;PatchClassLoaderUtils：通过hook实现替换Context中的mPackageInfo中的mClassLoader的功能。&lt;/p&gt;

&lt;h1 id=&quot;参考文档&quot;&gt;参考文档：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1517603&quot;&gt;彻底搞懂JVM类加载器：基本概念&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.tencent.com/developer/article/1520709&quot;&gt;类加载器中的双亲委派模型详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gityuan.com/2017/03/19/android-classloader/&quot;&gt;Android类加载器ClassLoader&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 24 Aug 2022 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/08/24/Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/08/24/Android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>ClassLoader</category>
        
        
      </item>
    
      <item>
        <title>Recovery机制介绍</title>
        <description>&lt;p&gt;2020年三星手机发生了一场严重事故，中国三星手机用户在5月23日这一天凌晨突然无限重启，事故原因是因SystemUI发生异常重复Crash导致手机进入Recovery界面，用户只能选择恢复出厂设置导致用户数据永久丢失。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/396666758/answer/1245994988&quot;&gt;怎么看待三星大量手机在今天（5.23）凌晨系统崩溃并数据丢失？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;知乎上已经有大佬详细分析了事故原因，本文重点介绍下为什么SystemUI频繁Crash会进入Recovery界面。&lt;/p&gt;

&lt;h1 id=&quot;1-resureparty功能初始化&quot;&gt;&lt;strong&gt;1. ResureParty功能初始化&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;ResureParty是一套系统自救机制，当监控到系统核心程序出现循环崩溃时，通过尝试一系列措施达到恢复设备正常运行的目的，直到所有措施都无济于事，则会进入Recovery界面让用户通过擦除数据的方式进行设备恢复。&lt;/p&gt;

&lt;p&gt;其初始化流程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Recovery/r1.png&quot; alt=&quot;r1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在SystemServer启动时，会初始化ResureParty机制。核心逻辑在PackageWatchDog，当应用发生异常退出时，PackageWatchDog会记录相关异常信息。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h1 id=&quot;2-systemui发生crash被系统重新拉起&quot;&gt;&lt;strong&gt;2. SystemUI发生Crash被系统重新拉起&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;SystemUI是常驻进程，当其发生异常退出时，系统会尝试重新启动，其流程图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Recovery/r2.png&quot; alt=&quot;r2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ActivityManagerService中收到应用死亡的回调后，会判断应用是否为系统常驻进程。如果应用是系统常驻进程，则会重新启动该进程。&lt;/p&gt;

&lt;h1 id=&quot;3-systemui频繁重启触发resureparty机制&quot;&gt;&lt;strong&gt;3. SystemUI频繁重启触发ResureParty机制&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;当SystemUI发生异常退出时，系统会重新启动SystemUI。但如果SystemUI的异常状态没有恢复，即重启后依然发生异常退出，则会陷入到异常退出-重启-异常退出-重启…这种循环崩溃的状态，此时就会触发ResureParty机制。&lt;/p&gt;

&lt;p&gt;触发ResureParty机制的流程图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/Recovery/r3.png&quot; alt=&quot;r3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当应用异常退出后，会上报到PackageWatchDog，其onPackageFailureLocked方法中会判断当前应用是否为系统常驻进程，如果应用是系统常驻进程，则会更新mitigationCount，其对应的严重等级如下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;mitigationCount&lt;/th&gt;
      &lt;th&gt;严重等级&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;LEVEL_RESET_SETTINGS_UNTRUSTED_DEFAULTS&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;LEVEL_RESET_SETTINGS_UNTRUSTED_CHANGES&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;LEVEL_RESET_SETTINGS_TRUSTED_DEFAULTS&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;LEVEL_WARM_REBOOT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;LEVEL_FACTORY_RESET&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当达到严重等级达到LEVEL_FACTORY_RESET级别后，系统就会进入Recovery界面2&lt;/p&gt;
</description>
        <pubDate>Fri, 29 May 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/05/29/Recovery%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/05/29/Recovery%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/</guid>
        
        <category>Android</category>
        
        <category>SystemUI</category>
        
        <category>Recovery</category>
        
        
      </item>
    
      <item>
        <title>Android源码编译mk转bp</title>
        <description>&lt;h3 id=&quot;1-基本概念介绍&quot;&gt;1. 基本概念介绍&lt;/h3&gt;

&lt;p&gt;自Android N开始，Google开始用Ninja来替代Makefile编译系统。编译时，会先把Android.mk通过kati转换成.ninja文件，然后使用ninja命令进行编译。&lt;/p&gt;

&lt;p&gt;Android.bp是替代Android.mk的配置文件，在Android O默认开启相关支持。编译时，由Soong解析转换成.ninja文件。&lt;/p&gt;

&lt;p&gt;Soong是为Android编译设计的工具，Blueprint和Soong都是由Golang写的项目，Blueprint解析文件的格式，而Soong解释内容的含义，bp即Blueprint的缩写。&lt;/p&gt;

&lt;p&gt;与Android.mk不同的是，Android.bp是纯粹的配置文件，不包含分支、循环等流程控制，也不能做算数、逻辑运算，需使用Golang编写控制逻辑。&lt;/p&gt;

&lt;p&gt;注意：Android.mk文件中的模块可以依赖Android.bp文件中的模块，但不能相反。&lt;/p&gt;

&lt;h3 id=&quot;2-androidbp文件格式&quot;&gt;2. Android.bp文件格式&lt;/h3&gt;

&lt;p&gt;Android.bp文件的语法和语义与Bazel BUILD文件类似，参考：&lt;a href=&quot;https://docs.bazel.build/versions/master/be/overview.html&quot;&gt;bazel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;模块：Android.bp文件中的模块以一个模块类型开始，后面跟着一组属性，以名值对(name: value)表示。每个模块必须有一个name属性，并且在所有的Android.bp文件中必须是唯一的。&lt;/p&gt;

&lt;p&gt;Globs：用于获取文件列表，可以包含普通的Unix通配符*，如”*.java”，还可以包含单个**通配符作为路径元素，它将匹配零个或多个路径元素。&lt;/p&gt;

&lt;p&gt;变量：Android.bp文件可以包含顶级变量并赋值。变量的范围被限定为它们声明的文件的剩余部分，以及任何子 blueprint 文件。一个例外是变量不可变，能够被 += 进行附加赋值，而且只能在被引用之前。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;gzip_srcs = [&quot;src/test/minigzip.c&quot;],
 
cc_binary {
    name: &quot;gzip&quot;,
    srcs: gzip_srcs,
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注释：Android.bp文件能包含C风格的多行/* */注释和C++风格的单行注释//。&lt;/p&gt;

&lt;p&gt;类型：变量和属性是强类型的，基于第一个赋值动态变量，以及模块类型静态属性。他们支持的类型有：布尔型（bool) 整型（int）字符串（string）字符串列表（”string1”, “string2”）Maps ({key1: “value1”, key2: [“value2”]})。&lt;/p&gt;

&lt;p&gt;Map 可以包含任意类型的值，包括嵌套的maps。列表和 maps 允许在最后一个值之后有逗号。&lt;/p&gt;

&lt;p&gt;操作符：字符串、字符串列表、和maps能使用+操作符进行附加。整型可以用+操作符来总结。附加的maps将生成两个map中键的并集，并附加的两个map中存在任何键的值。&lt;/p&gt;

&lt;p&gt;缺省模块：缺省模块可用于在多个模块中重复相同的属性。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;cc_defaults {
    name: &quot;gzip_defaults&quot;,
}
 
cc_binary {
    name: &quot;gzip&quot;,
    defaults: [&quot;gzip_defaults&quot;],
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;名称解析：Soong为不同目录中的模块提供了指定相同名称的能力。只要每个模块在一个单独的名称空间中声明。 命名空间可以这样声明：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;soong_namespace {
    imports: [&quot;path/to/otherNamespace1&quot;, &quot;path/to/otherNamespace2&quot;],
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每个Soong模块都会根据其在树中的位置分配一个名称空间，除非找不到soong_namespace模块，否则每个Soong模块都被认为位于当前目录或最接近的父目录中的Android.bp中的soong_namespace所定义的名称空间中。在这种情况下，该模块被认为处于隐式根目录命名空间。&lt;/p&gt;

&lt;p&gt;格式化：Soong 包含了一个 blueprint 文件的格式化器，类似于 gofmt。使用以下命令来递归格式化当前目录中的所有 Android.bp 文件：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;bpfmt -w .
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;标准格式包括 4 个空格的缩进，包含多个元素的列表中，每个元素之后的换行符，并且始终包括列表和 maps中的逗号。&lt;/p&gt;

&lt;h3 id=&quot;3-mk与bp对照&quot;&gt;3. mk与bp对照&lt;/h3&gt;

&lt;p&gt;参考：&lt;a href=&quot;https://android.googlesource.com/platform/build/soong/+/a930003/androidmk/cmd/androidmk/android.go&quot;&gt;android.go&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-go语言&quot;&gt;4. go语言&lt;/h3&gt;

&lt;p&gt;声明变量：var identifier type ，简短形式使用 := 赋值操作符&lt;/p&gt;

&lt;p&gt;声明常量：const identifier [type] = value&lt;/p&gt;

&lt;p&gt;声明数组：var variable_name [SIZE] variable_type&lt;/p&gt;

&lt;p&gt;指针：var var_name *var-type&lt;/p&gt;

&lt;p&gt;type关键字：定义结构体，定义接口，类型定义，类型别名，类型查询&lt;/p&gt;

&lt;p&gt;结构体：结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。也可以不包含任何字段，称为空结构体。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;type struct_variable_type struct {
   member definition;
   member definition;
   ...
   member definition;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接口：把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。也可以不带任何方法，成为空接口。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;type interface_name interface {
   method_name1 [return_type]
   method_name2 [return_type]
   method_name3 [return_type]
   ...
   method_namen [return_type]
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;切片(Slice)：是对数组的抽象，实现“动态数组”。append()用来将元素添加到切片末尾并返回结果。&lt;/p&gt;

&lt;p&gt;范围(Range)：用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对的 key 值。&lt;/p&gt;

&lt;p&gt;Map(集合)：可以使用内建函数 make 也可以使用 map 关键字来定义 Map&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;/* 声明变量，默认 map 是 nil */
var map_variable map[key_data_type]value_data_type
 
/* 使用 make 函数 */
map_variable := make(map[key_data_type]value_data_type)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;函数定义：不属于任何结构体、类型的方法。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;func function_name([parameter list]) [return_types] {
   函数体
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;方法定义：与函数区别的是，方法在定义的时候，会在func和方法名之间增加一个参数，这个参数就是接收者，这样我们定义的这个方法就和接收者绑定在了一起，称之为这个接收者的方法。&lt;/p&gt;

&lt;p&gt;init()函数：没有输入参数和返回值，用于包(package)的初始化，先于main()函数执行，不被其他函数调用，主要用于程序运行前的注册。&lt;/p&gt;

&lt;h3 id=&quot;5-添加逻辑控制&quot;&gt;5. 添加逻辑控制&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在bp中添加bluetoothext_defaults模块并指定go文件：&lt;/p&gt;

    &lt;p&gt;bootstrap_go_package {
    name: “soong-xxx”,
    pkgPath: “android/soong/xxx”,
    deps: [
    ],
    srcs: [
        “bluetoothext.go”,
    ],
    pluginFor: [“soong_build”],
}&lt;/p&gt;

    &lt;p&gt;// 定义模块
bluetoothext_defaults {
    name: “bluetoothext_defaults”,
}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里需要注意的是，bluetoothext_defaults是自定义的模块，bluetoothext.go配置这个模块包含了哪些内容，编译时需要在Android.bp中引用这个模块。&lt;/p&gt;

&lt;p&gt;2.编写go文件，定制bluetoothext_defaults模块的编译内容：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;package bluetoothext
 
import (
    &quot;android/soong/android&quot;
    &quot;android/soong/cc&quot;
)
 
func init() {
    // bluetoothext_defaults在Android.bp中定义
    android.RegisterModuleType(&quot;bluetoothext_defaults&quot;, bluetoothextDefaultsFactory)
}
 
...
 
func bluetoothextDefaultsFactory() android.Module {
    module := cc.DefaultsFactory()
    android.AddLoadHook(module, bluetoothextDefaults)
 
    return module
}
 
func bluetoothextDefaults(ctx android.LoadHookContext) {
    type props struct {
    //参考mk与bp对照
    }
 
    p := &amp;amp;props{}
    //定制模块内容
 
    ctx.AppendProperties(p)
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.引用自定义的bluetoothext_defaults模块：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// 编译模块中添加定义的模块
cc_library_shared {
    name: &quot;libbluetooth_jni&quot;,
    defaults: [&quot;bluetoothext_defaults&quot;]
    ...
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6-config常用方法&quot;&gt;6. config常用方法&lt;/h3&gt;

&lt;p&gt;参考：&lt;a href=&quot;https://android.googlesource.com/platform/build/soong/+/master/android/config.go&quot;&gt;config.go&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;// 获取编译常量
func (c *config) Getenv(key string) string {}
func (c *config) GetenvWithDefault(key string, defaultValue string) string {}
 
// 判断常量值是否为true
func (c *config) IsEnvTrue(key string) bool {}
 
// 判断常量值是否为false
func (c *config) IsEnvFalse(key string) bool {}
 
// 获取机器名
func (c *config) DeviceName() string {}
 
// 获取Android版本名
func (c *config) PlatformVersionName() string {}
 
// 获取Android版本int值
func (c *config) PlatformSdkVersionInt() int {}
 
// 获取Android版本String值
func (c *config) PlatformSdkVersion() string {}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://android.googlesource.com/platform/build/soong&quot;&gt;soong&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/699cfa0f8a74&quot;&gt;Android soong 代码分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://note.qidong.name/2017/08/android-ninja/&quot;&gt;Android中的Ninja简介&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://note.qidong.name/2017/08/android-blueprint/&quot;&gt;Android编译系统中的Android.bp、Blueprint与Soong&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 08 Apr 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/04/08/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91mk%E8%BD%ACbp/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/04/08/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91mk%E8%BD%ACbp/</guid>
        
        <category>Android</category>
        
        
      </item>
    
  </channel>
</rss>
